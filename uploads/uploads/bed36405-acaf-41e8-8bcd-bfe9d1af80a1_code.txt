## ROLE & PRIMARY GOAL:
You are a "Robotic Senior Software Engineer AI". Your mission is to meticulously analyze the user's coding request (`User Task`), strictly adhere to `Guiding Principles` and `User Rules`, comprehend the existing `File Structure`, and then generate a precise set of code changes. Your *sole and exclusive output* must be a single `git diff` formatted text. Zero tolerance for any deviation from the specified output format.

---

## INPUT SECTIONS OVERVIEW:
1.  `User Task`: The user's coding problem or feature request.
2.  `Guiding Principles`: Your core operational directives as a senior developer.
3.  `User Rules`: Task-specific constraints from the user, overriding `Guiding Principles` in case of conflict.
4.  `Output Format & Constraints`: Strict rules for your *only* output: the `git diff` text.
5.  `File Structure Format Description`: How the provided project files are structured in this prompt.
6.  `File Structure`: The current state of the project's files.

---

## 1. User Task
i want refactor code based on the role the use case keep the logic true 

---

## 2. Guiding Principles (Your Senior Developer Logic)

### A. Analysis & Planning (Internal Thought Process - Do NOT output this part):
1.  **Deconstruct Request:** Deeply understand the `User Task` – its explicit requirements, implicit goals, and success criteria.
2.  **Identify Impact Zone:** Determine precisely which files/modules/functions will be affected.
3.  **Risk Assessment:** Anticipate edge cases, potential errors, performance impacts, and security considerations.
4.  **Assume with Reason:** If ambiguities exist in `User Task`, make well-founded assumptions based on best practices and existing code context. Document these assumptions internally if complex.
5.  **Optimal Solution Path:** Briefly evaluate alternative solutions, selecting the one that best balances simplicity, maintainability, readability, and consistency with existing project patterns.
6.  **Plan Changes:** Before generating diffs, mentally (or internally) outline the specific changes needed for each affected file.

### B. Code Generation & Standards:
*   **Simplicity & Idiomatic Code:** Prioritize the simplest, most direct solution. Write code that is idiomatic for the language and aligns with project conventions (inferred from `File Structure`). Avoid over-engineering.
*   **Respect Existing Architecture:** Strictly follow the established project structure, naming conventions, and coding style.
*   **Type Safety:** Employ type hints/annotations as appropriate for the language.
*   **Modularity:** Design changes to be modular and reusable where sensible.
*   **Documentation:**
    *   Add concise docstrings/comments for new public APIs, complex logic, or non-obvious decisions.
    *   Update existing documentation if changes render it inaccurate.
*   **Logging:** Introduce logging for critical operations or error states if consistent with the project's logging strategy.
*   **No New Dependencies:** Do NOT introduce external libraries/dependencies unless explicitly stated in `User Task` or `User Rules`.
*   **Atomicity of Changes (Hunks):** Each distinct change block (hunk in the diff output) should represent a small, logically coherent modification.
*   **Testability:** Design changes to be testable. If a testing framework is evident in `File Structure` or mentioned in `User Rules`, ensure new code is compatible.

---

## 3. User Rules
no additional rules
*(These are user-provided, project-specific rules or task constraints. They take precedence over `Guiding Principles`.)*

---

## 4. Output Format & Constraints (MANDATORY & STRICT)

Your **ONLY** output will be a single, valid `git diff` formatted text, specifically in the **unified diff format**. No other text, explanations, or apologies are permitted.

### Git Diff Format Structure:
*   If no changes are required, output an empty string.
*   For each modified, newly created, or deleted file, include a diff block. Multiple file diffs are concatenated directly.

### File Diff Block Structure:
A typical diff block for a modified file looks like this:
```diff
diff --git a/relative/path/to/file.ext b/relative/path/to/file.ext
index <hash_old>..<hash_new> <mode>
--- a/relative/path/to/file.ext
+++ b/relative/path/to/file.ext
@@ -START_OLD,LINES_OLD +START_NEW,LINES_NEW @@
 context line (unchanged)
-old line to be removed
+new line to be added
 another context line (unchanged)
```

*   **`diff --git a/path b/path` line:**
    *   Indicates the start of a diff for a specific file.
    *   `a/path/to/file.ext` is the path in the "original" version.
    *   `b/path/to/file.ext` is the path in the "new" version. Paths are project-root-relative, using forward slashes (`/`).
*   **`index <hash_old>..<hash_new> <mode>` line (Optional Detail):**
    *   This line provides metadata about the change. While standard in `git diff`, if generating precise hashes and modes is overly complex for your internal model, you may omit this line or use placeholder values (e.g., `index 0000000..0000000 100644`). The `---`, `+++`, and `@@` lines are the most critical for applying the patch.
*   **`--- a/path/to/file.ext` line:**
    *   Specifies the original file. For **newly created files**, this should be `--- /dev/null`.
*   **`+++ b/path/to/file.ext` line:**
    *   Specifies the new file. For **deleted files**, this should be `+++ /dev/null`. For **newly created files**, this is `+++ b/path/to/new_file.ext`.
*   **Hunk Header (`@@ -START_OLD,LINES_OLD +START_NEW,LINES_NEW @@`):**
    *   `START_OLD,LINES_OLD`: 1-based start line and number of lines from the original file affected by this hunk.
        *   For **newly created files**, this is `0,0`.
        *   For hunks that **only add lines** (no deletions from original), `LINES_OLD` is `0`. (e.g., `@@ -50,0 +51,5 @@` means 5 lines added after original line 50).
    *   `START_NEW,LINES_NEW`: 1-based start line and number of lines in the new file version affected by this hunk.
        *   For **deleted files** (where the entire file is deleted), this is `0,0` for the `+++ /dev/null` part.
        *   For hunks that **only delete lines** (no additions), `LINES_NEW` is `0`. (e.g., `@@ -25,3 +25,0 @@` means 3 lines deleted starting from original line 25).
*   **Hunk Content:**
    *   Lines prefixed with a space (` `) are context lines (unchanged).
    *   Lines prefixed with a minus (`-`) are lines removed from the original file.
    *   Lines prefixed with a plus (`+`) are lines added to the new file.
    *   Include at least 3 lines of unchanged context around changes, where available. If changes are at the very beginning or end of a file, or if hunks are very close, fewer context lines are acceptable as per standard unified diff practice.

### Specific Cases:
*   **Newly Created Files:**
    ```diff
    diff --git a/relative/path/to/new_file.ext b/relative/path/to/new_file.ext
    new file mode 100644
    index 0000000..<hash_new_placeholder>
    --- /dev/null
    +++ b/relative/path/to/new_file.ext
    @@ -0,0 +1,LINES_IN_NEW_FILE @@
    +line 1 of new file
    +line 2 of new file
    ...
    ```
    *(The `new file mode` and `index` lines should be included. Use `100644` for regular files. For the hash in the `index` line, a placeholder like `abcdef0` is acceptable if the actual hash cannot be computed.)*

*   **Deleted Files:**
    ```diff
    diff --git a/relative/path/to/deleted_file.ext b/relative/path/to/deleted_file.ext
    deleted file mode <mode_old_placeholder>
    index <hash_old_placeholder>..0000000
    --- a/relative/path/to/deleted_file.ext
    +++ /dev/null
    @@ -1,LINES_IN_OLD_FILE +0,0 @@
    -line 1 of old file
    -line 2 of old file
    ...
    ```
    *(The `deleted file mode` and `index` lines should be included. Use a placeholder like `100644` for mode and `abcdef0` for hash if actual values are unknown.)*

*   **Untouched Files:** Do NOT include any diff output for files that have no changes.

### General Constraints on Generated Code:
*   **Minimal & Precise Changes:** Generate the smallest, most targeted diff that correctly implements the `User Task` per all rules.
*   **Preserve Integrity:** Do not break existing functionality unless the `User Task` explicitly requires it. The codebase should remain buildable/runnable.
*   **Leverage Existing Code:** Prefer modifying existing files over creating new ones, unless a new file is architecturally justified or required by `User Task` or `User Rules`.

---

## 5. File Structure Format Description
The `File Structure` (provided in the next section) is formatted as follows:
1.  An initial project directory tree structure (e.g., generated by `tree` or similar).
2.  Followed by the content of each file, using an XML-like structure:
    <file path="RELATIVE/PATH/TO/FILE">
    (File content here)
    </file>
    The `path` attribute contains the project-root-relative path, using forward slashes (`/`).
    File content is the raw text of the file. Each file block is separated by a newline.

---

## 6. File Structure
doproject\
├── .mvn
├── backend
│   └── doproject
│       └── uploads
│           └── materials
│               ├── 1
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 10
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 2
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 3
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 4
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 5
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 51
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 52
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 53
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 54
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 55
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 56
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 6
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 7
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               ├── 8
│               │   ├── course_handbook.pdf
│               │   ├── exercises.docx
│               │   ├── lecture_notes.txt
│               │   └── textbook.pdf
│               └── 9
│                   ├── course_handbook.pdf
│                   ├── exercises.docx
│                   ├── lecture_notes.txt
│                   └── textbook.pdf
├── sql
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       ├── classroomapp
│       │       │   ├── classroombackend
│       │       │   │   ├── config
│       │       │   │   │   ├── seed
│       │       │   │   │   │   ├── AccomplishmentSeeder.java
│       │       │   │   │   │   ├── AnnouncementSeeder.java
│       │       │   │   │   │   ├── AssignmentSeeder.java
│       │       │   │   │   │   ├── AssignmentTestDataSeeder.java
│       │       │   │   │   │   ├── AttendanceSeeder.java
│       │       │   │   │   │   ├── BlogSeeder.java
│       │       │   │   │   │   ├── ClassroomEnrollmentSeeder.java
│       │       │   │   │   │   ├── ClassroomSeeder.java
│       │       │   │   │   │   ├── ComprehensiveGradingSeeder.java
│       │       │   │   │   │   ├── CourseMaterialSeeder.java
│       │       │   │   │   │   ├── CourseSeeder.java
│       │       │   │   │   │   ├── DatabaseCleanupService.java
│       │       │   │   │   │   ├── DatabaseVerificationSeeder.java
│       │       │   │   │   │   ├── DataVerificationSeeder.java
│       │       │   │   │   │   ├── ExamSeeder.java
│       │       │   │   │   │   ├── LectureSeeder.java
│       │       │   │   │   │   ├── MasterSeeder.java
│       │       │   │   │   │   ├── MessageSeeder.java
│       │       │   │   │   │   ├── RequestSeeder.java
│       │       │   │   │   │   ├── RoleSeeder.java
│       │       │   │   │   │   ├── ScheduleSeeder.java
│       │       │   │   │   │   ├── StudentProgressSeeder.java
│       │       │   │   │   │   ├── SubmissionSeeder.java
│       │       │   │   │   │   ├── TeachingHistorySeeder.java
│       │       │   │   │   │   ├── TimetableEventSeeder.java
│       │       │   │   │   │   └── UserSeeder.java
│       │       │   │   │   ├── AppConfig.java
│       │       │   │   │   ├── CharsetFilter.java
│       │       │   │   │   ├── CustomCorsFilter.java
│       │       │   │   │   ├── DatabaseConfig.java
│       │       │   │   │   ├── DataLoader.java
│       │       │   │   │   ├── EmailConfig.java
│       │       │   │   │   ├── FirebaseConfig.java
│       │       │   │   │   ├── JacksonConfig.java
│       │       │   │   │   ├── MCPConfig.java
│       │       │   │   │   ├── ModelMapperConfig.java
│       │       │   │   │   ├── ProductionApplicationConfig.java
│       │       │   │   │   ├── SecurityConfig.java
│       │       │   │   │   ├── ThymeleafConfig.java
│       │       │   │   │   ├── UTF8EncodingConfig.java
│       │       │   │   │   ├── UTF8EncodingFixer.java
│       │       │   │   │   ├── WebConfig.java
│       │       │   │   │   └── WebSocketConfig.java
│       │       │   │   ├── constants
│       │       │   │   │   └── RoleConstants.java
│       │       │   │   ├── controller
│       │       │   │   │   ├── AcademicPerformanceController.java
│       │       │   │   │   ├── AccomplishmentController.java
│       │       │   │   │   ├── AdminController.java
│       │       │   │   │   ├── AdminRequestController.java
│       │       │   │   │   ├── AnnouncementController.java
│       │       │   │   │   ├── AssignmentController.java
│       │       │   │   │   ├── AttendanceController.java
│       │       │   │   │   ├── AttendanceSessionController.java
│       │       │   │   │   ├── AuthController.java
│       │       │   │   │   ├── BlogController.java
│       │       │   │   │   ├── ClassroomController.java
│       │       │   │   │   ├── CourseController.java
│       │       │   │   │   ├── CourseFeedbackController.java
│       │       │   │   │   ├── CourseMaterialController.java
│       │       │   │   │   ├── DatabaseHealthController.java
│       │       │   │   │   ├── DebugController.java
│       │       │   │   │   ├── EducationalRoleController.java
│       │       │   │   │   ├── ExamController.java
│       │       │   │   │   ├── ExamSubmissionController.java
│       │       │   │   │   ├── FileDownloadController.java
│       │       │   │   │   ├── FileUploadController.java
│       │       │   │   │   ├── FrontendApiBridgeController.java
│       │       │   │   │   ├── GreetingController.java
│       │       │   │   │   ├── HealthController.java
│       │       │   │   │   ├── LectureController.java
│       │       │   │   │   ├── MaterialController.java
│       │       │   │   │   ├── MCPController.java
│       │       │   │   │   ├── MCPTestController.java
│       │       │   │   │   ├── NotificationController.java
│       │       │   │   │   ├── RoleRequestController.java
│       │       │   │   │   ├── ScheduleController.java
│       │       │   │   │   ├── StudentController.java
│       │       │   │   │   ├── StudentMessageController.java
│       │       │   │   │   ├── StudentQuestionController.java
│       │       │   │   │   ├── SubmissionController.java
│       │       │   │   │   ├── TeacherController.java
│       │       │   │   │   ├── TestController.java
│       │       │   │   │   ├── TimetableController.java
│       │       │   │   │   ├── UserController.java
│       │       │   │   │   ├── UTF8TestController.java
│       │       │   │   │   ├── VideoConferenceController.java
│       │       │   │   │   └── VietnameseSpeechRecognitionController.java
│       │       │   │   ├── debug
│       │       │   │   │   └── GradingWorkflowDebugger.java
│       │       │   │   ├── dto
│       │       │   │   │   ├── assignmentmanagement
│       │       │   │   │   │   ├── AssignmentDto.java
│       │       │   │   │   │   ├── CreateAssignmentDto.java
│       │       │   │   │   │   ├── CreateSubmissionDto.java
│       │       │   │   │   │   ├── GradeSubmissionDto.java
│       │       │   │   │   │   └── SubmissionDto.java
│       │       │   │   │   ├── attendancemanagement
│       │       │   │   │   │   ├── AttendanceDto.java
│       │       │   │   │   │   ├── AttendanceRecordDto.java
│       │       │   │   │   │   ├── AttendanceResultDto.java
│       │       │   │   │   │   ├── AttendanceSessionDto.java
│       │       │   │   │   │   ├── AttendanceSubmitDto.java
│       │       │   │   │   │   ├── CreateAttendanceSessionDto.java
│       │       │   │   │   │   ├── CreateOrUpdateAttendanceDto.java
│       │       │   │   │   │   ├── MyAttendanceHistoryDto.java
│       │       │   │   │   │   ├── StudentAttendanceDto.java
│       │       │   │   │   │   └── TeachingHistoryDto.java
│       │       │   │   │   ├── classroommanagement
│       │       │   │   │   │   ├── ClassroomDetailsDto.java
│       │       │   │   │   │   ├── ClassroomDto.java
│       │       │   │   │   │   ├── CourseDetailsDto.java
│       │       │   │   │   │   ├── CreateClassroomDto.java
│       │       │   │   │   │   ├── EnrollmentRequestDto.java
│       │       │   │   │   │   ├── SyllabusDto.java
│       │       │   │   │   │   └── UpdateClassroomDto.java
│       │       │   │   │   ├── exammangement
│       │       │   │   │   │   ├── CreateExamDto.java
│       │       │   │   │   │   ├── CreateExamSubmissionDto.java
│       │       │   │   │   │   ├── ExamDto.java
│       │       │   │   │   │   ├── ExamSubmissionDto.java
│       │       │   │   │   │   └── GradeExamDto.java
│       │       │   │   │   ├── requestmanagement
│       │       │   │   │   │   ├── CreateRequestDto.java
│       │       │   │   │   │   └── RequestDTO.java
│       │       │   │   │   ├── usermanagement
│       │       │   │   │   │   ├── UpdateUserRolesRequest.java
│       │       │   │   │   │   ├── UpdateUserStatusRequest.java
│       │       │   │   │   │   ├── UserDetailsDto.java
│       │       │   │   │   │   └── UserMapper.java
│       │       │   │   │   ├── AccomplishmentDto.java
│       │       │   │   │   ├── AddMaterialsRequest.java
│       │       │   │   │   ├── AnnouncementAttachmentDto.java
│       │       │   │   │   ├── AnnouncementDto.java
│       │       │   │   │   ├── ApiResponse.java
│       │       │   │   │   ├── AssessmentDto.java
│       │       │   │   │   ├── AssignmentDto.java
│       │       │   │   │   ├── AssignmentRubricDto.java
│       │       │   │   │   ├── AssignmentSubmissionDto.java
│       │       │   │   │   ├── AttendanceDto.java
│       │       │   │   │   ├── AttendanceSessionDto.java
│       │       │   │   │   ├── BlogDto.java
│       │       │   │   │   ├── BulkGradeEntryDto.java
│       │       │   │   │   ├── BulkGradingDto.java
│       │       │   │   │   ├── BulkGradingResultDto.java
│       │       │   │   │   ├── ClassroomDto.java
│       │       │   │   │   ├── CourseFeedbackDto.java
│       │       │   │   │   ├── CourseMaterialDto.java
│       │       │   │   │   ├── CourseScheduleDto.java
│       │       │   │   │   ├── CreateAnnouncementDto.java
│       │       │   │   │   ├── CreateAssessmentDto.java
│       │       │   │   │   ├── CreateAssignmentDto.java
│       │       │   │   │   ├── CreateBlogDto.java
│       │       │   │   │   ├── CreateClassroomDto.java
│       │       │   │   │   ├── CreateEventDto.java
│       │       │   │   │   ├── CreateFeedbackDto.java
│       │       │   │   │   ├── CreateLectureDto.java
│       │       │   │   │   ├── CreateLectureMaterialDto.java
│       │       │   │   │   ├── CreateRubricCriteriaDto.java
│       │       │   │   │   ├── CreateRubricDto.java
│       │       │   │   │   ├── CreateScheduleItemDto.java
│       │       │   │   │   ├── CreateSubmissionDto.java
│       │       │   │   │   ├── CreateUserDto.java
│       │       │   │   │   ├── EventAttendeeDto.java
│       │       │   │   │   ├── FeedbackDto.java
│       │       │   │   │   ├── FileUploadResponse.java
│       │       │   │   │   ├── GoogleAuthRequestDto.java
│       │       │   │   │   ├── GradeDto.java
│       │       │   │   │   ├── GradingAnalyticsDto.java
│       │       │   │   │   ├── JwtResponseDto.java
│       │       │   │   │   ├── LectureDetailsDto.java
│       │       │   │   │   ├── LectureDto.java
│       │       │   │   │   ├── LectureMaterialDto.java
│       │       │   │   │   ├── LiveStreamDto.java
│       │       │   │   │   ├── LiveStreamStatusDto.java
│       │       │   │   │   ├── LocationDataDto.java
│       │       │   │   │   ├── LoginDto.java
│       │       │   │   │   ├── LoginRequest.java
│       │       │   │   │   ├── LoginRequestDto.java
│       │       │   │   │   ├── LoginResponseDto.java
│       │       │   │   │   ├── NotificationDto.java
│       │       │   │   │   ├── PasswordConfirmationDto.java
│       │       │   │   │   ├── PasswordResetRequestDto.java
│       │       │   │   │   ├── ProgressAnalyticsDto.java
│       │       │   │   │   ├── RecordingSessionDto.java
│       │       │   │   │   ├── RegisterDto.java
│       │       │   │   │   ├── RequestDTO.java
│       │       │   │   │   ├── RequestResponseDTO.java
│       │       │   │   │   ├── RubricCriteriaDto.java
│       │       │   │   │   ├── ScheduleDto.java
│       │       │   │   │   ├── ScheduleItemDto.java
│       │       │   │   │   ├── StudentDto.java
│       │       │   │   │   ├── StudentMessageDto.java
│       │       │   │   │   ├── StudentProgressDto.java
│       │       │   │   │   ├── StudentQuestionDto.java
│       │       │   │   │   ├── StudentRequestFormDTO.java
│       │       │   │   │   ├── SubmissionDto.java
│       │       │   │   │   ├── TeacherRequestFormDTO.java
│       │       │   │   │   ├── TimetableEventDto.java
│       │       │   │   │   ├── UpdateLectureDto.java
│       │       │   │   │   ├── UploadMaterialDto.java
│       │       │   │   │   └── UserDto.java
│       │       │   │   ├── exception
│       │       │   │   │   ├── BusinessLogicException.java
│       │       │   │   │   ├── ErrorResponse.java
│       │       │   │   │   ├── FileStorageException.java
│       │       │   │   │   ├── GlobalExceptionHandler.java
│       │       │   │   │   ├── ResourceNotFoundException.java
│       │       │   │   │   ├── UnauthorizedException.java
│       │       │   │   │   └── ValidationErrorResponse.java
│       │       │   │   ├── filter
│       │       │   │   │   └── JwtAuthenticationFilter.java
│       │       │   │   ├── mcp
│       │       │   │   │   ├── client
│       │       │   │   │   │   └── MCPClient.java
│       │       │   │   │   ├── tools
│       │       │   │   │   │   ├── DatabaseQueryTool.java
│       │       │   │   │   │   ├── DatabaseSchemaTool.java
│       │       │   │   │   │   └── TableInspectionTool.java
│       │       │   │   │   ├── MCPRequest.java
│       │       │   │   │   ├── MCPResponse.java
│       │       │   │   │   ├── MCPServer.java
│       │       │   │   │   └── MCPTool.java
│       │       │   │   ├── model
│       │       │   │   │   ├── assignmentmanagement
│       │       │   │   │   │   ├── Assignment.java
│       │       │   │   │   │   ├── AssignmentAttachment.java
│       │       │   │   │   │   ├── Submission.java
│       │       │   │   │   │   └── SubmissionAttachment.java
│       │       │   │   │   ├── attendancemanagement
│       │       │   │   │   │   ├── Attendance.java
│       │       │   │   │   │   ├── AttendanceSession.java
│       │       │   │   │   │   └── AttendanceStatus.java
│       │       │   │   │   ├── classroommanagement
│       │       │   │   │   │   ├── Classroom.java
│       │       │   │   │   │   ├── ClassroomEnrollment.java
│       │       │   │   │   │   ├── ClassroomEnrollmentId.java
│       │       │   │   │   │   ├── ClassroomSchedule.java
│       │       │   │   │   │   ├── Course.java
│       │       │   │   │   │   └── Syllabus.java
│       │       │   │   │   ├── exammangement
│       │       │   │   │   │   ├── Exam.java
│       │       │   │   │   │   └── ExamSubmission.java
│       │       │   │   │   ├── usermanagement
│       │       │   │   │   │   ├── Role.java
│       │       │   │   │   │   └── User.java
│       │       │   │   │   ├── Accomplishment.java
│       │       │   │   │   ├── AllowedIp.java
│       │       │   │   │   ├── Announcement.java
│       │       │   │   │   ├── AnnouncementAttachment.java
│       │       │   │   │   ├── AnnouncementRead.java
│       │       │   │   │   ├── Assessment.java
│       │       │   │   │   ├── Blog.java
│       │       │   │   │   ├── ClassSession.java
│       │       │   │   │   ├── CourseFeedback.java
│       │       │   │   │   ├── CourseMaterial.java
│       │       │   │   │   ├── CourseSchedule.java
│       │       │   │   │   ├── EducationalRole.java
│       │       │   │   │   ├── EventAttendee.java
│       │       │   │   │   ├── Exam.java
│       │       │   │   │   ├── GradingDetail.java
│       │       │   │   │   ├── GradingRubric.java
│       │       │   │   │   ├── Lecture.java
│       │       │   │   │   ├── LectureMaterial.java
│       │       │   │   │   ├── LectureRecording.java
│       │       │   │   │   ├── LiveStream.java
│       │       │   │   │   ├── Notification.java
│       │       │   │   │   ├── QuizQuestion.java
│       │       │   │   │   ├── QuizQuestionOption.java
│       │       │   │   │   ├── Request.java
│       │       │   │   │   ├── Schedule.java
│       │       │   │   │   ├── StudentMessage.java
│       │       │   │   │   ├── StudentProgress.java
│       │       │   │   │   ├── StudentQuestion.java
│       │       │   │   │   ├── StudentQuizAnswer.java
│       │       │   │   │   └── TimetableEvent.java
│       │       │   │   ├── repository
│       │       │   │   │   ├── assignmentmanagement
│       │       │   │   │   │   ├── AssignmentRepository.java
│       │       │   │   │   │   └── SubmissionRepository.java
│       │       │   │   │   ├── attendancemanagement
│       │       │   │   │   │   ├── AttendanceRepository.java
│       │       │   │   │   │   └── AttendanceSessionRepository.java
│       │       │   │   │   ├── classroommanagement
│       │       │   │   │   │   ├── ClassroomEnrollmentRepository.java
│       │       │   │   │   │   ├── ClassroomRepository.java
│       │       │   │   │   │   ├── ClassroomScheduleRepository.java
│       │       │   │   │   │   ├── CourseRepository.java
│       │       │   │   │   │   └── SyllabusRepository.java
│       │       │   │   │   ├── exammangement
│       │       │   │   │   │   ├── ExamRepository.java
│       │       │   │   │   │   └── ExamSubmissionRepository.java
│       │       │   │   │   ├── requestmanagement
│       │       │   │   │   │   └── RequestRepository.java
│       │       │   │   │   ├── usermanagement
│       │       │   │   │   │   ├── RoleRepository.java
│       │       │   │   │   │   └── UserRepository.java
│       │       │   │   │   ├── AccomplishmentRepository.java
│       │       │   │   │   ├── AllowedIpRepository.java
│       │       │   │   │   ├── AnnouncementAttachmentRepository.java
│       │       │   │   │   ├── AnnouncementReadRepository.java
│       │       │   │   │   ├── AnnouncementRepository.java
│       │       │   │   │   ├── AssessmentRepository.java
│       │       │   │   │   ├── BlogRepository.java
│       │       │   │   │   ├── CourseFeedbackRepository.java
│       │       │   │   │   ├── CourseMaterialRepository.java
│       │       │   │   │   ├── CourseScheduleRepository.java
│       │       │   │   │   ├── GradingDetailRepository.java
│       │       │   │   │   ├── GradingRubricRepository.java
│       │       │   │   │   ├── LectureMaterialRepository.java
│       │       │   │   │   ├── LectureRepository.java
│       │       │   │   │   ├── NotificationRepository.java
│       │       │   │   │   ├── ScheduleRepository.java
│       │       │   │   │   ├── StudentMessageRepository.java
│       │       │   │   │   ├── StudentProgressRepository.java
│       │       │   │   │   ├── StudentQuestionRepository.java
│       │       │   │   │   └── TimetableEventRepository.java
│       │       │   │   ├── security
│       │       │   │   │   ├── jwt
│       │       │   │   │   │   ├── JwtAuthTokenFilter.java
│       │       │   │   │   │   └── JwtUtils.java
│       │       │   │   │   ├── BlogPermissionEvaluator.java
│       │       │   │   │   ├── CustomUserDetails.java
│       │       │   │   │   ├── CustomUserDetailsService.java
│       │       │   │   │   └── JwtUtil.java
│       │       │   │   ├── service
│       │       │   │   │   ├── diagnostics
│       │       │   │   │   ├── impl
│       │       │   │   │   │   ├── AccomplishmentServiceImpl.java
│       │       │   │   │   │   ├── AdminRequestServiceImpl.java
│       │       │   │   │   │   ├── AnnouncementServiceImpl.java
│       │       │   │   │   │   ├── AssessmentServiceImpl.java
│       │       │   │   │   │   ├── AssignmentServiceImpl.java
│       │       │   │   │   │   ├── AttendanceServiceImpl.java
│       │       │   │   │   │   ├── AttendanceSessionServiceImpl.java
│       │       │   │   │   │   ├── AuthServiceImpl.java
│       │       │   │   │   │   ├── BlogServiceImpl.java
│       │       │   │   │   │   ├── ClassroomSecurityServiceImpl.java
│       │       │   │   │   │   ├── ClassroomServiceImpl.java
│       │       │   │   │   │   ├── CourseFeedbackServiceImpl.java
│       │       │   │   │   │   ├── CourseMaterialServiceImpl.java
│       │       │   │   │   │   ├── CourseServiceImpl.java
│       │       │   │   │   │   ├── DummyFileStorageServiceImpl.java
│       │       │   │   │   │   ├── EmailService.java
│       │       │   │   │   │   ├── EmailServiceDummyImpl.java
│       │       │   │   │   │   ├── EmailServiceImpl.java
│       │       │   │   │   │   ├── ExamServiceImpl.java
│       │       │   │   │   │   ├── ExamSubmissionServiceImpl.java
│       │       │   │   │   │   ├── FirebaseStorageServiceImpl.java
│       │       │   │   │   │   ├── LectureMaterialServiceImpl.java
│       │       │   │   │   │   ├── LectureServiceImpl.java
│       │       │   │   │   │   ├── LocalFileStorageServiceImpl.java
│       │       │   │   │   │   ├── RequestServiceImpl.java
│       │       │   │   │   │   ├── ScheduleServiceImpl.java
│       │       │   │   │   │   ├── StudentMessageServiceImpl.java
│       │       │   │   │   │   ├── StudentQuestionServiceImpl.java
│       │       │   │   │   │   ├── SubmissionServiceImpl.java
│       │       │   │   │   │   ├── TimetableServiceImpl.java
│       │       │   │   │   │   ├── UserServiceExtensionImpl.java
│       │       │   │   │   │   └── UserServiceImpl.java
│       │       │   │   │   ├── AcademicPerformanceService.java
│       │       │   │   │   ├── AccomplishmentSecurityService.java
│       │       │   │   │   ├── AccomplishmentService.java
│       │       │   │   │   ├── AdminRequestService.java
│       │       │   │   │   ├── AnnouncementService.java
│       │       │   │   │   ├── AssessmentService.java
│       │       │   │   │   ├── AssignmentService.java
│       │       │   │   │   ├── AttendanceService.java
│       │       │   │   │   ├── AttendanceSessionService.java
│       │       │   │   │   ├── AuthService.java
│       │       │   │   │   ├── BlogService.java
│       │       │   │   │   ├── ClassroomSecurityService.java
│       │       │   │   │   ├── ClassroomService.java
│       │       │   │   │   ├── CourseFeedbackService.java
│       │       │   │   │   ├── CourseMaterialService.java
│       │       │   │   │   ├── CourseService.java
│       │       │   │   │   ├── EducationalRoleService.java
│       │       │   │   │   ├── EmailService.java
│       │       │   │   │   ├── ExamService.java
│       │       │   │   │   ├── ExamSubmissionService.java
│       │       │   │   │   ├── FileStorageService.java
│       │       │   │   │   ├── LectureMaterialService.java
│       │       │   │   │   ├── LectureService.java
│       │       │   │   │   ├── MCPTestService.java
│       │       │   │   │   ├── RequestService.java
│       │       │   │   │   ├── ScheduleService.java
│       │       │   │   │   ├── SignalingWebSocketHandler.java
│       │       │   │   │   ├── StudentMessageService.java
│       │       │   │   │   ├── StudentProgressService.java
│       │       │   │   │   ├── StudentQuestionService.java
│       │       │   │   │   ├── SubmissionService.java
│       │       │   │   │   ├── TimetableService.java
│       │       │   │   │   ├── UserService.java
│       │       │   │   │   ├── UserServiceExtension.java
│       │       │   │   │   ├── VideoConferenceService.java
│       │       │   │   │   ├── VietnameseSpeechRecognitionService.java
│       │       │   │   │   └── VietnameseTextValidationService.java
│       │       │   │   ├── test
│       │       │   │   │   └── CriticalFixesTestRunner.java
│       │       │   │   ├── util
│       │       │   │   │   ├── EntityScanVerifier.java
│       │       │   │   │   └── PasswordHasher.java
│       │       │   │   ├── websocket
│       │       │   │   │   └── VideoConferenceSignalingServer.java
│       │       │   │   └── ClassroomBackendApplication.java
│       │       │   └── readMe
│       │       └── Hrm
│       └── resources
│           ├── sql
│           ├── static
│           │   ├── sample_materials
│           │   │   └── sample.pdf
│           │   └── architecture.txt
│           ├── templates
│           │   └── email
│           │       ├── request-approved.html
│           │       ├── request-received.html
│           │       └── request-rejected.html
│           ├── application.properties
│           └── sep490-e5896-firebase-adminsdk-fbsvc-402079bade.json
├── .gitignore
└── pom.xml

<file path="backend/doproject/uploads/materials/1/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Mathematics) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/1/exercises.docx">
Sample DOCX content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/1/lecture_notes.txt">
Sample lecture notes for Mathematics

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/1/textbook.pdf">
Sample PDF content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/10/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/10/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/10/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/10/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/2/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Literature) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/2/exercises.docx">
Sample DOCX content for Literature
</file>
<file path="backend/doproject/uploads/materials/2/lecture_notes.txt">
Sample lecture notes for Literature

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/2/textbook.pdf">
Sample PDF content for Literature
</file>
<file path="backend/doproject/uploads/materials/3/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: English) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/3/exercises.docx">
Sample DOCX content for English
</file>
<file path="backend/doproject/uploads/materials/3/lecture_notes.txt">
Sample lecture notes for English

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/3/textbook.pdf">
Sample PDF content for English
</file>
<file path="backend/doproject/uploads/materials/4/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/4/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/4/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/4/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/5/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/5/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/5/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/5/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/51/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Mathematics) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/51/exercises.docx">
Sample DOCX content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/51/lecture_notes.txt">
Sample lecture notes for Mathematics

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/51/textbook.pdf">
Sample PDF content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/52/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Literature) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/52/exercises.docx">
Sample DOCX content for Literature
</file>
<file path="backend/doproject/uploads/materials/52/lecture_notes.txt">
Sample lecture notes for Literature

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/52/textbook.pdf">
Sample PDF content for Literature
</file>
<file path="backend/doproject/uploads/materials/53/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: English) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/53/exercises.docx">
Sample DOCX content for English
</file>
<file path="backend/doproject/uploads/materials/53/lecture_notes.txt">
Sample lecture notes for English

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/53/textbook.pdf">
Sample PDF content for English
</file>
<file path="backend/doproject/uploads/materials/54/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/54/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/54/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/54/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/55/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/55/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/55/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/55/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/56/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Mathematics) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/56/exercises.docx">
Sample DOCX content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/56/lecture_notes.txt">
Sample lecture notes for Mathematics

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/56/textbook.pdf">
Sample PDF content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/6/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Mathematics) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/6/exercises.docx">
Sample DOCX content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/6/lecture_notes.txt">
Sample lecture notes for Mathematics

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/6/textbook.pdf">
Sample PDF content for Mathematics
</file>
<file path="backend/doproject/uploads/materials/7/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Literature) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/7/exercises.docx">
Sample DOCX content for Literature
</file>
<file path="backend/doproject/uploads/materials/7/lecture_notes.txt">
Sample lecture notes for Literature

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/7/textbook.pdf">
Sample PDF content for Literature
</file>
<file path="backend/doproject/uploads/materials/8/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: English) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/8/exercises.docx">
Sample DOCX content for English
</file>
<file path="backend/doproject/uploads/materials/8/lecture_notes.txt">
Sample lecture notes for English

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/8/textbook.pdf">
Sample PDF content for English
</file>
<file path="backend/doproject/uploads/materials/9/course_handbook.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Course Handbook: Computer Science) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF
</file>
<file path="backend/doproject/uploads/materials/9/exercises.docx">
Sample DOCX content for Computer Science
</file>
<file path="backend/doproject/uploads/materials/9/lecture_notes.txt">
Sample lecture notes for Computer Science

These are detailed notes about the course content.
- Topic 1: Introduction
- Topic 2: Main concepts
- Topic 3: Advanced techniques

Remember to review these notes before the exam!
</file>
<file path="backend/doproject/uploads/materials/9/textbook.pdf">
Sample PDF content for Computer Science
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/AccomplishmentSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDate;
import java.util.List;
import java.util.Random;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Accomplishment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.AccomplishmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class AccomplishmentSeeder {

    @Autowired
    private AccomplishmentRepository accomplishmentRepository;

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;

    private final Random random = new Random();

    public void seed() {
        if (accomplishmentRepository.count() > 0) {
            System.out.println("✅ [AccomplishmentSeeder] Accomplishments already seeded.");
            return;
        }

        List<User> students = userRepository.findByRoleId(1); // STUDENT role
        List<Classroom> classrooms = classroomRepository.findAll();

        if (students.isEmpty() || classrooms.isEmpty()) {
            System.out.println("⚠️ [AccomplishmentSeeder] No students or classrooms found. Skipping.");
            return;
        }
        
        System.out.println("🔄 [AccomplishmentSeeder] Seeding accomplishments...");

        int accomplishmentCount = 0;
        // Seed accomplishments for up to 5 students
        for (int i = 0; i < Math.min(5, students.size()); i++) {
            User student = students.get(i);
            
            // Give each student 2-4 accomplishments
            int numAccomplishments = 2 + random.nextInt(3); // 2 to 4
            for (int j = 0; j < numAccomplishments; j++) {
                // Pick a random classroom to represent a completed course
                Classroom classroom = classrooms.get(random.nextInt(classrooms.size()));
                
                Accomplishment accomplishment = new Accomplishment();
                accomplishment.setStudent(student);
                accomplishment.setCourseTitle(classroom.getName());
                accomplishment.setSubject(classroom.getSubject());
                accomplishment.setTeacherName(classroom.getTeacher() != null ? classroom.getTeacher().getFullName() : "N/A");
                accomplishment.setGrade(65.0 + random.nextDouble() * 35.0); // Grade between 65.0 and 100.0
                accomplishment.setCompletionDate(LocalDate.now().minusDays(30 + random.nextInt(300))); // Completed in the last year
                
                accomplishmentRepository.save(accomplishment);
                accomplishmentCount++;
            }
        }
        System.out.println("✅ [AccomplishmentSeeder] Created " + accomplishmentCount + " sample accomplishments.");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/AnnouncementSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.List;

import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.CreateAnnouncementDto;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.AnnouncementRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AnnouncementService;

@Component
public class AnnouncementSeeder {

    private final AnnouncementRepository announcementRepository;
    private final UserRepository userRepository;
    private final AnnouncementService announcementService;
    private final ClassroomRepository classroomRepository;

    public AnnouncementSeeder(AnnouncementRepository announcementRepository, UserRepository userRepository, AnnouncementService announcementService, ClassroomRepository classroomRepository) {
        this.announcementRepository = announcementRepository;
        this.userRepository = userRepository;
        this.announcementService = announcementService;
        this.classroomRepository = classroomRepository;
    }

    @Transactional
    public void seed() {
        if (announcementRepository.count() > 0) {
            System.out.println("✅ [AnnouncementSeeder] Announcements already exist. Seeding more for testing.");
        }

        // Find users by role for creating announcements
        User admin = userRepository.findByRoleId(4).stream().findFirst().orElse(null); // ADMIN
        User teacher = userRepository.findByRoleId(2).stream().findFirst().orElse(null); // TEACHER
        List<Classroom> classrooms = classroomRepository.findAll();

        if (admin == null || teacher == null) {
            System.out.println("⚠️ [AnnouncementSeeder] Admin or Teacher users not found. Skipping announcement seeding.");
            return;
        }

            if (classrooms.isEmpty()) {
                System.out.println("⚠️ [AnnouncementSeeder] No classrooms found. Skipping classroom-specific announcements.");
            }

            Classroom classroom1 = classrooms.stream().findFirst().orElse(null);

            // Announcement 1: Global from Admin
            CreateAnnouncementDto announcement1Dto = new CreateAnnouncementDto();
            announcement1Dto.setTitle("Chào mừng đến với hệ thống học tập trực tuyến mới");
            announcement1Dto.setContent("Chúng tôi vui mừng thông báo ra mắt hệ thống quản lý lớp học mới. Hệ thống cung cấp nhiều tính năng hữu ích cho cả giáo viên và học sinh.");
            announcement1Dto.setTargetAudience("ALL");
            announcement1Dto.setPriority("HIGH");
            announcementService.createAnnouncement(announcement1Dto, admin.getId());

            // Announcement 2: Classroom-specific from Teacher
            if (classroom1 != null) {
                CreateAnnouncementDto announcement2Dto = new CreateAnnouncementDto();
                announcement2Dto.setTitle("Thông báo về lịch thi giữa kỳ");
                announcement2Dto.setContent("Lịch thi giữa kỳ môn học sẽ diễn ra vào tuần tới. Chi tiết về thời gian và địa điểm sẽ được cập nhật sớm.");
                announcement2Dto.setClassroomId(classroom1.getId());
                announcement2Dto.setTargetAudience("STUDENTS");
                announcement2Dto.setPriority("NORMAL");
                announcementService.createAnnouncement(announcement2Dto, teacher.getId());
            }

            // Announcement 3: System maintenance
            CreateAnnouncementDto announcement3Dto = new CreateAnnouncementDto();
            announcement3Dto.setTitle("Thông báo bảo trì hệ thống");
            announcement3Dto.setContent("Hệ thống sẽ được bảo trì vào lúc 2 giờ sáng Chủ Nhật tuần này. Vui lòng lưu lại công việc của bạn trước thời gian này.");
            announcement3Dto.setTargetAudience("ALL");
            announcement3Dto.setPriority("URGENT");
            announcementService.createAnnouncement(announcement3Dto, admin.getId());
            
            System.out.println("✅ [AnnouncementSeeder] Created 3 sample announcements and their notifications.");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/AssignmentSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateAssignmentDto;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.service.AssignmentService;

@Component
public class AssignmentSeeder {

    @Autowired
    private AssignmentRepository assignmentRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;

    @Autowired
    @Lazy
    private AssignmentService assignmentService;

    @Transactional
    public void seed() {
        if (assignmentRepository.count() == 0) {
            List<Classroom> classrooms = classroomRepository.findAll();
            
            if (classrooms.isEmpty()) {
                System.out.println("⚠️ [AssignmentSeeder] No classrooms found. Skipping.");
                 return;
            }

            // Find specific classes by name (partial match)
            Classroom mathClass = findClassroomByPartialName(classrooms, "Toán");
            Classroom litClass = findClassroomByPartialName(classrooms, "Văn");
            Classroom engClass = findClassroomByPartialName(classrooms, "Anh");
            Classroom csClass = findClassroomByPartialName(classrooms, "Công nghệ");
            
            // Create Math assignments
            if (mathClass != null) {
                // Assignment 1 for Math
                CreateAssignmentDto mathAssignment1Dto = new CreateAssignmentDto();
                mathAssignment1Dto.setTitle("Bài tập về Đạo hàm và Tích phân");
                mathAssignment1Dto.setDescription("Giải các bài tập từ 1-10 trong giáo trình Toán cao cấp A1, chương 3.");
                mathAssignment1Dto.setDueDate(LocalDateTime.now().plusDays(7));
                mathAssignment1Dto.setPoints(100);
                mathAssignment1Dto.setClassroomId(mathClass.getId());
                assignmentService.CreateAssignment(mathAssignment1Dto, mathClass.getTeacher().getEmail());

                // Assignment 2 for Math
                CreateAssignmentDto mathAssignment2Dto = new CreateAssignmentDto();
                mathAssignment2Dto.setTitle("Bài tập về Ma trận và Định thức");
                mathAssignment2Dto.setDescription("Tính các định thức và ma trận nghịch đảo. Giải các hệ phương trình tuyến tính.");
                mathAssignment2Dto.setDueDate(LocalDateTime.now().plusDays(14));
                mathAssignment2Dto.setPoints(100);
                mathAssignment2Dto.setClassroomId(mathClass.getId());
                assignmentService.CreateAssignment(mathAssignment2Dto, mathClass.getTeacher().getEmail());

                System.out.println("✅ [AssignmentSeeder] Created 2 assignments for Math class");
            }
            
            // Create Literature assignments
            if (litClass != null) {
                // Assignment 1 for Literature
                CreateAssignmentDto litAssignment1Dto = new CreateAssignmentDto();
                litAssignment1Dto.setTitle("Phân tích tác phẩm Truyện Kiều");
                litAssignment1Dto.setDescription("Phân tích nhân vật Thúy Kiều và giá trị nhân đạo trong tác phẩm.");
                litAssignment1Dto.setDueDate(LocalDateTime.now().plusDays(10));
                litAssignment1Dto.setPoints(100);
                litAssignment1Dto.setClassroomId(litClass.getId());
                assignmentService.CreateAssignment(litAssignment1Dto, litClass.getTeacher().getEmail());
                
                // Assignment 2 for Literature
                CreateAssignmentDto litAssignment2Dto = new CreateAssignmentDto();
                litAssignment2Dto.setTitle("So sánh các tác phẩm thơ của Hồ Xuân Hương");
                litAssignment2Dto.setDescription("Phân tích và so sánh phong cách, chủ đề trong các bài thơ nổi tiếng của Hồ Xuân Hương.");
                litAssignment2Dto.setDueDate(LocalDateTime.now().plusDays(15));
                litAssignment2Dto.setPoints(100);
                litAssignment2Dto.setClassroomId(litClass.getId());
                assignmentService.CreateAssignment(litAssignment2Dto, litClass.getTeacher().getEmail());
                
                System.out.println("✅ [AssignmentSeeder] Created 2 assignments for Literature class");
            }
            
            // Create English assignments
            if (engClass != null) {
                // Assignment 1 for English
                CreateAssignmentDto engAssignment1Dto = new CreateAssignmentDto();
                engAssignment1Dto.setTitle("Presentation on Cultural Differences");
                engAssignment1Dto.setDescription("Prepare a 5-minute presentation about cultural differences between Vietnam and an English-speaking country.");
                engAssignment1Dto.setDueDate(LocalDateTime.now().plusDays(9));
                engAssignment1Dto.setPoints(100);
                engAssignment1Dto.setClassroomId(engClass.getId());
                assignmentService.CreateAssignment(engAssignment1Dto, engClass.getTeacher().getEmail());

                // Assignment 2 for English
                CreateAssignmentDto engAssignment2Dto = new CreateAssignmentDto();
                engAssignment2Dto.setTitle("Essay Writing: My Future Career");
                engAssignment2Dto.setDescription("Write a 500-word essay about your future career aspirations and the steps to achieve them.");
                engAssignment2Dto.setDueDate(LocalDateTime.now().plusDays(12));
                engAssignment2Dto.setPoints(100);
                engAssignment2Dto.setClassroomId(engClass.getId());
                assignmentService.CreateAssignment(engAssignment2Dto, engClass.getTeacher().getEmail());

                System.out.println("✅ [AssignmentSeeder] Created 2 assignments for English class");
            }
            
            // Create CS assignments
            if (csClass != null) {
                // Assignment 1 for CS
                CreateAssignmentDto csAssignment1Dto = new CreateAssignmentDto();
                csAssignment1Dto.setTitle("Xây dựng ứng dụng quản lý sinh viên");
                csAssignment1Dto.setDescription("Thiết kế và xây dựng ứng dụng quản lý sinh viên đơn giản với Java Swing hoặc JavaFX.");
                csAssignment1Dto.setDueDate(LocalDateTime.now().plusDays(20));
                csAssignment1Dto.setPoints(100);
                csAssignment1Dto.setClassroomId(csClass.getId());
                assignmentService.CreateAssignment(csAssignment1Dto, csClass.getTeacher().getEmail());

                // Assignment 2 for CS
                CreateAssignmentDto csAssignment2Dto = new CreateAssignmentDto();
                csAssignment2Dto.setTitle("Thiết kế cơ sở dữ liệu cho hệ thống bán hàng");
                csAssignment2Dto.setDescription("Phân tích yêu cầu và thiết kế cơ sở dữ liệu cho hệ thống quản lý bán hàng đơn giản.");
                csAssignment2Dto.setDueDate(LocalDateTime.now().plusDays(15));
                csAssignment2Dto.setPoints(100);
                csAssignment2Dto.setClassroomId(csClass.getId());
                assignmentService.CreateAssignment(csAssignment2Dto, csClass.getTeacher().getEmail());

                System.out.println("✅ [AssignmentSeeder] Created 2 assignments for CS class");
            }
            
            System.out.println("✅ [AssignmentSeeder] Created assignments for available classes");
        } else {
            System.out.println("✅ [AssignmentSeeder] Assignments already seeded");
        }
    }
    
    private Classroom findClassroomByPartialName(List<Classroom> classrooms, String partialName) {
        return classrooms.stream()
                .filter(c -> c.getName().contains(partialName))
                .findFirst()
                .orElse(null);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/AssignmentTestDataSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class AssignmentTestDataSeeder {

    @Autowired
    private AssignmentRepository assignmentRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;
    
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void seedAssignmentTestData() {
        System.out.println("📚 [AssignmentTestData] Tạo assignments test cho classroom 54...");

        Classroom classroom54 = classroomRepository.findById(54L).orElse(null);
        if (classroom54 == null) {
            System.out.println("⚠️ [AssignmentTestData] Không tìm thấy classroom 54");
            return;
        }

        // Find teacher by role (assuming TEACHER role is 2)
        User teacher = userRepository.findByRoleId(2).stream()
            .findFirst().orElse(null);
        if (teacher == null) {
            System.out.println("⚠️ [AssignmentTestData] Không tìm thấy teacher");
            return;
        }

        // Tạo assignments test nếu chưa có
        List<Assignment> existingAssignments = assignmentRepository.findByClassroomId(54L);
        if (existingAssignments.size() < 3) {
            createTestAssignments(classroom54, teacher);
        }
    }

    private void createTestAssignments(Classroom classroom, User teacher) {
        List<AssignmentData> assignmentDataList = Arrays.asList(
            new AssignmentData(
                "Thiết kế cơ sở dữ liệu cho hệ thống bán hàng",
                "Yêu cầu thiết kế CSDL cho hệ thống bán hàng online bao gồm:\n\n" +
                "1. Phân tích yêu cầu nghiệp vụ\n" +
                "2. Thiết kế mô hình thực thể - quan hệ (ERD)\n" +
                "3. Chuẩn hóa dữ liệu đến dạng chuẩn 3\n" +
                "4. Tạo script SQL tạo bảng\n" +
                "5. Viết stored procedure cơ bản\n\n" +
                "**Deliverables:**\n" +
                "- File PDF báo cáo (max 10 trang)\n" +
                "- File SQL script\n" +
                "- Sơ đồ ERD (format .png hoặc .pdf)\n\n" +
                "**Tiêu chí chấm điểm:**\n" +
                "- Phân tích yêu cầu: 20%\n" +
                "- Thiết kế ERD: 30%\n" +
                "- Chuẩn hóa dữ liệu: 25%\n" +
                "- SQL script: 25%",
                100.0,
                LocalDateTime.now().plusDays(7)
            ),
            new AssignmentData(
                "Xây dựng ứng dụng web với Spring Boot",
                "Phát triển một ứng dụng web hoàn chình sử dụng Spring Boot:\n\n" +
                "**Yêu cầu chức năng:**\n" +
                "1. Authentication & Authorization\n" +
                "2. CRUD operations cho ít nhất 3 entities\n" +
                "3. REST API với đầy đủ endpoints\n" +
                "4. Frontend với Thymeleaf hoặc React\n" +
                "5. Validation và error handling\n" +
                "6. Unit tests (coverage ≥ 70%)\n\n" +
                "**Công nghệ yêu cầu:**\n" +
                "- Spring Boot 3.x\n" +
                "- Spring Security\n" +
                "- JPA/Hibernate\n" +
                "- MySQL/PostgreSQL\n" +
                "- Maven/Gradle\n\n" +
                "**Nộp bài:**\n" +
                "- Source code (ZIP file)\n" +
                "- Database script\n" +
                "- Documentation\n" +
                "- Demo video (5-10 phút)",
                100.0,
                LocalDateTime.now().plusDays(14)
            ),
            new AssignmentData(
                "Phân tích và thiết kế hệ thống",
                "Thực hiện phân tích và thiết kế hệ thống quản lý thư viện:\n\n" +
                "**Phần 1: Phân tích hệ thống (40%)**\n" +
                "- Phân tích stakeholder\n" +
                "- Thu thập và phân tích yêu cầu\n" +
                "- Use case diagram\n" +
                "- Activity diagram\n\n" +
                "**Phần 2: Thiết kế hệ thống (60%)**\n" +
                "- Kiến trúc hệ thống\n" +
                "- Class diagram\n" +
                "- Sequence diagram\n" +
                "- Component diagram\n" +
                "- Deployment diagram\n\n" +
                "**Công cụ:**\n" +
                "- UML tools (StarUML, Lucidchart, Draw.io)\n" +
                "- Word/LaTeX cho documentation\n\n" +
                "**Format nộp bài:**\n" +
                "- PDF report (15-20 trang)\n" +
                "- UML diagrams (separate files)\n" +
                "- Presentation slides",
                100.0,
                LocalDateTime.now().plusDays(10)
            )
        );

        for (AssignmentData data : assignmentDataList) {
            // Kiểm tra xem assignment đã tồn tại chưa
            boolean exists = assignmentRepository.findByClassroomId(classroom.getId())
                .stream()
                .anyMatch(a -> a.getTitle().equals(data.title));

            if (!exists) {
                Assignment assignment = new Assignment();
                assignment.setTitle(data.title);
                assignment.setDescription(data.description);
                assignment.setPoints(data.points.intValue());
                assignment.setDueDate(data.dueDate);
                assignment.setClassroom(classroom);

                assignmentRepository.save(assignment);
                System.out.println("✅ [AssignmentTestData] Tạo assignment: " + data.title);
            }
        }
    }

    private static class AssignmentData {
        final String title;
        final String description;
        final Double points;
        final LocalDateTime dueDate;

        AssignmentData(String title, String description, Double points, LocalDateTime dueDate) {
            this.title = title;
            this.description = description;
            this.points = points;
            this.dueDate = dueDate;
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/AttendanceSeeder.java">
package com.classroomapp.classroombackend.config.seed;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.attendancemanagement.Attendance;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceSession;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceSessionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AttendanceSeeder {

    private final AttendanceSessionRepository attendanceSessionRepository;
    private final AttendanceRepository attendanceRepository;
    private final LectureRepository lectureRepository;
    private final ClassroomRepository classroomRepository;
    private final ClassroomEnrollmentRepository classroomEnrollmentRepository;

    @Transactional
    public void seed() {
        // We will now always run this seeder to ensure some teaching history exists.
        System.out.println("🔄 [AttendanceSeeder] Seeding attendance data and ensuring teaching history...");

        List<Classroom> classrooms = classroomRepository.findAll();
        if (classrooms.isEmpty()) {
            System.out.println("⚠️ [AttendanceSeeder] No classrooms found, skipping seed.");
            return;
        }

        for (Classroom classroom : classrooms) {
            seedAttendanceForClassroom(classroom);
        }

        System.out.println("✅ [AttendanceSeeder] Finished seeding attendance data.");
    }

    private void seedAttendanceForClassroom(Classroom classroom) {
        List<Lecture> lectures = lectureRepository.findByClassroomId(classroom.getId());
        List<User> students = classroomEnrollmentRepository.findByClassroomId(classroom.getId())
                .stream()
                .map(enrollment -> enrollment.getUser())
                .collect(Collectors.toList());

        if (lectures.isEmpty()) {
            System.out.println("⚠️ [AttendanceSeeder] No lectures for classroom: " + classroom.getName() + ", skipping.");
            return;
        }

        // Seed attendance for lectures that have a date in the past or today
        for (Lecture lecture : lectures) {
            // Check if lecture has a date and if it's in the past or today
            if (lecture.getLectureDate() != null && !lecture.getLectureDate().isAfter(LocalDate.now())) {
                
                // Find existing or create a new session
                AttendanceSession session = attendanceSessionRepository.findByLectureId(lecture.getId())
                    .orElse(new AttendanceSession());

                // Always ensure there is a clock-in time for past lectures
                if (session.getTeacherClockInTime() == null) {
                    session.setTeacherClockInTime(lecture.getLectureDate().atTime(8, 30)); // Set a fixed time for consistency
                }
                
                // If it's a new session, set its properties
                if (session.getId() == null) {
                    session.setLecture(lecture);
                    session.setSessionDate(lecture.getLectureDate());
                    session.setClassroom(classroom);
                    attendanceSessionRepository.save(session);

                    // Create attendance records for each student only for the new session
                    if (!students.isEmpty()) {
                        for (int j = 0; j < students.size(); j++) {
                            User student = students.get(j);
                            Attendance attendance = new Attendance();
                            attendance.setSession(session);
                            attendance.setStudent(student);
                            
                            // Alternate status for variety
                            attendance.setStatus(j % 3 == 0 ? AttendanceStatus.ABSENT : (j % 3 == 1 ? AttendanceStatus.LATE : AttendanceStatus.PRESENT));
                            attendanceRepository.save(attendance);
                        }
                    }
                } else {
                    // If the session already exists, just save the updated clock-in time
                    attendanceSessionRepository.save(session);
                }
            }
        }
        System.out.println("✅ [AttendanceSeeder] Seeded/updated attendance for classroom: " + classroom.getName());
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/BlogSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Blog;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.BlogRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class BlogSeeder {

    @Autowired
    private BlogRepository blogRepository;

    @Autowired
    private UserRepository userRepository;

    public void seed() {
        if (blogRepository.count() == 0) {
            User admin = userRepository.findByEmail("admin@test.com").orElseThrow(() -> new RuntimeException("Admin user not found"));
            User manager = userRepository.findByEmail("manager@test.com").orElseThrow(() -> new RuntimeException("Manager user not found"));
            User teacher = userRepository.findByEmail("teacher@test.com").orElseThrow(() -> new RuntimeException("Teacher user not found"));
            User student = userRepository.findByEmail("student@test.com").orElseThrow(() -> new RuntimeException("Student user not found"));
            
            LocalDateTime now = LocalDateTime.now();

            Blog blog1 = new Blog();
            // Blog 1 - Published by Adminvới Nền tảng Lớp học của Chúng tôi
            blog1.setTitle("Chào mừng đến với Nền tảng Lớp học của Chúng tôi");
            blog1.setDescription(
                    "Đây là bài viết blog đầu tiên trên nền tảng lớp học của chúng tôi. Chúng tôi rất vui mừng thông báo về việc ra mắt môi trường học tập kỹ thuật số mới được thiết kế để tạo điều kiện giao tiếp tốt hơn giữa giáo viên và học sinh.\\n\\nNền tảng của chúng tôi bao gồm các tính năng như:\\n- Lớp học ảo\\n- Nộp bài tập\\n- Hệ thống chấm điểm\\n- Diễn đàn thảo luận\\n\\nChúng tôi hy vọng bạn sẽ thích sử dụng nền tảng của chúng tôi!");
            blog1.setImageUrl(
                    "https://images.unsplash.com/photo-1503676260728-1c00da094a0b?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80");
            blog1.setThumbnailUrl(
                    "https://images.unsplash.com/photo-1503676260728-1c00da094a0b?ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60");
            blog1.setTags("thông báo, chào mừng, nền tảng");
            blog1.setAuthor(admin);
            blog1.setIsPublished(true);
            blog1.setStatus("published");
            blog1.setPublishedDate(now.minusDays(7));
            blog1.setLastEditedDate(now.minusDays(7));
            blog1.setLastEditedBy(admin);
            blog1.setViewCount(156);
            blogRepository.save(blog1);

            Blog blog2 = new Blog();
            // Blog 2 - Published by Teacherến Hiệu Quả
            blog2.setTitle("Mẹo Học Trực Tuyến Hiệu Quả");
            blog2.setDescription(
                    "Khi chúng ta chuyển sang học trực tuyến nhiều hơn, đây là một số mẹo để giúp học sinh thành công:\\n\\n1. **Tạo không gian học tập riêng** - Tìm một nơi yên tĩnh, thoải mái nơi bạn có thể tập trung.\\n\\n2. **Thiết lập thói quen** - Đặt giờ học cố định và tuân thủ chúng.\\n\\n3. **Nghỉ giải lao** - Sử dụng các kỹ thuật như phương pháp Pomodoro (25 phút làm việc sau đó nghỉ 5 phút).\\n\\n4. **Giữ tổ chức** - Sử dụng lịch kỹ thuật số và danh sách việc cần làm để theo dõi bài tập và thời hạn.\\n\\n5. **Tham gia tích cực** - Tham gia vào các cuộc thảo luận trực tuyến và đặt câu hỏi khi cần giúp đỡ.\\n\\nBạn thấy chiến lược nào hiệu quả nhất cho việc học trực tuyến? Hãy chia sẻ trong phần bình luận!");
            blog2.setImageUrl(
                    "https://images.unsplash.com/photo-1498243691581-b145c3f54a5a?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80");
            blog2.setThumbnailUrl(
                    "https://images.unsplash.com/photo-1498243691581-b145c3f54a5a?ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60");
            blog2.setVideoUrl("https://www.youtube.com/embed/sBJmRD7kNTk");
            blog2.setTags("học trực tuyến, mẹo học tập, giáo dục");
            blog2.setAuthor(teacher);
            blog2.setIsPublished(true);
            blog2.setStatus("published");
            blog2.setPublishedDate(now.minusDays(5));
            blog2.setLastEditedDate(now.minusDays(5));
            blog2.setLastEditedBy(teacher);
            blog2.setViewCount(89);
            blogRepository.save(blog2);

            Blog blog3 = new Blog();
            // Blog 3 - Draft by Manageri Sắp Ra Mắt Cho Học Kỳ Tới
            blog3.setTitle("Tính Năng Mới Sắp Ra Mắt Cho Học Kỳ Tới");
            blog3.setDescription(
                    "Chúng tôi đang làm việc trên một số tính năng thú vị sẽ được phát hành trong học kỳ tới. Những cải tiến này dựa trên phản hồi từ học sinh và giáo viên.\\n\\n**Sắp Ra Mắt:**\\n\\n- Hệ thống tin nhắn cải tiến\\n- Công cụ cộng tác thời gian thực\\n- Ứng dụng di động cho iOS và Android\\n- Tích hợp với các công cụ giáo dục phổ biến\\n- Phân tích nâng cao cho giáo viên\\n\\nBài viết này vẫn đang là bản nháp và sẽ được cập nhật với nhiều chi tiết hơn trước khi xuất bản.");
            blog3.setThumbnailUrl("https://i1.sndcdn.com/artworks-000473680527-kz21lf-t1080x1080.jpg");
            blog3.setTags("tính năng, sắp ra mắt, cải tiến");
            blog3.setAuthor(manager);
            blog3.setIsPublished(false);
            blog3.setStatus("draft");
            blog3.setLastEditedDate(now.minusDays(2));
            blog3.setLastEditedBy(manager);
            blogRepository.save(blog3);

            Blog blog4 = new Blog();
            // Blog 4 - Published by Manager with image and video Tàng Thế Giới
            blog4.setTitle("Chuyến Tham Quan Ảo: Khám Phá Các Bảo Tàng Thế Giới");
            blog4.setDescription(
                    "Hôm nay chúng ta sẽ thực hiện một chuyến tham quan ảo đến một số bảo tàng nổi tiếng nhất thế giới cung cấp các tour trực tuyến.\\n\\nNhiều bảo tàng uy tín cung cấp các tour ảo cho phép bạn khám phá bộ sưu tập của họ từ sự thoải mái của ngôi nhà. Đây là một nguồn tài nguyên giáo dục tuyệt vời cho nghệ thuật, lịch sử và nghiên cứu văn hóa.\\n\\n**Các bảo tàng được giới thiệu trong video:**\\n\\n- Bảo tàng Louvre, Paris\\n- Bảo tàng Anh, London\\n- Bảo tàng Nghệ thuật Metropolitan, New York\\n- Bảo tàng Vatican, Rome\\n- Bảo tàng Nghệ thuật Hiện đại và Đương đại Quốc gia, Seoul\\n\\nVideo đính kèm cung cấp một tour có hướng dẫn của các bảo tàng này. Chúng tôi hy vọng chuyến tham quan ảo này sẽ truyền cảm hứng cho học sinh tìm hiểu thêm về nghệ thuật và lịch sử!");
            blog4.setImageUrl(
                    "https://images.unsplash.com/photo-1515169273894-7e876dcf13da?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80");
            blog4.setThumbnailUrl(
                    "https://images.unsplash.com/photo-1515169273894-7e876dcf13da?ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60");
            blog4.setVideoUrl("https://www.youtube.com/embed/vQ_sAt-VzRk");
            blog4.setTags("tham quan ảo, bảo tàng, nghệ thuật, lịch sử, giáo dục");
            blog4.setAuthor(manager);
            blog4.setIsPublished(true);
            blog4.setStatus("published");
            blog4.setPublishedDate(now.minusDays(1));
            blog4.setLastEditedDate(now.minusDays(1));
            blog4.setLastEditedBy(manager);
            blog4.setViewCount(42);
            blogRepository.save(blog4);

            Blog blog5 = new Blog();
            // Blog 5 - Published by Student (if they can create blogs)t Đầu Đến Nâng Cao
            blog5.setTitle("Hành Trình Học Tập Của Tôi: Từ Người Mới Bắt Đầu Đến Nâng Cao");
            blog5.setDescription(
                    "Xin chào mọi người! Tôi muốn chia sẻ hành trình học tập cá nhân của mình và một số hiểu biết có thể giúp ích cho các học sinh khác.\\n\\n"
                            +
                            "**Trải Nghiệm Của Tôi:**\\n\\n" +
                            "Khi tôi lần đầu sử dụng nền tảng này, tôi cảm thấy choáng ngợp bởi tất cả các tính năng. Nhưng dần dần, tôi khám phá ra cách mỗi công cụ có thể giúp tôi học tốt hơn.\\n\\n"
                            +
                            "**Những Bài Học Chính:**\\n\\n" +
                            "1. **Tính nhất quán là chìa khóa** - Học một chút mỗi ngày tốt hơn là nhồi nhét\\n" +
                            "2. **Đặt câu hỏi** - Đừng ngần ngại hỏi giáo viên hoặc bạn học để được giúp đỡ\\n" +
                            "3. **Sử dụng tất cả tài nguyên** - Tận dụng bài giảng, bài tập và diễn đàn thảo luận\\n" +
                            "4. **Theo dõi tiến độ** - Giám sát kết quả học tập để xác định các lĩnh vực cần cải thiện\\n" +
                            "5. **Kết nối** - Tham gia vào cộng đồng thông qua tin nhắn và thông báo\\n\\n" +
                            "**Lời Khuyên Cho Học Sinh Mới:**\\n\\n" +
                            "- Bắt đầu với những điều cơ bản và dần dần khám phá các tính năng nâng cao\\n" +
                            "- Thiết lập lịch học phù hợp với bạn\\n" +
                            "- Đừng sợ mắc lỗi - đó là cách chúng ta học!\\n" +
                            "- Kết nối với các học sinh khác có cùng sở thích\\n\\n" +
                            "Tôi hy vọng điều này sẽ giúp ích cho ai đó trong hành trình học tập của họ!");
            blog5.setImageUrl(
                    "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80");
            blog5.setThumbnailUrl(
                    "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60");
            blog5.setTags("trải nghiệm học sinh, mẹo học tập, động lực, cộng đồng");
            blog5.setAuthor(student); // Student user
            blog5.setIsPublished(true);
            blog5.setStatus("published");
            blog5.setPublishedDate(now.minusHours(12));
            blog5.setLastEditedDate(now.minusHours(12));
            blog5.setLastEditedBy(student);
            blog5.setViewCount(23);
            blogRepository.save(blog5);
            
            System.out.println("✅ [BlogSeeder] Created 5 sample blogs");
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/ClassroomEnrollmentSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
@Transactional
public class ClassroomEnrollmentSeeder {

    @Autowired
    private ClassroomEnrollmentRepository classroomEnrollmentRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ClassroomRepository classroomRepository;

    public void seed() {
        if (classroomEnrollmentRepository.count() == 0) {
            List<User> students = userRepository.findAllByRoleId(1L);
            List<Classroom> classrooms = classroomRepository.findAll();
            
            if (students.isEmpty() || classrooms.isEmpty()) {
                System.out.println("⚠️ [ClassroomEnrollmentSeeder] No students or classrooms found. Skipping.");
                return;
            }
            
            System.out.println("ℹ️ [ClassroomEnrollmentSeeder] Found " + students.size() + " students and " + classrooms.size() + " classrooms");
            
            // Find specific classes by name (partial match)
            Classroom mathClass = findClassroomByPartialName(classrooms, "Toán");
            Classroom litClass = findClassroomByPartialName(classrooms, "Văn");
            Classroom engClass = findClassroomByPartialName(classrooms, "Anh");
            
            if (mathClass == null) {
                System.out.println("⚠️ [ClassroomEnrollmentSeeder] Math class not found");
            } else {
                System.out.println("✅ [ClassroomEnrollmentSeeder] Found Math class: " + mathClass.getName());
            }
            
            if (litClass == null) {
                System.out.println("⚠️ [ClassroomEnrollmentSeeder] Literature class not found");
            } else {
                System.out.println("✅ [ClassroomEnrollmentSeeder] Found Literature class: " + litClass.getName());
            }
            
            if (engClass == null) {
                System.out.println("⚠️ [ClassroomEnrollmentSeeder] English class not found");
            } else {
                System.out.println("✅ [ClassroomEnrollmentSeeder] Found English class: " + engClass.getName());
            }

            // Enroll all students in Math class (everyone needs math)
            if (mathClass != null) {
                for (User student : students) {
                    enrollStudent(mathClass, student);
                }
                System.out.println("✅ [ClassroomEnrollmentSeeder] Enrolled " + students.size() + " students in Math class");
            }

            // Enroll most students in Literature
            if (litClass != null) {
                for (int i = 0; i < Math.min(4, students.size()); i++) {
                    User student = students.get(i);
                    enrollStudent(litClass, student);
                }
                System.out.println("✅ [ClassroomEnrollmentSeeder] Enrolled first 4 students in Literature class");
            }

            // Enroll some students in English
            if (engClass != null) {
                for (int i = 1; i < Math.min(5, students.size()); i++) {
                    User student = students.get(i);
                    enrollStudent(engClass, student);
                }
                System.out.println("✅ [ClassroomEnrollmentSeeder] Enrolled students 2-5 in English class");
            }

            // Enroll students in remaining classes
            List<Classroom> otherClasses = classrooms.stream()
                    .filter(c -> !c.equals(mathClass) && !c.equals(litClass) && !c.equals(engClass))
                    .collect(Collectors.toList());
            
            if (!otherClasses.isEmpty()) {
                for (int i = 0; i < Math.min(otherClasses.size(), students.size()); i++) {
                    User student = students.get(i % students.size());
                    Classroom classroom = otherClasses.get(i % otherClasses.size());
                    enrollStudent(classroom, student);
                }
                System.out.println("✅ [ClassroomEnrollmentSeeder] Enrolled students in " + otherClasses.size() + " other classes");
            }

            System.out.println("✅ [ClassroomEnrollmentSeeder] Created classroom enrollments for students across all classes");
        } else {
            System.out.println("✅ [ClassroomEnrollmentSeeder] Classroom enrollments already seeded");
        }
    }
    
    private Classroom findClassroomByPartialName(List<Classroom> classrooms, String partialName) {
        return classrooms.stream()
                .filter(c -> c.getName().contains(partialName))
                .findFirst()
                .orElse(null);
    }
    
    private void enrollStudent(Classroom classroom, User student) {
        ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId(classroom.getId(), student.getId());
        if (!classroomEnrollmentRepository.existsById(enrollmentId)) {
            ClassroomEnrollment enrollment = new ClassroomEnrollment();
            enrollment.setId(enrollmentId);
            enrollment.setClassroom(classroom);
            enrollment.setUser(student);
            classroomEnrollmentRepository.save(enrollment);
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/ClassroomSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.CourseRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
@Transactional
public class ClassroomSeeder {

    @Autowired
    private ClassroomRepository classroomRepository;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private CourseRepository courseRepository;

    public List<Classroom> seed() {
        if (classroomRepository.count() > 0) {
            System.out.println("✅ [ClassroomSeeder] Classrooms already exist, skipping seeding.");
            return classroomRepository.findAll();
        }

        System.out.println("🔄 [ClassroomSeeder] Seeding classrooms...");

        // Find teachers by Role ID (assuming 2 is the ID for TEACHER)
        List<User> teachers = userRepository.findByRoleId(Integer.valueOf(2));

        if (teachers.isEmpty()) {
            System.out.println("⚠️ [ClassroomSeeder] No teachers found (Role ID 2). Cannot create classrooms.");
            return new ArrayList<>();
        }

        List<Classroom> classrooms = new ArrayList<>();

        Classroom classroom1 = new Classroom();
        classroom1.setName("Lập trìnhh Java cơ bản - Kỳ 3");
        classroom1.setTeacher(teachers.get(0));
        classrooms.add(classroomRepository.save(classroom1));
        System.out.println("✅ [ClassroomSeeder] Created classroom: " + classroom1.getName());


        Classroom classroom2 = new Classroom();
        classroom2.setName("Toán rời rạc - Kỳ 2");
        classroom2.setTeacher(teachers.size() > 1 ? teachers.get(1) : teachers.get(0));
        classrooms.add(classroomRepository.save(classroom2));
        System.out.println("✅ [ClassroomSeeder] Created classroom: " + classroom2.getName());

        return classrooms;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/ComprehensiveGradingSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class ComprehensiveGradingSeeder {

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;
    
    @Autowired
    private ClassroomEnrollmentRepository enrollmentRepository;
    
    @Autowired
    private AssignmentRepository assignmentRepository;
    
    @Autowired
    private SubmissionRepository submissionRepository;

    private final Random random = new Random();

    @Transactional
    public void seedGradingData() {
        System.out.println("🎯 [GradingSeeder] Bắt đầu tạo dữ liệu chấm điểm toàn diện...");

        // Lấy classroom 54 (Công nghệ thông tin)
        Classroom classroom54 = classroomRepository.findById(54L).orElse(null);
        if (classroom54 == null) {
            System.out.println("⚠️ [GradingSeeder] Không tìm thấy classroom 54. Đang thoát...");
            return;
        }

        // Tạo sinh viên mới nếu cần
        List<User> students = createStudentsIfNeeded();
        
        // Đăng ký sinh viên vào lớp 54
        enrollStudentsInClassroom(students, classroom54);
        
        // Lấy assignments hiện tại trong classroom 54
        List<Assignment> assignments = assignmentRepository.findByClassroomId(54L);
        if (assignments.isEmpty()) {
            System.out.println("⚠️ [GradingSeeder] Không có assignments trong classroom 54");
            return;
        }

        // Tạo submissions với các trạng thái khác nhau
        for (Assignment assignment : assignments) {
            createDiverseSubmissions(assignment, students);
        }

        System.out.println("✅ [GradingSeeder] Hoàn thành tạo dữ liệu chấm điểm!");
    }

    private List<User> createStudentsIfNeeded() {
        System.out.println("📚 [GradingSeeder] Tạo sinh viên test...");
        
        List<String> studentNames = Arrays.asList(
            "Nguyễn Văn An", "Trần Thị Bích", "Lê Minh Cường", "Phạm Thu Dung",
            "Hoàng Văn Em", "Vũ Thị Phương", "Đặng Minh Giang", "Bùi Thị Hạnh",
            "Ngô Văn Inh", "Lý Thị Kim", "Đinh Văn Long", "Trịnh Thị Mai",
            "Dương Văn Nam", "Lương Thị Oanh", "Tạ Văn Phúc", "Cao Thị Quỳnh"
        );

        // Find existing students by role (assuming STUDENT role is 1)
        List<User> existingStudents = userRepository.findByRoleId(1);
        
        // Nếu đã có đủ sinh viên thì dùng lại
        if (existingStudents.size() >= 12) {
            return existingStudents.subList(0, 12);
        }

        // Tạo sinh viên mới
        for (int i = existingStudents.size(); i < 12; i++) {
            User student = new User();
            student.setEmail("student" + (i + 1) + "@school.edu");
            student.setUsername("student" + (i + 1));
            student.setPassword("$2a$10$defaultpassword"); // Encrypted password
            student.setFullName(studentNames.get(i % studentNames.size()));
            student.setPhoneNumber("098765" + String.format("%04d", i + 1));
            student.setRoleId(1); // Student role
            student.setDepartment("Công nghệ thông tin");
            
            userRepository.save(student);
            existingStudents.add(student);
        }

        return existingStudents.subList(0, 12);
    }

    private void enrollStudentsInClassroom(List<User> students, Classroom classroom) {
        System.out.println("📝 [GradingSeeder] Đăng ký sinh viên vào lớp...");
        
        for (User student : students) {
            ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId();
            enrollmentId.setClassroomId(classroom.getId());
            enrollmentId.setUserId(student.getId());

            // Kiểm tra xem đã đăng ký chưa
            if (!enrollmentRepository.existsById(enrollmentId)) {
                ClassroomEnrollment enrollment = new ClassroomEnrollment();
                enrollment.setId(enrollmentId);
                enrollment.setClassroom(classroom);
                enrollment.setUser(student);
                
                enrollmentRepository.save(enrollment);
            }
        }
    }

    private void createDiverseSubmissions(Assignment assignment, List<User> students) {
        System.out.println("📋 [GradingSeeder] Tạo submissions cho assignment: " + assignment.getTitle());

        List<String> submissionContents = Arrays.asList(
            "# Báo cáo Thiết kế Cơ sở Dữ liệu\n\n" +
            "## 1. Phân tích yêu cầu\n" +
            "Hệ thống bán hàng cần quản lý thông tin khách hàng, sản phẩm, đơn hàng...\n\n" +
            "## 2. Thiết kế ERD\n" +
            "[Diagram được đính kèm]\n\n" +
            "## 3. Tạo bảng SQL\n" +
            "```sql\nCREATE TABLE customers (\n  id INT PRIMARY KEY,\n  name VARCHAR(100)\n);\n```",
            
            "Thiết kế CSDL cho hệ thống bán hàng:\n\n" +
            "1. Bảng KHACH_HANG (customer_id, ten, email, sdt)\n" +
            "2. Bảng SAN_PHAM (product_id, ten_sp, gia, mo_ta)\n" +
            "3. Bảng DON_HANG (order_id, customer_id, ngay_dat, tong_tien)\n" +
            "4. Bảng CHI_TIET_DH (order_id, product_id, so_luong, gia)\n\n" +
            "Quan hệ: 1-n giữa KHACH_HANG và DON_HANG, n-n giữa DON_HANG và SAN_PHAM",
            
            "Database Design Document\n\n" +
            "Entity Analysis:\n" +
            "- Customer: Stores customer information\n" +
            "- Product: Product catalog\n" +
            "- Order: Sales transactions\n" +
            "- OrderItem: Order details\n\n" +
            "Normalization: Applied 3NF to eliminate redundancy\n" +
            "Indexes: Created on foreign keys and frequently queried columns"
        );

        // Tạo submission cho mỗi sinh viên với tỷ lệ khác nhau
        for (int i = 0; i < students.size(); i++) {
            User student = students.get(i);
            
            // 80% sinh viên nộp bài
            if (random.nextDouble() < 0.8) {
                Submission submission = new Submission();
                submission.setAssignment(assignment);
                submission.setStudent(student);
                
                // Nội dung submission
                String content = submissionContents.get(random.nextInt(submissionContents.size()));
                submission.setComment(content);
                
                // Thời gian nộp (một số trễ hạn)
                LocalDateTime submissionTime;
                if (random.nextDouble() < 0.15) { // 15% nộp trễ
                    submissionTime = assignment.getDueDate().plusDays(random.nextInt(7) + 1);
                } else {
                    submissionTime = assignment.getDueDate().minusHours(random.nextInt(48) + 1);
                }
                submission.setSubmittedAt(submissionTime);
                
                // Một số bài đã được chấm điểm
                if (random.nextDouble() < 0.4) { // 40% đã chấm
                    submission.setScore(60 + random.nextInt(40)); // Điểm từ 60-100
                    submission.setFeedback(generateFeedback(submission.getScore()));
                    submission.setGradedAt(submissionTime.plusDays(random.nextInt(5) + 1));
                }
                
                submissionRepository.save(submission);
            }
        }
    }

    private String generateFeedback(Integer score) {
        if (score >= 90) {
            return "Xuất sắc! Bài làm rất tốt, ERD thiết kế chính xác, SQL viết đúng chuẩn. " +
                   "Phân tích yêu cầu chi tiết và logic. Tiếp tục phát huy!";
        } else if (score >= 80) {
            return "Tốt! Bài làm đạt yêu cầu, thiết kế CSDL hợp lý. " +
                   "Một số điểm cần cải thiện: chuẩn hóa dữ liệu và tối ưu hóa query.";
        } else if (score >= 70) {
            return "Khá! Nắm được kiến thức cơ bản về thiết kế CSDL. " +
                   "Cần chú ý thêm về quan hệ giữa các bảng và ràng buộc dữ liệu.";
        } else {
            return "Cần cải thiện! Bài làm chưa đạt yêu cầu tối thiểu. " +
                   "Hãy xem lại tài liệu về ERD và chuẩn hóa CSDL. Liên hệ thầy nếu cần hỗ trợ.";
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/CourseMaterialSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Random;

import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.CourseMaterial;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.CourseMaterialRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class CourseMaterialSeeder {

    private final CourseMaterialRepository courseMaterialRepository;
    private final UserRepository userRepository;
    private final Random random = new Random();
    
    // Base directory for storing uploaded files - relative to project root
    private final String UPLOAD_DIR = "backend/doproject/uploads/materials";

    @Transactional
    public void seed(List<Classroom> classrooms) {
        System.out.println("Seeding course materials...");
        
        // Get teacher users for uploading materials
        List<User> teachers = userRepository.findByRoleId(2); // Teacher role ID
        
        if (teachers.isEmpty()) {
            System.out.println("No teachers found. Skipping course material seeding.");
            return;
        }

        // Seed materials for each classroom
        for (Classroom classroom : classrooms) {
            seedMaterialsForClassroom(classroom, teachers);
        }
        
        System.out.println("Course materials seeding completed.");
    }
    
    private void seedMaterialsForClassroom(Classroom classroom, List<User> teachers) {
        User teacher = getRandomTeacher(teachers);
        
        // Create directory for classroom materials if it doesn't exist
        String classroomDir = UPLOAD_DIR + "/" + classroom.getId();
        createDirectoryIfNotExists(classroomDir);
        
        // Create sample materials with actual files
        try {
            // PDF Document
            String pdfFileName = "textbook.pdf";
            String pdfPath = classroomDir + "/" + pdfFileName;
            createSampleFile(pdfPath, "Sample PDF content for " + classroom.getSubject());
            
            CourseMaterial pdfMaterial = new CourseMaterial();
            pdfMaterial.setTitle("Giáo trình " + classroom.getSubject());
            pdfMaterial.setDescription("Tài liệu học tập chính thức cho môn " + classroom.getSubject());
            pdfMaterial.setFilePath("/uploads/materials/" + classroom.getId() + "/" + pdfFileName); // Relative to server root
            pdfMaterial.setFileName(pdfFileName);
            pdfMaterial.setFileType("application/pdf");
            pdfMaterial.setFileSize(Files.size(Path.of(pdfPath)));
            pdfMaterial.setUploadDate(LocalDateTime.now().minusDays(random.nextInt(30)));
            pdfMaterial.setClassroomId(classroom.getId());
            pdfMaterial.setUploadedBy(teacher.getId());
            pdfMaterial.setIsPublic(true);
            pdfMaterial.setDownloadCount(random.nextInt(50));
            courseMaterialRepository.save(pdfMaterial);
            
            // Word Document
            String docxFileName = "exercises.docx";
            String docxPath = classroomDir + "/" + docxFileName;
            createSampleFile(docxPath, "Sample DOCX content for " + classroom.getSubject());
            
            CourseMaterial docxMaterial = new CourseMaterial();
            docxMaterial.setTitle("Bài tập " + classroom.getSubject());
            docxMaterial.setDescription("Bài tập thực hành cho môn " + classroom.getSubject());
            docxMaterial.setFilePath("/uploads/materials/" + classroom.getId() + "/" + docxFileName); // Relative to server root
            docxMaterial.setFileName(docxFileName);
            docxMaterial.setFileType("application/vnd.openxmlformats-officedocument.wordprocessingml.document");
            docxMaterial.setFileSize(Files.size(Path.of(docxPath)));
            docxMaterial.setUploadDate(LocalDateTime.now().minusDays(random.nextInt(20)));
            docxMaterial.setClassroomId(classroom.getId());
            docxMaterial.setUploadedBy(teacher.getId());
            docxMaterial.setIsPublic(true);
            docxMaterial.setDownloadCount(random.nextInt(40));
            courseMaterialRepository.save(docxMaterial);
            
            // Text File (simpler than PowerPoint)
            String txtFileName = "lecture_notes.txt";
            String txtPath = classroomDir + "/" + txtFileName;
            createSampleFile(txtPath, "Sample lecture notes for " + classroom.getSubject() + "\n\n" +
                    "These are detailed notes about the course content.\n" +
                    "- Topic 1: Introduction\n" +
                    "- Topic 2: Main concepts\n" +
                    "- Topic 3: Advanced techniques\n\n" +
                    "Remember to review these notes before the exam!");
            
            CourseMaterial txtMaterial = new CourseMaterial();
            txtMaterial.setTitle("Ghi chú bài giảng " + classroom.getSubject());
            txtMaterial.setDescription("Ghi chú bài giảng cho môn " + classroom.getSubject());
            txtMaterial.setFilePath("/uploads/materials/" + classroom.getId() + "/" + txtFileName); // Relative to server root
            txtMaterial.setFileName(txtFileName);
            txtMaterial.setFileType("text/plain");
            txtMaterial.setFileSize(Files.size(Path.of(txtPath)));
            txtMaterial.setUploadDate(LocalDateTime.now().minusDays(random.nextInt(15)));
            txtMaterial.setClassroomId(classroom.getId());
            txtMaterial.setUploadedBy(teacher.getId());
            txtMaterial.setIsPublic(true);
            txtMaterial.setDownloadCount(random.nextInt(60));
            courseMaterialRepository.save(txtMaterial);
            
            // Try to copy a sample PDF from resources
            try {
                // Create a PDF file with fixed content for testing
                String realPdfFileName = "course_handbook.pdf";
                String realPdfPath = classroomDir + "/" + realPdfFileName;
                
                String pdfMinimalContent = 
                        "%PDF-1.4\n" +
                        "1 0 obj\n" +
                        "<</Type /Catalog /Pages 2 0 R>>\n" +
                        "endobj\n" +
                        "2 0 obj\n" +
                        "<</Type /Pages /Kids [3 0 R] /Count 1>>\n" +
                        "endobj\n" +
                        "3 0 obj\n" +
                        "<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>\n" +
                        "endobj\n" +
                        "4 0 obj\n" +
                        "<</Font <</F1 5 0 R>>>>\n" +
                        "endobj\n" +
                        "5 0 obj\n" +
                        "<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>\n" +
                        "endobj\n" +
                        "6 0 obj\n" +
                        "<</Length 44>>\n" +
                        "stream\n" +
                        "BT /F1 24 Tf 100 700 Td (Course Handbook: " + classroom.getSubject() + ") Tj ET\n" +
                        "endstream\n" +
                        "endobj\n" +
                        "xref\n" +
                        "0 7\n" +
                        "0000000000 65535 f\n" +
                        "0000000009 00000 n\n" +
                        "0000000056 00000 n\n" +
                        "0000000111 00000 n\n" +
                        "0000000212 00000 n\n" +
                        "0000000250 00000 n\n" +
                        "0000000317 00000 n\n" +
                        "trailer\n" +
                        "<</Size 7 /Root 1 0 R>>\n" +
                        "startxref\n" +
                        "406\n" +
                        "%%EOF";
                
                createSampleFile(realPdfPath, pdfMinimalContent);
                
                CourseMaterial realPdfMaterial = new CourseMaterial();
                realPdfMaterial.setTitle("Sổ tay môn học " + classroom.getSubject());
                realPdfMaterial.setDescription("Sổ tay hướng dẫn chi tiết cho môn " + classroom.getSubject());
                realPdfMaterial.setFilePath("/uploads/materials/" + classroom.getId() + "/" + realPdfFileName); // Relative to server root
                realPdfMaterial.setFileName(realPdfFileName);
                realPdfMaterial.setFileType("application/pdf");
                realPdfMaterial.setFileSize(Files.size(Path.of(realPdfPath)));
                realPdfMaterial.setUploadDate(LocalDateTime.now().minusDays(random.nextInt(5)));
                realPdfMaterial.setClassroomId(classroom.getId());
                realPdfMaterial.setUploadedBy(teacher.getId());
                realPdfMaterial.setIsPublic(true);
                realPdfMaterial.setDownloadCount(random.nextInt(25));
                courseMaterialRepository.save(realPdfMaterial);
            } catch (Exception e) {
                log.error("Error creating PDF file: {}", e.getMessage(), e);
            }
            
        } catch (Exception e) {
            log.error("Error creating sample materials for classroom {}: {}", classroom.getId(), e.getMessage(), e);
        }
    }
    
    private User getRandomTeacher(List<User> teachers) {
        return teachers.get(random.nextInt(teachers.size()));
    }
    
    private void createDirectoryIfNotExists(String dirPath) {
        try {
            Files.createDirectories(Paths.get(dirPath));
        } catch (IOException e) {
            log.error("Error creating directory {}: {}", dirPath, e.getMessage(), e);
        }
    }
    
    private void createSampleFile(String filePath, String content) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(filePath)) {
            fos.write(content.getBytes());
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/CourseSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.classroommanagement.Course;
import com.classroomapp.classroombackend.repository.classroommanagement.CourseRepository;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class CourseSeeder {

    @Autowired
    private CourseRepository courseRepository;

    public void seed() {
        if (courseRepository.count() == 0) {
            Course math = new Course();
            math.setName("Advanced Mathematics");
            math.setDescription("A comprehensive study of mathematical concepts and their applications.");
            courseRepository.save(math);

            Course history = new Course();
            history.setName("World History");
            history.setDescription("A survey of major historical events from ancient civilizations to the modern era.");
            courseRepository.save(history);

            Course literature = new Course();
            literature.setName("Vietnamese Literature");
            literature.setDescription("An exploration of Vietnamese literary works throughout history.");
            courseRepository.save(literature);

            Course english = new Course();
            english.setName("Communicative English");
            english.setDescription("Developing English communication skills for an international environment.");
            courseRepository.save(english);

            Course cs = new Course();
            cs.setName("Computer Science");
            cs.setDescription("Fundamental concepts of computer science and programming.");
            courseRepository.save(cs);

            Course physics = new Course();
            physics.setName("General Physics");
            physics.setDescription("An introduction to the fundamental principles of physics.");
            courseRepository.save(physics);

            System.out.println("✅ [CourseSeeder] Created 6 sample courses.");
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/DatabaseCleanupService.java">
package com.classroomapp.classroombackend.config.seed;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

/**
 * Database cleanup component that runs on startup to ensure data integrity.
 * Implements ApplicationRunner to run AFTER the application context and Hibernate are fully initialized.
 */
@Component
@Order(1) // Ensures this runs before other ApplicationRunner beans (like seeders)
public class DatabaseCleanupService implements ApplicationRunner {
    
    private static final Logger log = LoggerFactory.getLogger(DatabaseCleanupService.class);
    
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    @Transactional
    public void run(ApplicationArguments args) throws Exception {
        log.info("🧹 [DatabaseCleanupService] Starting duplicate submission cleanup (via ApplicationRunner)...");
        cleanupDuplicateSubmissions();
    }
    
    private void cleanupDuplicateSubmissions() {
        try {
            // First, count existing duplicates
            String countDuplicatesQuery = """
                SELECT COUNT(*) FROM (
                    SELECT assignment_id, student_id, COUNT(*) as cnt
                    FROM submissions
                    GROUP BY assignment_id, student_id
                    HAVING COUNT(*) > 1
                ) as duplicates
                """;
            
            Integer duplicateGroups = jdbcTemplate.queryForObject(countDuplicatesQuery, Integer.class);
            
            if (duplicateGroups != null && duplicateGroups > 0) {
                log.warn("Found {} groups of duplicate submissions. Cleaning up...", duplicateGroups);
                
                // Define the subquery to find IDs of duplicate submissions to delete
                String duplicateIdsSubquery = """
                    SELECT s1.id
                    FROM submissions s1
                    INNER JOIN submissions s2 ON s1.assignment_id = s2.assignment_id
                                            AND s1.student_id = s2.student_id
                                            AND s1.id < s2.id
                    """;
                
                // First, delete related attachments to avoid foreign key violations
                String cleanupAttachmentsQuery = "DELETE FROM submission_attachments WHERE submission_id IN (" + duplicateIdsSubquery + ")";
                int deletedAttachments = jdbcTemplate.update(cleanupAttachmentsQuery);
                log.info("✅ [DatabaseCleanupService] Removed {} orphaned submission attachments", deletedAttachments);

                // Now, delete the duplicate submissions
                String cleanupSubmissionsQuery = "DELETE FROM submissions WHERE id IN (" + duplicateIdsSubquery + ")";
                
                int deletedRows = jdbcTemplate.update(cleanupSubmissionsQuery);
                log.info("✅ [DatabaseCleanupService] Removed {} duplicate submission records", deletedRows);
                
                // Verify cleanup
                Integer remainingDuplicates = jdbcTemplate.queryForObject(countDuplicatesQuery, Integer.class);
                if (remainingDuplicates != null && remainingDuplicates > 0) {
                    log.warn("⚠️ [DatabaseCleanupService] {} duplicate groups still remain after cleanup", remainingDuplicates);
                } else {
                    log.info("✅ [DatabaseCleanupService] All duplicate submissions cleaned up successfully");
                }
            } else {
                log.info("✅ [DatabaseCleanupService] No duplicate submissions found");
            }
            
        } catch (Exception e) {
            log.error("❌ [DatabaseCleanupService] Error during duplicate cleanup: {}", e.getMessage(), e);
            // Don't throw the exception to prevent application startup failure
            // The unique constraint will prevent new duplicates
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/DatabaseVerificationSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.List;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.ScheduleRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class DatabaseVerificationSeeder {

    private final UserRepository userRepository;
    private final ScheduleRepository scheduleRepository;

    public void verify() {
        System.out.println("🔍 [DatabaseVerification] Starting database state verification...");
        
        // Check all users
        List<User> allUsers = userRepository.findAll();
        System.out.println("👥 [DatabaseVerification] Found " + allUsers.size() + " total users:");
        
        for (User user : allUsers) {
            System.out.println("   - ID: " + user.getId() + 
                             ", Username: " + user.getUsername() + 
                             ", Role: " + user.getRoleId() + 
                             ", Name: " + user.getFullName());
        }
        
        // Find teacher specifically
        User teacher = userRepository.findByUsername("teacher").orElse(null);
        if (teacher != null) {
            System.out.println("🎓 [DatabaseVerification] Teacher found - ID: " + teacher.getId() + 
                             ", Name: " + teacher.getFullName());
            
            // Check schedules for this teacher
            List<Schedule> teacherSchedules = scheduleRepository.findByTeacherId(teacher.getId());
            System.out.println("📅 [DatabaseVerification] Found " + teacherSchedules.size() + 
                             " schedules for teacher ID " + teacher.getId());
            
            if (!teacherSchedules.isEmpty()) {
                System.out.println("📋 [DatabaseVerification] Teacher's schedules:");
                for (int i = 0; i < Math.min(5, teacherSchedules.size()); i++) {
                    Schedule schedule = teacherSchedules.get(i);
                    System.out.println("   - Schedule " + (i+1) + ": " + 
                                     getDayName(schedule.getDayOfWeek()) + " " +
                                     schedule.getStartTime() + "-" + schedule.getEndTime() + 
                                     " | " + schedule.getSubject() + 
                                     " | Room: " + schedule.getRoom());
                }
                if (teacherSchedules.size() > 5) {
                    System.out.println("   ... and " + (teacherSchedules.size() - 5) + " more schedules");
                }
            } else {
                System.out.println("⚠️ [DatabaseVerification] NO SCHEDULES FOUND for teacher ID " + teacher.getId());
            }
        } else {
            System.out.println("❌ [DatabaseVerification] Teacher user not found!");
        }
        
        // Check all schedules
        List<Schedule> allSchedules = scheduleRepository.findAll();
        System.out.println("📅 [DatabaseVerification] Total schedules in database: " + allSchedules.size());
        
        if (!allSchedules.isEmpty()) {
            System.out.println("📋 [DatabaseVerification] All schedules by teacher:");
            allSchedules.stream()
                .collect(java.util.stream.Collectors.groupingBy(s -> s.getTeacher().getId()))
                .forEach((teacherId, schedules) -> {
                    User scheduleTeacher = userRepository.findById(teacherId).orElse(null);
                    String teacherName = scheduleTeacher != null ? scheduleTeacher.getFullName() : "Unknown";
                    System.out.println("   - Teacher ID " + teacherId + " (" + teacherName + "): " + 
                                     schedules.size() + " schedules");
                });
        }
        
        System.out.println("✅ [DatabaseVerification] Verification completed");
    }
    
    private String getDayName(int dayOfWeek) {
        String[] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        return days[dayOfWeek];
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/DataVerificationSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class DataVerificationSeeder {
    
    private static final Logger log = LoggerFactory.getLogger(DataVerificationSeeder.class);
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;
    
    @Autowired
    private ClassroomEnrollmentRepository classroomEnrollmentRepository;
    
    @Autowired
    private LectureRepository lectureRepository;
    
    public void verifyDataIntegrity() {
        log.info("🔍 ============== DATA VERIFICATION STARTED ==============");
        
        verifyUsers();
        verifyClassrooms();
        verifyEnrollments();
        verifyLectures();
        
        log.info("✅ ============== DATA VERIFICATION COMPLETED ==============");
    }
    
    private void verifyUsers() {
        log.info("👥 Verifying Users...");
        
        // Check critical test users
        User student = userRepository.findByEmail("student@test.com").orElse(null);
        User teacher = userRepository.findByEmail("teacher@test.com").orElse(null);
        User mathTeacher = userRepository.findByEmail("math@test.com").orElse(null);
        
        if (student != null) {
            log.info("✅ Student User: ID={}, Email={}, Role={}, RoleId={}", 
                student.getId(), student.getEmail(), student.getRole(), student.getRoleId());
            
            if (student.getRoleId() != 1) {
                log.error("❌ CRITICAL: Student user has wrong role! Expected: 1 (STUDENT), Actual: {}", student.getRoleId());
            }
        } else {
            log.error("❌ CRITICAL: Student user not found!");
        }
        
        if (teacher != null) {
            log.info("✅ Main Teacher: ID={}, Email={}, Role={}, RoleId={}", 
                teacher.getId(), teacher.getEmail(), teacher.getRole(), teacher.getRoleId());
                
            if (teacher.getRoleId() != 2) {
                log.error("❌ CRITICAL: Teacher user has wrong role! Expected: 2 (TEACHER), Actual: {}", teacher.getRoleId());
            }
        } else {
            log.error("❌ CRITICAL: Main teacher user not found!");
        }
        
        if (mathTeacher != null) {
            log.info("✅ Math Teacher: ID={}, Email={}, Role={}, RoleId={}", 
                mathTeacher.getId(), mathTeacher.getEmail(), mathTeacher.getRole(), mathTeacher.getRoleId());
        } else {
            log.warn("⚠️ Math teacher user not found!");
        }
        
        // Count users by role
        List<User> students = userRepository.findByRoleId(1);
        List<User> teachers = userRepository.findByRoleId(2);
        List<User> managers = userRepository.findByRoleId(3);
        List<User> admins = userRepository.findByRoleId(4);
        
        log.info("📊 User counts: Students={}, Teachers={}, Managers={}, Admins={}", 
            students.size(), teachers.size(), managers.size(), admins.size());
    }
    
    private void verifyClassrooms() {
        log.info("🏫 Verifying Classrooms...");
        
        List<Classroom> classrooms = classroomRepository.findAll();
        log.info("📚 Found {} classrooms:", classrooms.size());
        
        for (Classroom classroom : classrooms) {
            User classroomTeacher = classroom.getTeacher();
            log.info("   - Classroom: {} (ID={}), Teacher: {} (ID={}), TeacherRole: {}", 
                classroom.getName(), 
                classroom.getId(),
                classroomTeacher != null ? classroomTeacher.getFullName() : "NULL",
                classroomTeacher != null ? classroomTeacher.getId() : "NULL",
                classroomTeacher != null ? classroomTeacher.getRole() : "NULL");
                
            if (classroomTeacher != null && classroomTeacher.getRoleId() != 2) {
                log.error("❌ CRITICAL: Classroom {} has teacher with wrong role! Expected: 2 (TEACHER), Actual: {}", 
                    classroom.getName(), classroomTeacher.getRoleId());
            }
        }
        
        // Find specific classroom for testing
        Classroom mathClass = classrooms.stream()
            .filter(c -> c.getName().contains("Toán"))
            .findFirst()
            .orElse(null);
            
        if (mathClass != null) {
            log.info("✅ Found Math classroom for testing: {} (ID={})", mathClass.getName(), mathClass.getId());
        } else {
            log.error("❌ CRITICAL: Math classroom not found! This will cause lecture loading issues.");
        }
    }
    
    private void verifyEnrollments() {
        log.info("📝 Verifying Enrollments...");
        
        User student = userRepository.findByEmail("student@test.com").orElse(null);
        if (student != null) {
            List<ClassroomEnrollment> enrollments = classroomEnrollmentRepository.findByUserId(student.getId());
            log.info("🎓 Student {} is enrolled in {} classrooms:", student.getEmail(), enrollments.size());
            
            for (ClassroomEnrollment enrollment : enrollments) {
                Classroom classroom = enrollment.getClassroom();
                log.info("   - Enrolled in: {} (ID={})", classroom.getName(), classroom.getId());
            }
            
            if (enrollments.isEmpty()) {
                log.error("❌ CRITICAL: Student is not enrolled in any classrooms! This will cause empty course lists.");
            }
        }
    }
    
    private void verifyLectures() {
        log.info("📖 Verifying Lectures...");
        
        List<Lecture> allLectures = lectureRepository.findAll();
        log.info("📚 Found {} total lectures", allLectures.size());
        
        // Check lectures by classroom
        List<Classroom> classrooms = classroomRepository.findAll();
        for (Classroom classroom : classrooms) {
            List<Lecture> classroomLectures = lectureRepository.findByClassroomId(classroom.getId());
            log.info("   - Classroom {} has {} lectures", classroom.getName(), classroomLectures.size());
            
            for (Lecture lecture : classroomLectures) {
                log.info("     * Lecture: {} (ID={})", lecture.getTitle(), lecture.getId());
            }
        }
        
        if (allLectures.isEmpty()) {
            log.error("❌ CRITICAL: No lectures found! This will cause empty lecture lists in frontend.");
        }
        
        // Specific check for Math classroom lectures
        Classroom mathClass = classrooms.stream()
            .filter(c -> c.getName().contains("Toán"))
            .findFirst()
            .orElse(null);

        if (mathClass != null) {
            List<Lecture> mathLectures = lectureRepository.findByClassroomId(mathClass.getId());
            log.info("🧮 Math classroom (ID={}) has {} lectures (this is what frontend will load)",
                mathClass.getId(), mathLectures.size());

            if (mathLectures.isEmpty()) {
                log.error("❌ CRITICAL: Math classroom (ID={}) has no lectures! Frontend will show empty list.", mathClass.getId());
                log.error("   This is the ROOT CAUSE of the empty lecture list issue!");
                log.error("   LectureSeeder may have failed or not run properly.");
            } else {
                log.info("✅ Math classroom lectures found:");
                for (Lecture lecture : mathLectures) {
                    log.info("   - {} (ID={}, Date={})", lecture.getTitle(), lecture.getId(), lecture.getLectureDate());
                }
            }
        } else {
            log.error("❌ CRITICAL: Math classroom not found! Available classrooms:");
            for (Classroom c : classrooms) {
                log.error("   - {} (ID={})", c.getName(), c.getId());
            }
        }
    }
    
    public void diagnoseStudentTeacherIssue() {
        log.info("🔍 ============== DIAGNOSING STUDENT/TEACHER ISSUE ==============");
        
        User student = userRepository.findByEmail("student@test.com").orElse(null);
        if (student == null) {
            log.error("❌ Student user not found!");
            return;
        }
        
        log.info("👤 Student Details:");
        log.info("   - ID: {}", student.getId());
        log.info("   - Email: {}", student.getEmail());
        log.info("   - Username: {}", student.getUsername());
        log.info("   - Role: {}", student.getRole());
        log.info("   - RoleId: {}", student.getRoleId());
        
        // Check if student is mistakenly assigned as teacher to any classroom
        List<Classroom> classroomsAsTeacher = classroomRepository.findByTeacherId(student.getId());
        if (!classroomsAsTeacher.isEmpty()) {
            log.error("❌ CRITICAL BUG: Student is assigned as TEACHER to {} classrooms!", classroomsAsTeacher.size());
            for (Classroom classroom : classroomsAsTeacher) {
                log.error("   - Student is teacher of: {} (ID={})", classroom.getName(), classroom.getId());
            }
        } else {
            log.info("✅ Student is correctly NOT assigned as teacher to any classroom");
        }
        
        // Check student enrollments
        List<ClassroomEnrollment> enrollments = classroomEnrollmentRepository.findByUserId(student.getId());
        log.info("📚 Student is enrolled in {} classrooms:", enrollments.size());
        for (ClassroomEnrollment enrollment : enrollments) {
            Classroom classroom = enrollment.getClassroom();
            log.info("   - Enrolled as STUDENT in: {} (ID={})", classroom.getName(), classroom.getId());
        }
        
        log.info("✅ ============== DIAGNOSIS COMPLETED ==============");
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/ExamSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.exammangement.Exam;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.exammangement.ExamRepository;

@Component
public class ExamSeeder {

    @Autowired
    private ExamRepository examRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;

    public void seed() {
        System.out.println("🔄 [ExamSeeder] Starting exam seeding process...");
        System.out.println("🔄 [ExamSeeder] Current exam count: " + examRepository.count());

        if (examRepository.count() == 0) {
            System.out.println("🔄 [ExamSeeder] Seeding exams...");

            List<Classroom> classrooms = classroomRepository.findAll();
            System.out.println("🔄 [ExamSeeder] Found " + classrooms.size() + " classrooms");

            if (classrooms.isEmpty()) {
                System.out.println("⚠️ [ExamSeeder] No classrooms found. Skipping exam seeding.");
                return;
            }

            // Debug: Print all classroom names
            for (Classroom classroom : classrooms) {
                System.out.println("🔄 [ExamSeeder] Classroom found: " + classroom.getName() + " (ID: " + classroom.getId() + ")");
            }

            // Find classrooms by partial name
            Classroom mathClass = findClassroomByPartialName(classrooms, "Toán");
            Classroom litClass = findClassroomByPartialName(classrooms, "Văn");
            Classroom csClass = findClassroomByPartialName(classrooms, "Công nghệ");

            System.out.println("🔄 [ExamSeeder] Math class found: " + (mathClass != null ? mathClass.getName() : "null"));
            System.out.println("🔄 [ExamSeeder] Literature class found: " + (litClass != null ? litClass.getName() : "null"));
            System.out.println("🔄 [ExamSeeder] CS class found: " + (csClass != null ? csClass.getName() : "null"));

            int examsCreated = 0;

            if (mathClass != null) {
                System.out.println("🔄 [ExamSeeder] Creating exams for math class: " + mathClass.getName());
                createExamForClassroom(mathClass, "Kiểm tra giữa kỳ Toán", 120, 10);
                createExamForClassroom(mathClass, "Kiểm tra cuối kỳ Toán", 180, 30);
                examsCreated += 2;
                System.out.println("✅ [ExamSeeder] Created 2 exams for math class");
            }

            if (litClass != null) {
                System.out.println("🔄 [ExamSeeder] Creating exam for literature class: " + litClass.getName());
                createExamForClassroom(litClass, "Bài thi hết môn Văn", 150, 25);
                examsCreated += 1;
                System.out.println("✅ [ExamSeeder] Created 1 exam for literature class");
            }

            if (csClass != null) {
                System.out.println("🔄 [ExamSeeder] Creating exam for CS class: " + csClass.getName());
                createExamForClassroom(csClass, "Thi thực hành Java", 90, 15);
                examsCreated += 1;
                System.out.println("✅ [ExamSeeder] Created 1 exam for CS class");
            }

            if (examsCreated > 0) {
                System.out.println("✅ [ExamSeeder] Created " + examsCreated + " sample exams for various classes.");
            } else {
                 System.out.println("⚠️ [ExamSeeder] Could not find relevant classrooms to seed exams.");
            }

        } else {
            System.out.println("✅ [ExamSeeder] Exams already seeded (count: " + examRepository.count() + ")");
        }
    }

    private void createExamForClassroom(Classroom classroom, String title, int duration, int daysFromNow) {
        try {
            System.out.println("🔄 [ExamSeeder] Creating exam: " + title + " for classroom: " + classroom.getName());

            Instant startTime = LocalDateTime.now().plusDays(daysFromNow).withHour(9).withMinute(0).atZone(ZoneId.systemDefault()).toInstant();
            Instant endTime = startTime.plusSeconds(duration * 60);

            System.out.println("🔄 [ExamSeeder] Start time: " + startTime);
            System.out.println("🔄 [ExamSeeder] End time: " + endTime);
            System.out.println("🔄 [ExamSeeder] Duration: " + duration + " minutes");

            Exam exam = new Exam();
            exam.setTitle(title);
            exam.setStartTime(startTime);
            exam.setEndTime(endTime);
            exam.setDurationInMinutes(duration);
            exam.setClassroom(classroom);

            Exam savedExam = examRepository.save(exam);
            System.out.println("✅ [ExamSeeder] Successfully created exam with ID: " + savedExam.getId());

        } catch (Exception e) {
            System.out.println("❌ [ExamSeeder] Error creating exam: " + title);
            System.out.println("❌ [ExamSeeder] Error details: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private Classroom findClassroomByPartialName(List<Classroom> classrooms, String partialName) {
        return classrooms.stream()
                .filter(c -> c.getName().contains(partialName))
                .findFirst()
                .orElse(null);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/LectureSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDate;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.repository.LectureMaterialRepository;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.ScheduleRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;

@Component
@Transactional
public class LectureSeeder {

    @Autowired
    private LectureRepository lectureRepository;

    @Autowired
    private LectureMaterialRepository lectureMaterialRepository;

    @Autowired
    private ClassroomRepository classroomRepository;

    @Autowired
    private ScheduleRepository scheduleRepository; // Inject ScheduleRepository

    @Transactional
    public void seed(List<Classroom> classrooms) {
        System.out.println("🔄 [LectureSeeder] Starting lecture seeding process...");

        if (classrooms.isEmpty()) {
            System.out.println("⚠️ [LectureSeeder] No classrooms provided. Skipping.");
            return;
        }

        System.out.println("📚 [LectureSeeder] Checking " + classrooms.size() + " classrooms for lectures...");

        for (Classroom classroom : classrooms) {
            // Check if this specific classroom already has lectures
            if (lectureRepository.existsByClassroomId(classroom.getId())) {
                System.out.println("✅ [LectureSeeder] Classroom '" + classroom.getName() + "' already has lectures. Skipping.");
                continue;
            }

            System.out.println("🔧 [LectureSeeder] No lectures found for '" + classroom.getName() + "'. Creating now...");

            if (classroom.getName().contains("Toán")) {
                createMathLectures(classroom);
            } else {
                createSampleLecturesForClassroom(classroom);
            }
        }

        long totalLectures = lectureRepository.count();
        System.out.println("✅ [LectureSeeder] Seeding process completed. Total lectures in database: " + totalLectures);
    }

    private void createMathLectures(Classroom mathClass) {
        System.out.println("🧮 [LectureSeeder] Creating lectures for Math classroom: " + mathClass.getName());

        // Try to find a schedule for this classroom, but don't require it
        List<Schedule> schedules = scheduleRepository.findByClassroomId(mathClass.getId());
        Schedule scheduleToLink = schedules.isEmpty() ? null : schedules.get(0);

        if (scheduleToLink != null) {
            System.out.println("✅ [LectureSeeder] Found schedule to link: " + scheduleToLink.getSubject());
        } else {
            System.out.println("⚠️ [LectureSeeder] No schedule found for Math classroom, creating lectures without schedule link");
        }

        // Lecture 1
        Lecture mathLecture1 = new Lecture();
        mathLecture1.setTitle("Giới thiệu về Đạo hàm");
        mathLecture1.setContent("# Giới thiệu về Đạo hàm\n\n## Định nghĩa đạo hàm\n\nĐạo hàm của một hàm số f(x) tại điểm x₀, ký hiệu là f'(x₀), được định nghĩa là:\n\nf'(x₀) = lim(h→0) [f(x₀+h) - f(x₀)]/h\n\nĐạo hàm cho ta biết tốc độ biến thiên của hàm số tại một điểm.\n\n## Các quy tắc tính đạo hàm\n\n1. Đạo hàm của hằng số: (C)' = 0\n2. Đạo hàm của x^n: (x^n)' = n*x^(n-1)\n3. Đạo hàm của tổng, hiệu: (u ± v)' = u' ± v'\n4. Đạo hàm của tích: (uv)' = u'v + uv'\n5. Đạo hàm của thương: (u/v)' = (u'v - uv')/v²");
        mathLecture1.setClassroom(mathClass);
        mathLecture1.setLectureDate(LocalDate.of(2025, 7, 9)); // Date in the past for history
        if (scheduleToLink != null) {
            mathLecture1.setSchedule(scheduleToLink);
        }
        lectureRepository.save(mathLecture1);
        System.out.println("✅ [LectureSeeder] Created lecture 1: " + mathLecture1.getTitle());

        // Lecture 2
        Lecture mathLecture2 = new Lecture();
        mathLecture2.setTitle("Tích phân và Ứng dụng");
        mathLecture2.setContent("# Tích phân và Ứng dụng\n\n## Nguyên hàm\n\nNếu F'(x) = f(x) thì F(x) được gọi là một nguyên hàm của f(x).\n\n## Tích phân xác định\n\nTích phân xác định của f(x) từ a đến b, ký hiệu là ∫[a,b] f(x)dx, cho ta diện tích hình thang cong giới hạn bởi đồ thị y=f(x), trục Ox và hai đường thẳng x=a, x=b.\n\n## Ứng dụng của tích phân\n\n1. Tính diện tích hình phẳng\n2. Tính thể tích vật thể tròn xoay\n3. Tính độ dài cung\n4. Ứng dụng trong vật lý và kỹ thuật");
        mathLecture2.setClassroom(mathClass);
        mathLecture2.setLectureDate(LocalDate.now().plusDays(2)); // Date in the future
        if (scheduleToLink != null) {
            mathLecture2.setSchedule(scheduleToLink);
        }
        lectureRepository.save(mathLecture2);
        System.out.println("✅ [LectureSeeder] Created lecture 2: " + mathLecture2.getTitle());

        // Lecture 3 - Additional lecture for more content
        Lecture mathLecture3 = new Lecture();
        mathLecture3.setTitle("Phương trình vi phân");
        mathLecture3.setContent("# Phương trình vi phân\n\n## Khái niệm cơ bản\n\nPhương trình vi phân là phương trình chứa hàm số chưa biết và các đạo hàm của nó.\n\n## Phương trình vi phân cấp 1\n\nDạng tổng quát: F(x, y, y') = 0\n\n### Phương trình tách biến\n\nDạng: dy/dx = f(x)g(y)\n\nCách giải: ∫dy/g(y) = ∫f(x)dx\n\n### Phương trình tuyến tính cấp 1\n\nDạng: y' + P(x)y = Q(x)\n\nCông thức nghiệm: y = e^(-∫P(x)dx)[∫Q(x)e^(∫P(x)dx)dx + C]");
        mathLecture3.setClassroom(mathClass);
        mathLecture3.setLectureDate(LocalDate.now().plusDays(7)); // Next week
        if (scheduleToLink != null) {
            mathLecture3.setSchedule(scheduleToLink);
        }
        lectureRepository.save(mathLecture3);
        System.out.println("✅ [LectureSeeder] Created lecture 3: " + mathLecture3.getTitle());

        System.out.println("✅ [LectureSeeder] Successfully created 3 lectures for Math classroom");
    }

    private void createLecturesForOtherClassrooms(List<Classroom> classrooms) {
        System.out.println("📚 [LectureSeeder] Creating lectures for other classrooms...");

        for (Classroom classroom : classrooms) {
            // Skip if it's the Math classroom (already handled)
            if (classroom.getName().contains("Toán")) {
                continue;
            }

            // Create 1-2 sample lectures for each other classroom
            createSampleLecturesForClassroom(classroom);
        }
    }

    private void createSampleLecturesForClassroom(Classroom classroom) {
        System.out.println("📖 [LectureSeeder] Creating sample lectures for: " + classroom.getName());

        // Try to find a schedule for this classroom
        List<Schedule> schedules = scheduleRepository.findByClassroomId(classroom.getId());
        Schedule scheduleToLink = schedules.isEmpty() ? null : schedules.get(0);

        // Create a generic lecture based on classroom name/subject
        Lecture lecture1 = new Lecture();
        lecture1.setTitle("Bài giảng giới thiệu - " + classroom.getName());
        lecture1.setContent("# Bài giảng giới thiệu\n\n## Chào mừng đến với khóa học " + classroom.getName() + "\n\nĐây là bài giảng đầu tiên trong khóa học. Chúng ta sẽ tìm hiểu về:\n\n- Mục tiêu của khóa học\n- Nội dung chính\n- Phương pháp học tập\n- Đánh giá và kiểm tra\n\n## Yêu cầu\n\n- Tham gia đầy đủ các buổi học\n- Hoàn thành bài tập được giao\n- Tích cực tham gia thảo luận\n\nChúc các bạn học tập hiệu quả!");
        lecture1.setClassroom(classroom);
        lecture1.setLectureDate(LocalDate.now().minusDays(1)); // Yesterday
        if (scheduleToLink != null) {
            lecture1.setSchedule(scheduleToLink);
        }
        lectureRepository.save(lecture1);

        // Create a second lecture
        Lecture lecture2 = new Lecture();
        lecture2.setTitle("Bài học thực hành - " + classroom.getName());
        lecture2.setContent("# Bài học thực hành\n\n## Mục tiêu\n\nTrong bài học này, chúng ta sẽ:\n\n- Áp dụng kiến thức đã học\n- Thực hành qua các bài tập\n- Thảo luận và giải đáp thắc mắc\n\n## Nội dung thực hành\n\n1. Ôn tập kiến thức cơ bản\n2. Giải các bài tập mẫu\n3. Thực hành độc lập\n4. Thảo luận kết quả\n\n## Bài tập về nhà\n\nHoàn thành các bài tập được giao và chuẩn bị cho buổi học tiếp theo.");
        lecture2.setClassroom(classroom);
        lecture2.setLectureDate(LocalDate.now().plusDays(3)); // In a few days
        if (scheduleToLink != null) {
            lecture2.setSchedule(scheduleToLink);
        }
        lectureRepository.save(lecture2);

        System.out.println("✅ [LectureSeeder] Created 2 sample lectures for: " + classroom.getName());
    }

    private Classroom findClassroomByPartialName(List<Classroom> classrooms, String partialName) {
        return classrooms.stream()
                .filter(c -> c.getName().contains(partialName))
                .findFirst()
                .orElse(null);
    }

    /**
     * Force re-seed lectures (for debugging purposes)
     * This method will clear existing lectures and create new ones
     */
    @Transactional
    public void forceSeed(List<Classroom> classrooms) {
        System.out.println("🔄 [LectureSeeder] FORCE SEEDING - Clearing existing lectures...");

        // Clear existing lectures
        lectureRepository.deleteAll();
        System.out.println("✅ [LectureSeeder] Cleared all existing lectures");

        // Now seed fresh lectures, but avoid the logic that skips everything
        System.out.println("📚 [LectureSeeder] Force seeding lectures for all " + classrooms.size() + " classrooms...");
        for (Classroom classroom : classrooms) {
            if (classroom.getName().contains("Toán")) {
                createMathLectures(classroom);
            } else {
                createSampleLecturesForClassroom(classroom);
            }
        }
    }

    /**
     * Verify lectures exist for a specific classroom
     */
    public void verifyLecturesForClassroom(Long classroomId) {
        List<Lecture> lectures = lectureRepository.findByClassroomId(classroomId);
        System.out.println("🔍 [LectureSeeder] Verification for classroom " + classroomId + ": " + lectures.size() + " lectures found");

        if (lectures.isEmpty()) {
            System.out.println("❌ [LectureSeeder] WARNING: No lectures found for classroom " + classroomId);

            // Try to find the classroom and create lectures
            Classroom classroom = classroomRepository.findById(classroomId).orElse(null);
            if (classroom != null) {
                System.out.println("🔧 [LectureSeeder] Attempting to create lectures for classroom: " + classroom.getName());
                if (classroom.getName().contains("Toán")) {
                    createMathLectures(classroom);
                } else {
                    createSampleLecturesForClassroom(classroom);
                }
            }
        } else {
            for (Lecture lecture : lectures) {
                System.out.println("   - " + lecture.getTitle() + " (ID: " + lecture.getId() + ", Date: " + lecture.getLectureDate() + ")");
            }
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/MasterSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.DependsOn;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.CourseMaterialRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.RequiredArgsConstructor;

@Component
@Order(2) // Run after DatabaseCleanupService
@RequiredArgsConstructor
@DependsOn("entityManagerFactory") // Wait for JPA to be initialized
public class MasterSeeder implements CommandLineRunner {
    private static final Logger log = LoggerFactory.getLogger(MasterSeeder.class);

    private final UserRepository userRepository;
    private final CourseMaterialRepository courseMaterialRepository;
    private final ClassroomRepository classroomRepository;
    private final UserSeeder userSeeder;
    private final CourseSeeder courseSeeder;
    private final ClassroomSeeder classroomSeeder;
    private final ClassroomEnrollmentSeeder classroomEnrollmentSeeder;
    private final ScheduleSeeder scheduleSeeder;
    private final LectureSeeder lectureSeeder;
    private final AssignmentSeeder assignmentSeeder;
    private final BlogSeeder blogSeeder;
    private final SubmissionSeeder submissionSeeder;
    private final AccomplishmentSeeder accomplishmentSeeder;
    private final AnnouncementSeeder announcementSeeder;
    private final AttendanceSeeder attendanceSeeder;
    private final MessageSeeder messageSeeder;
    private final TeachingHistorySeeder teachingHistorySeeder;
    private final CourseMaterialSeeder courseMaterialSeeder;
    private final ExamSeeder examSeeder;
    private final StudentProgressSeeder studentProgressSeeder;
    private final ComprehensiveGradingSeeder comprehensiveGradingSeeder;
    private final AssignmentTestDataSeeder assignmentTestDataSeeder;
    private final DatabaseVerificationSeeder databaseVerificationSeeder;
    private final DataVerificationSeeder dataVerificationSeeder;
    private final TimetableEventSeeder timetableEventSeeder;
    private final RequestSeeder requestSeeder;


    @Override
    @Transactional
    public void run(String... args) throws Exception {
        List<Classroom> classrooms;
        if (userRepository.count() == 0) {
            log.info("============== Seeding Database ==============");

            userSeeder.seed();
            courseSeeder.seed();
            classrooms = classroomSeeder.seed();
            classroomEnrollmentSeeder.seed();
            scheduleSeeder.seed();
            timetableEventSeeder.seed(); // Seed timetable events
            requestSeeder.seed(); // Seed role requests

            log.info("============== Starting Lecture Seeding ==============");
            lectureSeeder.seed(classrooms);
            log.info("============== Lecture Seeding Complete ==============");

            assignmentSeeder.seed();
            submissionSeeder.seed();
            blogSeeder.seed();
            accomplishmentSeeder.seed();
            announcementSeeder.seed();
            attendanceSeeder.seed();
            messageSeeder.seed();
            teachingHistorySeeder.seed();
            examSeeder.seed();
            studentProgressSeeder.seed();

            log.info("============== Main Seeding Complete ==============");
        } else {
            log.info("Database already has users. Skipping main seeding.");
            classrooms = classroomRepository.findAll();
        }

        // Always verify database state
        databaseVerificationSeeder.verify();

        // Additional verification for the specific issue
        verifyUserRoleAssignments();

        // Run comprehensive data verification
        dataVerificationSeeder.verifyDataIntegrity();
        dataVerificationSeeder.diagnoseStudentTeacherIssue();

        // Always run the submission seeder to add new test data
        log.info("============== Checking for new submissions to seed ==============");
        submissionSeeder.seed();
        log.info("============== Submission seeding complete ==============");

        // Always run comprehensive grading seeder for classroom 54
        log.info("============== Seeding Comprehensive Grading Data ==============");
        assignmentTestDataSeeder.seedAssignmentTestData();
        comprehensiveGradingSeeder.seedGradingData();
        log.info("============== Comprehensive Grading Seeding Complete ==============");

        if (courseMaterialRepository.count() == 0) {
            log.info("============== Seeding Course Materials ==============");
            if (classrooms.isEmpty()) {
                log.info("No classrooms found to seed materials for.");
            } else {
                courseMaterialSeeder.seed(classrooms);
            }
            log.info("============== Course Materials Seeding Complete ==============");
        } else {
            log.info("Course materials already seeded. Skipping.");
        }
        
        // Không gọi lại scheduleSeeder.seed() để tránh xung đột
        log.info("============== Checking Schedule Status ==============");
        log.info("Schedules are already seeded in the main seeding process if needed.");
        log.info("============== Schedule Status Check Complete ==============");
        
        // Always run the classroom enrollment seeder to ensure students are in classrooms
        log.info("============== Forcing Classroom Enrollment Seeding ==============");
        classroomEnrollmentSeeder.seed();
        log.info("============== Classroom Enrollment Seeding Complete ==============");
    }

    /**
     * Verify user role assignments to debug the student/teacher issue
     */
    private void verifyUserRoleAssignments() {
        log.info("============== Verifying User Role Assignments ==============");

        // Check student user
        User student = userRepository.findByEmail("student@test.com").orElse(null);
        if (student != null) {
            log.info("✅ Student User: ID={}, Email={}, Role={}, RoleId={}",
                student.getId(), student.getEmail(), student.getRole(), student.getRoleId());
        } else {
            log.error("❌ Student user not found!");
        }

        // Check teacher user
        User teacher = userRepository.findByEmail("teacher@test.com").orElse(null);
        if (teacher != null) {
            log.info("✅ Teacher User: ID={}, Email={}, Role={}, RoleId={}",
                teacher.getId(), teacher.getEmail(), teacher.getRole(), teacher.getRoleId());
        } else {
            log.error("❌ Teacher user not found!");
        }

        // Check classrooms and their teacher assignments
        List<Classroom> classrooms = classroomRepository.findAll();
        log.info("📚 Found {} classrooms:", classrooms.size());
        for (Classroom classroom : classrooms) {
            User classroomTeacher = classroom.getTeacher();
            log.info("   - Classroom: {} (ID={}), Teacher: {} (ID={})",
                classroom.getName(), classroom.getId(),
                classroomTeacher != null ? classroomTeacher.getFullName() : "NULL",
                classroomTeacher != null ? classroomTeacher.getId() : "NULL");
        }

        // Check if student is enrolled in any classrooms
        if (student != null) {
            log.info("🎓 Student {} should be enrolled in classrooms as STUDENT, not assigned as teacher",
                student.getEmail());
        }

        log.info("============== User Role Verification Complete ==============");
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/MessageSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Random;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.StudentMessage;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.StudentMessageRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class MessageSeeder {

    private final StudentMessageRepository studentMessageRepository;
    private final UserRepository userRepository;
    private final Random random = new Random();

    public MessageSeeder(StudentMessageRepository studentMessageRepository, UserRepository userRepository) {
        this.studentMessageRepository = studentMessageRepository;
        this.userRepository = userRepository;
    }

    public void seed() {
        if (studentMessageRepository.count() > 0) {
            System.out.println("✅ [MessageSeeder] Messages already seeded.");
            return;
        }

        System.out.println("🔄 [MessageSeeder] Seeding messages...");

        List<User> students = userRepository.findByRoleId(1); // STUDENT
        List<User> teachers = userRepository.findByRoleId(2); // TEACHER
        List<User> managers = userRepository.findByRoleId(3); // MANAGER

        if (students.size() < 2 || teachers.isEmpty() || managers.isEmpty()) {
            System.out.println("⚠️ [MessageSeeder] Not enough users with required roles to seed messages. Skipping.");
                return;
            }

        int messageCount = 0;

        // Create 5-10 conversation threads
        int conversations = 5 + random.nextInt(6);
        for (int i = 0; i < conversations; i++) {
            User student = students.get(random.nextInt(students.size()));
            User teacher = teachers.get(random.nextInt(teachers.size()));
            createConversation(student, teacher);
            messageCount += 2;
        }

        // Create some requests to managers
        User studentForRequest = students.get(0);
        User teacherForRequest = teachers.get(0);
        User manager = managers.get(0);

        createMessage(studentForRequest, manager, "Thắc mắc về học phí", "Em chào thầy/cô, em muốn hỏi về chính sách học phí cho học kỳ tới ạ.", "MEDIUM", true);
        createMessage(teacherForRequest, manager, "Đề xuất cải tiến giáo trình", "Tôi có một vài ý tưởng để cải tiến nội dung giáo trình môn học, rất mong được trao đổi với ban quản lý.", "LOW", false);
        messageCount += 2;


        System.out.println("✅ [MessageSeeder] Created " + messageCount + " sample messages.");
    }

    private void createConversation(User student, User teacher) {
        String[] subjects = {"Thắc mắc về bài tập", "Xin phép nghỉ học", "Hỏi về điểm số", "Cần tư vấn thêm"};
        String[] studentMessages = {
            "Em có một vài câu hỏi về bài tập tuần này ạ.",
            "Em viết email này để xin phép nghỉ buổi học tới do có việc gia đình.",
            "Thầy/cô có thể xem lại giúp em điểm bài kiểm tra vừa rồi không ạ?",
            "Em đang gặp chút khó khăn với nội dung môn học, thầy/cô có thể cho em một buổi tư vấn được không?"
        };
        String[] teacherReplies = {
            "Chào em, em cứ hỏi nhé, thầy/cô sẽ giải đáp.",
            "Thầy/cô đã nhận được thông tin. Em nhớ xem lại bài giảng nhé.",
            "Được em, thầy/cô sẽ kiểm tra lại và phản hồi sớm.",
            "Chắc chắn rồi, em có thể ghé văn phòng thầy/cô vào chiều thứ 5 nhé."
        };

        String subject = subjects[random.nextInt(subjects.length)];
        String studentMessage = studentMessages[random.nextInt(studentMessages.length)];
        String teacherReply = teacherReplies[random.nextInt(teacherReplies.length)];

        // Student sends first message
        StudentMessage msg1 = createMessage(student, teacher, subject, studentMessage, "MEDIUM", true);
        
        // Teacher replies
        createMessage(teacher, student, "Re: " + subject, teacherReply, "MEDIUM", random.nextBoolean());
    }

    private StudentMessage createMessage(User sender, User recipient, String subject, String content, String priority, boolean isRead) {
        StudentMessage message = new StudentMessage();
        message.setSender(sender);
        message.setRecipient(recipient);
        message.setSubject(subject);
        message.setContent(content);
        message.setPriority(priority);
        message.setStatus("DELIVERED");
        message.setCreatedAt(LocalDateTime.now().minusDays(random.nextInt(10)).minusHours(random.nextInt(24)));
        message.setIsRead(isRead);
        return studentMessageRepository.save(message);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/RequestSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.dto.StudentRequestFormDTO;
import com.classroomapp.classroombackend.dto.TeacherRequestFormDTO;
import com.classroomapp.classroombackend.model.Request;
import com.classroomapp.classroombackend.repository.requestmanagement.RequestRepository;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class RequestSeeder {

    private final RequestRepository requestRepository;
    private final ObjectMapper objectMapper;

    public void seed() {
        if (requestRepository.count() > 0) {
            return;
        }
        try {
            // Create a teacher role request
            TeacherRequestFormDTO teacherForm = new TeacherRequestFormDTO();
            teacherForm.setEmail("nguyenvanA@gmail.com");
            teacherForm.setFullName("Nguyễn Văn A");
            teacherForm.setPhoneNumber("0987654321");
            teacherForm.setCvFileName("nguyen_van_a_cv.pdf");
            teacherForm.setCvFileType("application/pdf");
            teacherForm.setCvFileData(
                    "U2FtcGxlIENWIGZpbGUgY29udGVudC4gSW4gcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBiZSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiBhIFBERiBmaWxlLg=="); // Sample base64 data
            teacherForm.setCvFileUrl("/files/teachers/nguyen_van_a_cv.pdf");
            teacherForm.setAdditionalInfo(
                    "Tôi đã có 5 năm kinh nghiệm giảng dạy Toán cấp trung học. Tôi từng làm việc tại trường THPT Chu Văn An và là giáo viên dạy thêm tại nhiều trung tâm luyện thi.");

            Request teacherRequest = new Request();
            teacherRequest.setEmail(teacherForm.getEmail() != null ? teacherForm.getEmail() : "unknown@email.com");
            teacherRequest.setFullName(teacherForm.getFullName() != null ? teacherForm.getFullName() : "Unknown");
            teacherRequest.setPhoneNumber(teacherForm.getPhoneNumber() != null ? teacherForm.getPhoneNumber() : "0000000000");
            teacherRequest.setRequestedRole("TEACHER");
            teacherRequest.setFormResponses(objectMapper.writeValueAsString(teacherForm));
            teacherRequest.setStatus("PENDING");
            teacherRequest.setCreatedAt(LocalDateTime.now().minusDays(3));
            requestRepository.save(teacherRequest);

            // Create a student role request
            StudentRequestFormDTO studentForm = new StudentRequestFormDTO();
            studentForm.setEmail("tranvanB@gmail.com");
            studentForm.setFullName("Trần Văn B");
            studentForm.setPhoneNumber("0987123456");
            studentForm.setGrade("Lớp 11");
            studentForm.setParentContact("Phụ huynh: Trần Thị C, SĐT: 0912345678");
            studentForm.setAdditionalInfo("Em muốn đăng ký học thêm môn Toán và Vật lý để chuẩn bị cho kỳ thi quốc gia.");

            Request studentRequest = new Request();
            studentRequest.setEmail(studentForm.getEmail() != null ? studentForm.getEmail() : "unknown@email.com");
            studentRequest.setFullName(studentForm.getFullName() != null ? studentForm.getFullName() : "Unknown");
            studentRequest.setPhoneNumber(studentForm.getPhoneNumber() != null ? studentForm.getPhoneNumber() : "0000000000");
            studentRequest.setRequestedRole("STUDENT");
            studentRequest.setFormResponses(objectMapper.writeValueAsString(studentForm));
            studentRequest.setStatus("PENDING");
            studentRequest.setCreatedAt(LocalDateTime.now().minusDays(1));
            requestRepository.save(studentRequest);
            System.out.println("✅ [RequestSeeder] Created 2 sample role requests.");
        } catch (Exception e) {
            System.err.println("❌ Error creating sample requests: " + e.getMessage());
            e.printStackTrace();
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/RoleSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.usermanagement.Role;
import com.classroomapp.classroombackend.repository.usermanagement.RoleRepository;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

@Component
public class RoleSeeder {

    @Autowired
    private RoleRepository roleRepository;

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void seed() {
        if (roleRepository.count() == 0) {
            try {
                entityManager.createNativeQuery("SET IDENTITY_INSERT roles ON").executeUpdate();

                Role student = new Role("STUDENT");
                student.setId(1);
                roleRepository.save(student);

                Role teacher = new Role("TEACHER");
                teacher.setId(2);
                roleRepository.save(teacher);

                Role manager = new Role("MANAGER");
                manager.setId(3);
                roleRepository.save(manager);

                Role admin = new Role("ADMIN");
                admin.setId(4);
                roleRepository.save(admin);

                System.out.println("✅ [RoleSeeder] Created roles with explicit IDs.");

            } finally {
                entityManager.createNativeQuery("SET IDENTITY_INSERT roles OFF").executeUpdate();
            }
        } else {
            System.out.println("✅ [RoleSeeder] Roles already seeded.");
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/ScheduleSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalTime;
import java.util.List;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.ScheduleRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class ScheduleSeeder {

    private final ScheduleRepository scheduleRepository;
    private final UserRepository userRepository;
    private final ClassroomRepository classroomRepository;

    public ScheduleSeeder(ScheduleRepository scheduleRepository, UserRepository userRepository, ClassroomRepository classroomRepository) {
        this.scheduleRepository = scheduleRepository;
        this.userRepository = userRepository;
        this.classroomRepository = classroomRepository;
    }

    public void seed() {
        if (scheduleRepository.count() > 0) {
            System.out.println("✅ [ScheduleSeeder] Schedules already exist, skipping seeding.");
            return;
        }

        System.out.println("🔄 [ScheduleSeeder] No schedules found, starting seeding process...");

        List<Classroom> classrooms = classroomRepository.findAll();
        List<User> teachers = userRepository.findByRoleId(2); // Role ID for TEACHER

        if (classrooms.isEmpty() || teachers.isEmpty()) {
            System.out.println("⚠️ [ScheduleSeeder] Not enough classrooms or teachers to seed schedules. Skipping.");
            return;
        }

        // Find specific classrooms
        Classroom mathClass = findClassroomByPartialName(classrooms, "Toán");
        Classroom litClass = findClassroomByPartialName(classrooms, "Văn");
        Classroom engClass = findClassroomByPartialName(classrooms, "Anh");
        Classroom csClass = findClassroomByPartialName(classrooms, "Công nghệ");

        int scheduleCount = 0;

        // Seed schedules for Math class
        if (mathClass != null && mathClass.getTeacher() != null) {
            scheduleRepository.save(createSchedule(mathClass.getTeacher(), mathClass, 0, LocalTime.of(8, 0), LocalTime.of(9, 30), "Room 101", "Giải tích 1"));
            scheduleRepository.save(createSchedule(mathClass.getTeacher(), mathClass, 2, LocalTime.of(8, 0), LocalTime.of(9, 30), "Room 101", "Đại số tuyến tính"));
            scheduleCount += 2;
        }

        // Seed schedules for Literature class
        if (litClass != null && litClass.getTeacher() != null) {
            scheduleRepository.save(createSchedule(litClass.getTeacher(), litClass, 1, LocalTime.of(10, 0), LocalTime.of(11, 30), "Room 102", "Phân tích tác phẩm"));
            scheduleRepository.save(createSchedule(litClass.getTeacher(), litClass, 3, LocalTime.of(10, 0), LocalTime.of(11, 30), "Room 102", "Lý luận văn học"));
            scheduleCount += 2;
        }

        // Seed schedules for English class
        if (engClass != null && engClass.getTeacher() != null) {
            scheduleRepository.save(createSchedule(engClass.getTeacher(), engClass, 0, LocalTime.of(14, 0), LocalTime.of(15, 30), "Room 201", "Speaking & Listening"));
            scheduleRepository.save(createSchedule(engClass.getTeacher(), engClass, 4, LocalTime.of(14, 0), LocalTime.of(15, 30), "Room 201", "Reading & Writing"));
            scheduleCount += 2;
        }
        
        // Seed schedules for Computer Science class
        if (csClass != null && csClass.getTeacher() != null) {
            scheduleRepository.save(createSchedule(csClass.getTeacher(), csClass, 1, LocalTime.of(13, 0), LocalTime.of(14, 30), "Lab 301", "Lập trình hướng đối tượng"));
            scheduleRepository.save(createSchedule(csClass.getTeacher(), csClass, 4, LocalTime.of(13, 0), LocalTime.of(14, 30), "Lab 301", "Cấu trúc dữ liệu và giải thuật"));
            scheduleCount += 2;
        }

        if (scheduleCount > 0) {
            System.out.println("✅ [ScheduleSeeder] Successfully created " + scheduleCount + " schedules for specific classes.");
        } else {
            System.out.println("⚠️ [ScheduleSeeder] Could not find specific classrooms to seed schedules.");
        }
    }

    private Classroom findClassroomByPartialName(List<Classroom> classrooms, String partialName) {
        return classrooms.stream()
                .filter(c -> c.getName().contains(partialName))
                .findFirst()
                .orElse(null);
    }

    private Schedule createSchedule(User teacher, Classroom classroom, int dayOfWeek,
                                    LocalTime startTime, LocalTime endTime,
                                    String room, String subject) {
        Schedule schedule = new Schedule();
        schedule.setTeacher(teacher);
        schedule.setClassroom(classroom);
        schedule.setDayOfWeek(dayOfWeek);
        schedule.setStartTime(startTime);
        schedule.setEndTime(endTime);
        schedule.setRoom(room);
        schedule.setSubject(subject);
        schedule.setMaterialsUrl("https://docs.google.com/document/d/example");
        schedule.setMeetUrl("https://meet.google.com/lookup/example");
        return schedule;
    }

    private String getDayName(int dayOfWeek) {
        String[] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        if (dayOfWeek >= 0 && dayOfWeek < days.length) {
            return days[dayOfWeek];
        }
        return "Unknown";
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/StudentProgressSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.StudentProgress;
import com.classroomapp.classroombackend.model.StudentProgress.ProgressType;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.StudentProgressRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;


@Component
public class StudentProgressSeeder {

    @Autowired
    private StudentProgressRepository studentProgressRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AssignmentRepository assignmentRepository;
    
    @Autowired
    private ClassroomEnrollmentRepository enrollmentRepository;

    private final Random random = new Random();

    public void seed() {
        if (studentProgressRepository.count() > 0) {
            System.out.println("✅ [StudentProgressSeeder] Student progress already seeded.");
            return;
        }

        System.out.println("🔄 [StudentProgressSeeder] Seeding student progress data...");

        List<User> students = userRepository.findByRoleId(1); // STUDENT role
        if (students.isEmpty()) {
            System.out.println("⚠️ [StudentProgressSeeder] No students found. Skipping progress seeding.");
            return;
        }

        int progressCount = 0;
        // Seed progress for the first 5 students
        for (int i = 0; i < Math.min(5, students.size()); i++) {
            User student = students.get(i);
            List<Classroom> enrolledClassrooms = enrollmentRepository.findByUserId(student.getId()).stream()
                    .map(e -> e.getClassroom())
                    .collect(Collectors.toList());

            if (enrolledClassrooms.isEmpty()) {
                continue;
            }

            // Create overall progress for each enrolled classroom
            for (Classroom classroom : enrolledClassrooms) {
                createOverallProgress(student.getId(), classroom.getId(),
                        new BigDecimal(50 + random.nextInt(51)), // 50-100%
                        60 + random.nextInt(120)); // 60-180 minutes
                progressCount++;
                
                // Create detailed progress for assignments within that classroom
                List<Assignment> assignments = assignmentRepository.findByClassroomId(classroom.getId());
                if (!assignments.isEmpty()) {
                    // Create progress for up to 2 assignments per class
                    for (int j = 0; j < Math.min(2, assignments.size()); j++) {
                        Assignment assignment = assignments.get(j);
                        createAssignmentProgress(student.getId(), classroom.getId(), assignment.getId(),
                                new BigDecimal(100), // Assume completed
                                new BigDecimal(70 + random.nextInt(31)), // 70-100 points
                                new BigDecimal(100), // Max points
                                30 + random.nextInt(90)); // 30-120 minutes
                        progressCount++;
                    }
                }
            }
        }
        System.out.println("✅ [StudentProgressSeeder] Created " + progressCount + " student progress records.");
    }

    private void createOverallProgress(Long studentId, Long classroomId, BigDecimal progressPercentage, Integer timeSpentMinutes) {
        StudentProgress progress = new StudentProgress();
        progress.setStudentId(studentId);
        progress.setClassroomId(classroomId);
        progress.setProgressType(ProgressType.OVERALL);
        progress.setProgressPercentage(progressPercentage);
        progress.setTimeSpentMinutes(timeSpentMinutes);
        progress.setLastAccessed(LocalDateTime.now().minusDays(random.nextInt(10)));
        studentProgressRepository.save(progress);
    }

    private void createAssignmentProgress(Long studentId, Long classroomId, Long assignmentId,
                                         BigDecimal progressPercentage, BigDecimal pointsEarned,
                                         BigDecimal maxPoints, Integer timeSpentMinutes) {
        StudentProgress progress = new StudentProgress();
        progress.setStudentId(studentId);
        progress.setClassroomId(classroomId);
        progress.setAssignmentId(assignmentId);
        progress.setProgressType(ProgressType.ASSIGNMENT);
        progress.setProgressPercentage(progressPercentage);
        progress.setPointsEarned(pointsEarned);
        progress.setMaxPoints(maxPoints);
        progress.setTimeSpentMinutes(timeSpentMinutes);
        progress.setLastAccessed(LocalDateTime.now().minusDays(random.nextInt(5)));
        studentProgressRepository.save(progress);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/SubmissionSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.assignmentmanagement.SubmissionAttachment;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class SubmissionSeeder {
    private static final Logger log = LoggerFactory.getLogger(SubmissionSeeder.class);

    @Autowired
    private SubmissionRepository submissionRepository;

    @Autowired
    private AssignmentRepository assignmentRepository;

    @Autowired
    private UserRepository userRepository;

    private static final String SAMPLE_PDF_URL = "/static/sample_materials/sample.pdf";

    @Transactional
    public void seed() {
        log.info("Running SubmissionSeeder to ensure test submissions exist");
        
        List<Assignment> assignments = assignmentRepository.findAll();
        List<User> students = userRepository.findAllByRoleId(1L); // Role ID 1 for STUDENT

        if (assignments.isEmpty() || students.isEmpty()) {
            log.warn("⚠️ [SubmissionSeeder] No assignments or students found, skipping submission creation.");
            return;
        }

        log.info("Found {} assignments and {} students for seeding submissions", 
                assignments.size(), students.size());

        // First check for specific assignment ID 87 which is used in the demo
        Optional<Assignment> assignment87 = assignmentRepository.findById(87L);
        if (assignment87.isPresent()) {
            log.info("Found specific assignment ID 87 - creating test submissions for it");
            Assignment assignment = assignment87.get();
            
            // Create submissions for all students for this assignment
            for (User student : students) {
                createSubmissionIfNotExists(assignment, student);
            }
        } else {
            log.warn("Assignment ID 87 not found - continuing with regular seeding");
        }

        // Seed submissions for all assignments for the first 3 students
        int submissionsCreated = 0;
        for (Assignment assignment : assignments) {
            for (int j = 0; j < Math.min(students.size(), 3); j++) {
                User student = students.get(j);
                
                if (createSubmissionIfNotExists(assignment, student)) {
                    submissionsCreated++;
                }
            }
        }

        if (submissionsCreated > 0) {
            log.info("✅ [SubmissionSeeder] Created {} new sample submissions.", submissionsCreated);
        } else {
            log.info("ℹ️ [SubmissionSeeder] No new submissions were created. Data may already exist.");
        }
        
        // Log count for specific assignment ID 87
        if (assignment87.isPresent()) {
            List<Submission> submissions87 = submissionRepository.findByAssignmentId(87L);
            log.info("Final submission count for assignment ID 87: {}", submissions87.size());
        }
    }
    
    /**
     * Creates a submission for the assignment and student if one doesn't already exist
     * @param assignment Assignment to create submission for
     * @param student Student to create submission for
     * @return true if a new submission was created, false if one already existed
     */
    private boolean createSubmissionIfNotExists(Assignment assignment, User student) {
        // Check if a submission already exists to avoid duplicates
        List<Submission> existingSubmissions = submissionRepository.findByStudentAndAssignment(student, assignment);
        if (existingSubmissions.isEmpty()) {
            int studentIndex = student.getFullName().hashCode() % 3; // Deterministic variation
            createSubmission(assignment, student, studentIndex);
            log.debug("Created submission for assignment {} and student {}", assignment.getId(), student.getId());
            return true;
        } else {
            log.debug("Submission already exists for assignment {} and student {} (found {} submissions)", 
                     assignment.getId(), student.getId(), existingSubmissions.size());
            return false;
        }
    }

    private void createSubmission(Assignment assignment, User student, int studentIndex) {
        Submission submission = new Submission();
        submission.setAssignment(assignment);
        submission.setStudent(student);
        submission.setSubmittedAt(LocalDateTime.now().minusDays(studentIndex));

        // Create and add an attachment
        SubmissionAttachment attachment = new SubmissionAttachment();
        attachment.setFileName("sample_submission.pdf");
        attachment.setFileUrl(SAMPLE_PDF_URL);
        submission.addAttachment(attachment);

        // Set different data based on student index
        switch (studentIndex % 3) {
            case 0: // First student variation
                submission.setComment("Đây là bài nộp của tôi cho bài tập " + assignment.getTitle());
                submission.setScore(95);
                submission.setFeedback("Làm rất tốt! Bài làm chi tiết và đầy đủ.");
                break;
            case 1: // Second student variation
                submission.setComment("Em đã hoàn thành bài tập theo yêu cầu.");
                submission.setScore(82);
                submission.setFeedback("Bài làm khá tốt, cần chú ý hơn đến phần định dạng.");
                break;
            case 2: // Third student variation - ungraded
                submission.setComment("Bài nộp cho " + assignment.getTitle());
                // No score or feedback yet
                break;
        }
        
        submissionRepository.save(submission);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/TeachingHistorySeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDate;
import java.util.List;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class TeachingHistorySeeder {

    private final UserRepository userRepository;
    private final ClassroomRepository classroomRepository;

    public void seed() {
        System.out.println("🔄 [TeachingHistorySeeder] Starting teaching history seeding...");
        
        // Find the main teacher user
        User teacher = userRepository.findByUsername("teacher")
                .orElseThrow(() -> new RuntimeException("Teacher user not found"));
        
        System.out.println("✅ [TeachingHistorySeeder] Found teacher: " + teacher.getFullName() + " (ID: " + teacher.getId() + ")");
        
        // Get all classrooms for this teacher
        List<Classroom> classrooms = classroomRepository.findByTeacher(teacher);
        if (classrooms.isEmpty()) {
            System.out.println("⚠️ [TeachingHistorySeeder] No classrooms found for teacher. Skipping teaching history seeding.");
            return;
        }
        
        System.out.println("✅ [TeachingHistorySeeder] Found " + classrooms.size() + " classrooms for teacher");
        
        // Create teaching history records
        // Note: Since there's no specific TeachingHistory entity, we'll create data that can be used
        // by the teaching history API endpoints. This might involve creating additional records
        // in existing entities or creating a new entity if needed.
        
        // For now, we'll create some sample data that represents teaching history
        // This could be implemented as:
        // 1. Historical classroom assignments
        // 2. Past semester records
        // 3. Teaching performance metrics
        
        createHistoricalClassroomData(teacher, classrooms);
        
        System.out.println("✅ [TeachingHistorySeeder] Teaching history seeding completed");
    }
    
    private void createHistoricalClassroomData(User teacher, List<Classroom> currentClassrooms) {
        // Create historical data by modifying existing classrooms or creating new ones
        // representing past semesters
        
        LocalDate currentDate = LocalDate.now();
        
        // Create data for previous semesters
        for (int semesterBack = 1; semesterBack <= 3; semesterBack++) {
            LocalDate semesterStart = currentDate.minusMonths(semesterBack * 6);
            
            for (int i = 0; i < Math.min(2, currentClassrooms.size()); i++) {
                Classroom currentClassroom = currentClassrooms.get(i);
                
                // Create a historical classroom record
                Classroom historicalClassroom = new Classroom();
                historicalClassroom.setName(currentClassroom.getName() + " - Kỳ " + semesterBack);
                historicalClassroom.setDescription("Lớp học kỳ trước - " + currentClassroom.getDescription());
                historicalClassroom.setSection(currentClassroom.getSection() + "_H" + semesterBack);
                historicalClassroom.setSubject(currentClassroom.getSubject());
                historicalClassroom.setTeacher(teacher);
                historicalClassroom.setCourseId(currentClassroom.getCourseId());
                
                // Save the historical classroom
                classroomRepository.save(historicalClassroom);
                
                System.out.println("📚 [TeachingHistorySeeder] Created historical classroom: " + historicalClassroom.getName());
            }
        }
        
        System.out.println("✅ [TeachingHistorySeeder] Created historical classroom data for 3 previous semesters");
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/TimetableEventSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.TimetableEvent;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.TimetableEventRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@Component
public class TimetableEventSeeder {

    private final TimetableEventRepository timetableEventRepository;
    private final UserRepository userRepository;
    private final ClassroomRepository classroomRepository;

    public TimetableEventSeeder(TimetableEventRepository timetableEventRepository, UserRepository userRepository, ClassroomRepository classroomRepository) {
        this.timetableEventRepository = timetableEventRepository;
        this.userRepository = userRepository;
        this.classroomRepository = classroomRepository;
    }

    public void seed() {
        if (timetableEventRepository.count() > 0) {
            return;
        }

        List<User> users = userRepository.findAll();
        List<Classroom> classrooms = classroomRepository.findAll();

        if (users.isEmpty() || classrooms.isEmpty()) {
            System.out.println("⚠️ [TimetableEventSeeder] Not enough users or classrooms to seed events. Skipping.");
            return;
        }

        User teacher = users.get(1);  // teacher user
        User admin = users.get(3);    // admin user

        // Create events for a specific week: e.g., starting from today
        LocalDateTime weekStart = LocalDateTime.now().with(java.time.DayOfWeek.MONDAY).withHour(0).withMinute(0);

        // Monday - Mathematics Class 8:00-9:30
        TimetableEvent mathMonday = new TimetableEvent();
        mathMonday.setTitle("Advanced Mathematics");
        mathMonday.setDescription("Weekly mathematics class covering calculus and algebra topics");
        mathMonday.setStartDatetime(weekStart.withHour(8).withMinute(0)); // Monday this week
        mathMonday.setEndDatetime(weekStart.withHour(9).withMinute(30));
        mathMonday.setEventType(TimetableEvent.EventType.CLASS);
        mathMonday.setClassroomId(classrooms.get(0).getId());
        mathMonday.setCreatedBy(teacher.getId());
        mathMonday.setLocation("Room 101");
        mathMonday.setColor("#52c41a");
        timetableEventRepository.save(mathMonday);

        // Tuesday - Physics Lab 10:00-11:30
        TimetableEvent physicsTuesday = new TimetableEvent();
        physicsTuesday.setTitle("Classical Physics Lab");
        physicsTuesday.setDescription("Hands-on physics experiments and lab work");
        physicsTuesday.setStartDatetime(weekStart.plusDays(1).withHour(10).withMinute(0)); // Tuesday
        physicsTuesday.setEndDatetime(weekStart.plusDays(1).withHour(11).withMinute(30));
        physicsTuesday.setEventType(TimetableEvent.EventType.CLASS);
        physicsTuesday.setClassroomId(classrooms.get(1).getId());
        physicsTuesday.setCreatedBy(teacher.getId());
        physicsTuesday.setLocation("Lab 201");
        physicsTuesday.setColor("#722ed1");
        timetableEventRepository.save(physicsTuesday);

        // Friday - Java Programming 13:00-14:30
        TimetableEvent javaFriday = new TimetableEvent();
        javaFriday.setTitle("Java Programming");
        javaFriday.setDescription("Object-oriented programming concepts and practical coding");
        javaFriday.setStartDatetime(weekStart.plusDays(4).withHour(13).withMinute(0)); // Friday
        javaFriday.setEndDatetime(weekStart.plusDays(4).withHour(14).withMinute(30));
        javaFriday.setEventType(TimetableEvent.EventType.CLASS);
        javaFriday.setClassroomId(classrooms.get(2).getId());
        javaFriday.setCreatedBy(admin.getId());
        javaFriday.setLocation("Computer Lab 301");
        javaFriday.setColor("#fa8c16");
        timetableEventRepository.save(javaFriday);

        // Add an exam event for next week
        LocalDateTime nextWeekStart = weekStart.plusWeeks(1);
        TimetableEvent mathExam = new TimetableEvent();
        mathExam.setTitle("Mathematics Midterm Exam");
        mathExam.setDescription("Comprehensive exam covering chapters 1-5 of calculus");
        mathExam.setStartDatetime(nextWeekStart.withHour(9).withMinute(0)); // Monday next week
        mathExam.setEndDatetime(nextWeekStart.withHour(11).withMinute(0));
        mathExam.setEventType(TimetableEvent.EventType.EXAM);
        mathExam.setClassroomId(classrooms.get(0).getId());
        mathExam.setCreatedBy(teacher.getId());
        mathExam.setLocation("Exam Hall A");
        mathExam.setColor("#f5222d");
        mathExam.setReminderMinutes(60);
        timetableEventRepository.save(mathExam);

        // Add an assignment due date
        TimetableEvent assignmentDue = new TimetableEvent();
        assignmentDue.setTitle("Calculus Problem Set Due");
        assignmentDue.setDescription("Submit completed calculus problem set from chapter 3");
        assignmentDue.setStartDatetime(weekStart.plusDays(3).withHour(23).withMinute(59)); // Wednesday
        assignmentDue.setEndDatetime(weekStart.plusDays(3).withHour(23).withMinute(59));
        assignmentDue.setEventType(TimetableEvent.EventType.ASSIGNMENT_DUE);
        assignmentDue.setClassroomId(classrooms.get(0).getId());
        assignmentDue.setCreatedBy(teacher.getId());
        assignmentDue.setLocation("Online Submission");
        assignmentDue.setColor("#faad14");
        assignmentDue.setReminderMinutes(1440); // 24 hours reminder
        timetableEventRepository.save(assignmentDue);

        System.out.println("✅ [TimetableEventSeeder] Created sample timetable events.");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/seed/UserSeeder.java">
package com.classroomapp.classroombackend.config.seed;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.constants.RoleConstants;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

@Component
public class UserSeeder {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void seed() {
        if (userRepository.count() == 0) {
            try {
                System.out.println("🔄 [UserSeeder] Starting user seeding with explicit IDs...");

                // Allow explicit ID insertion for SQL Server
                entityManager.createNativeQuery("SET IDENTITY_INSERT users ON").executeUpdate();
                System.out.println("✅ [UserSeeder] IDENTITY_INSERT enabled for users table");

                // Create student user
                User student = new User();
                student.setId(101L);
                student.setUsername("student");
                student.setPassword(passwordEncoder.encode("student123"));
                student.setEmail("student@test.com");
                student.setFullName("Student User");
                student.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student);
                System.out.println("✅ [UserSeeder] Created student user with ID: " + student.getId());

                // Create main teacher user
                User teacher = new User();
                teacher.setId(201L);
                teacher.setUsername("teacher");
                teacher.setPassword(passwordEncoder.encode("teacher123"));
                teacher.setEmail("teacher@test.com");
                teacher.setFullName("Teacher User");
                teacher.setRoleId(RoleConstants.TEACHER);
                userRepository.save(teacher);
                System.out.println("✅ [UserSeeder] Created teacher user with ID: " + teacher.getId());

                // Create manager user
                User manager = new User();
                manager.setId(301L);
                manager.setUsername("manager");
                manager.setPassword(passwordEncoder.encode("manager123"));
                manager.setEmail("manager@test.com");
                manager.setFullName("Manager User");
                manager.setRoleId(RoleConstants.MANAGER);
                userRepository.save(manager);

                // Create admin user
                User admin = new User();
                admin.setId(401L);
                admin.setUsername("admin");
                admin.setPassword(passwordEncoder.encode("admin123"));
                admin.setEmail("admin@test.com");
                admin.setFullName("Administrator");
                admin.setRoleId(RoleConstants.ADMIN);
                userRepository.save(admin);

                // Create subject-specific teachers
                User mathTeacher = new User();
                mathTeacher.setId(202L);
                mathTeacher.setUsername("math_teacher");
                mathTeacher.setPassword(passwordEncoder.encode("teacher123"));
                mathTeacher.setEmail("math@test.com");
                mathTeacher.setFullName("Nguyễn Văn Toán");
                mathTeacher.setRoleId(RoleConstants.TEACHER);
                userRepository.save(mathTeacher);

                User litTeacher = new User();
                litTeacher.setId(203L);
                litTeacher.setUsername("lit_teacher");
                litTeacher.setPassword(passwordEncoder.encode("teacher123"));
                litTeacher.setEmail("literature@test.com");
                litTeacher.setFullName("Trần Thị Văn");
                litTeacher.setRoleId(RoleConstants.TEACHER);
                userRepository.save(litTeacher);

                User engTeacher = new User();
                engTeacher.setId(204L);
                engTeacher.setUsername("eng_teacher");
                engTeacher.setPassword(passwordEncoder.encode("teacher123"));
                engTeacher.setEmail("english@test.com");
                engTeacher.setFullName("Lê Anh");
                engTeacher.setRoleId(RoleConstants.TEACHER);
                userRepository.save(engTeacher);

                // Create additional test students
                User student1 = new User();
                student1.setId(102L);
                student1.setUsername("student1");
                student1.setPassword(passwordEncoder.encode("student123"));
                student1.setEmail("student1@test.com");
                student1.setFullName("Phạm Văn Nam");
                student1.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student1);

                User student2 = new User();
                student2.setId(103L);
                student2.setUsername("student2");
                student2.setPassword(passwordEncoder.encode("student123"));
                student2.setEmail("student2@test.com");
                student2.setFullName("Alice Johnson");
                student2.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student2);

                User student3 = new User();
                student3.setId(104L);
                student3.setUsername("student3");
                student3.setPassword(passwordEncoder.encode("student123"));
                student3.setEmail("student3@test.com");
                student3.setFullName("Bob Wilson");
                student3.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student3);

                User student4 = new User();
                student4.setId(105L);
                student4.setUsername("student4");
                student4.setPassword(passwordEncoder.encode("student123"));
                student4.setEmail("student4@test.com");
                student4.setFullName("Carol Davis");
                student4.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student4);

                User student5 = new User();
                student5.setId(106L);
                student5.setUsername("student5");
                student5.setPassword(passwordEncoder.encode("student123"));
                student5.setEmail("student5@test.com");
                student5.setFullName("David Chen");
                student5.setRoleId(RoleConstants.STUDENT);
                userRepository.save(student5);

                // Additional teachers
                User extraTeacher1 = new User();
                extraTeacher1.setId(205L);
                extraTeacher1.setUsername("teacher2");
                extraTeacher1.setPassword(passwordEncoder.encode("teacher123"));
                extraTeacher1.setEmail("teacher2@test.com");
                extraTeacher1.setFullName("Dr. Sarah Williams");
                extraTeacher1.setRoleId(RoleConstants.TEACHER);
                userRepository.save(extraTeacher1);

                User extraTeacher2 = new User();
                extraTeacher2.setId(206L);
                extraTeacher2.setUsername("teacher3");
                extraTeacher2.setPassword(passwordEncoder.encode("teacher123"));
                extraTeacher2.setEmail("teacher3@test.com");
                extraTeacher2.setFullName("Prof. Michael Brown");
                extraTeacher2.setRoleId(RoleConstants.TEACHER);
                userRepository.save(extraTeacher2);

                System.out.println("✅ [UserSeeder] Created users with standardized, explicit IDs.");

            } finally {
                // IMPORTANT: Disable explicit ID insertion
                entityManager.createNativeQuery("SET IDENTITY_INSERT users OFF").executeUpdate();
                System.out.println("✅ [UserSeeder] IDENTITY_INSERT disabled for users table");

                // Verify the users were created with correct IDs
                User createdStudent = userRepository.findByUsername("student").orElse(null);
                User createdTeacher = userRepository.findByUsername("teacher").orElse(null);
                User createdManager = userRepository.findByUsername("manager").orElse(null);

                System.out.println("🔍 [UserSeeder] Verification of created users:");
                if (createdStudent != null) {
                    System.out.println("   📚 Student: ID=" + createdStudent.getId() + ", Expected=101");
                }
                if (createdTeacher != null) {
                    System.out.println("   🎓 Teacher: ID=" + createdTeacher.getId() + ", Expected=201");
                }
                if (createdManager != null) {
                    System.out.println("   👔 Manager: ID=" + createdManager.getId() + ", Expected=301");
                }
            }
        } else {
            System.out.println("✅ [UserSeeder] Users already seeded.");
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/AppConfig.java">
package com.classroomapp.classroombackend.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    
    @Bean
    public ModelMapper modelMapper() {
        ModelMapper modelMapper = new ModelMapper();
        // Cấu hình bổ sung cho ModelMapper nếu cần
        modelMapper.getConfiguration().setSkipNullEnabled(true);
        return modelMapper;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/CharsetFilter.java">
package com.classroomapp.classroombackend.config;

import java.io.IOException;

import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Filter to ensure all requests and responses use UTF-8 encoding
 * This helps prevent Vietnamese character encoding issues
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
@WebFilter("/*")
public class CharsetFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Nothing to initialize
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        // Set UTF-8 encoding for request
        if (request instanceof HttpServletRequest) {
            request.setCharacterEncoding("UTF-8");
        }
        
        // Set UTF-8 encoding for response
        if (response instanceof HttpServletResponse) {
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            httpResponse.setCharacterEncoding("UTF-8");
            httpResponse.setHeader("Content-Type", "application/json; charset=UTF-8");
        }
        
        // Continue with the filter chain
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        // Nothing to destroy
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/CustomCorsFilter.java">
package com.classroomapp.classroombackend.config;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
// Enable CORS filter
import org.springframework.stereotype.Component;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CustomCorsFilter implements Filter {

    private final Logger logger = LoggerFactory.getLogger(CustomCorsFilter.class);
    
    // List of allowed origins
    private final List<String> allowedOrigins = Arrays.asList(
        "http://localhost:3000", 
        "http://localhost:5173",
        "http://localhost:8088"
    );

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        HttpServletRequest request = (HttpServletRequest) req;
        
        logger.debug("CustomCorsFilter processing request: {} {}", request.getMethod(), request.getRequestURI());

        // Get origin from request
        String origin = request.getHeader("Origin");
        
        // Set CORS headers
        if (origin != null && allowedOrigins.contains(origin)) {
            // Only allow specified origins
            response.setHeader("Access-Control-Allow-Origin", origin);
            response.setHeader("Access-Control-Allow-Credentials", "true");
        } 
        
        response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE, PUT");
        response.setHeader("Access-Control-Max-Age", "3600");
        response.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization, Content-Length, X-Requested-With");
        
        // Handle preflight OPTIONS requests
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            logger.debug("Handling OPTIONS preflight request");
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            // Pass request down the chain
            chain.doFilter(req, res);
        }
    }

    @Override
    public void init(FilterConfig filterConfig) {
        logger.info("CustomCorsFilter initialized");
    }

    @Override
    public void destroy() {
        logger.info("CustomCorsFilter destroyed");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/DatabaseConfig.java">
package com.classroomapp.classroombackend.config; 
 
import javax.sql.DataSource;

import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

import com.zaxxer.hikari.HikariDataSource;

@Configuration
@EnableJpaRepositories(basePackages = "com.classroomapp.classroombackend.repository")
@EntityScan(basePackages = "com.classroomapp.classroombackend.model")
public class DatabaseConfig {

    @Bean
    @Primary
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setDriverClassName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
        dataSource.setJdbcUrl("jdbc:sqlserver://localhost:1433;databaseName=SchoolManagementDB;encrypt=false;trustServerCertificate=true;sendStringParametersAsUnicode=true;characterEncoding=UTF-8;useUnicode=true;sendTimeAsDateTime=false;");
        dataSource.setUsername("sa");
        dataSource.setPassword("12345678");
        // dataSource.setAutoCommit(false); // This can prevent seeders from committing data. Let Spring's @Transactional manage commits.
        dataSource.setTransactionIsolation("TRANSACTION_READ_COMMITTED");
        dataSource.setMaximumPoolSize(10);
        dataSource.setMinimumIdle(5);
        return dataSource;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/DataLoader.java">
package com.classroomapp.classroombackend.config;

import java.util.List;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.config.seed.AnnouncementSeeder;
import com.classroomapp.classroombackend.config.seed.AssignmentSeeder;
import com.classroomapp.classroombackend.config.seed.ClassroomSeeder;
import com.classroomapp.classroombackend.config.seed.CourseSeeder;
import com.classroomapp.classroombackend.config.seed.LectureSeeder;
import com.classroomapp.classroombackend.config.seed.RoleSeeder;
import com.classroomapp.classroombackend.config.seed.UserSeeder;
import com.classroomapp.classroombackend.config.seed.RequestSeeder;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

import lombok.RequiredArgsConstructor;

@Component
@Profile("local")
@Order(2) // Run after DatabaseCleanupService
@RequiredArgsConstructor
public class DataLoader implements CommandLineRunner {

    private final RoleSeeder roleSeeder;
    private final UserSeeder userSeeder;
    private final CourseSeeder courseSeeder;
    private final ClassroomSeeder classroomSeeder;
    private final LectureSeeder lectureSeeder;
    private final AssignmentSeeder assignmentSeeder;
    private final AnnouncementSeeder announcementSeeder;
    private final RequestSeeder requestSeeder;

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        System.out.println("🌱 [DataLoader] Starting data seeding...");
        // roleSeeder.seed();
        // userSeeder.seed();
        // courseSeeder.seed();
        // List<Classroom> classrooms = classroomSeeder.seed();
        // lectureSeeder.seed(classrooms);
        // assignmentSeeder.seed(); // Re-enabled with @Lazy dependency
        // announcementSeeder.seed(classrooms);
        requestSeeder.seed();
        System.out.println("✅ [DataLoader] Data seeding completed.");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/EmailConfig.java">
package com.classroomapp.classroombackend.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.spring6.SpringTemplateEngine;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.ClassLoaderTemplateResolver;
import org.thymeleaf.templateresolver.ITemplateResolver;

import com.classroomapp.classroombackend.service.EmailService;
import com.classroomapp.classroombackend.service.impl.EmailServiceImpl;

@Configuration
public class EmailConfig {
    
    @Bean
    @Primary
    public EmailService emailService(EmailServiceImpl emailService) {
        return emailService;
    }

    @Bean
    @Primary
    public TemplateEngine emailTemplateEngine() {
        final SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.addTemplateResolver(htmlTemplateResolver());
        return templateEngine;
    }

    private ITemplateResolver htmlTemplateResolver() {
        final ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();
        templateResolver.setPrefix("/templates/");
        templateResolver.setSuffix(".html");
        templateResolver.setTemplateMode(TemplateMode.HTML);
        templateResolver.setCharacterEncoding("UTF-8");
        templateResolver.setCacheable(false);
        return templateResolver;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/FirebaseConfig.java">
package com.classroomapp.classroombackend.config;

import java.io.InputStream;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;

@Configuration
@ConditionalOnProperty(name = "firebase.enabled", havingValue = "true", matchIfMissing = false)
public class FirebaseConfig {
    
    private static final Logger logger = LoggerFactory.getLogger(FirebaseConfig.class);

    @Value("${firebase.bucket-name}")
    private String storageBucket;
    
    @PostConstruct
    public void init() {
        try {
            if (FirebaseApp.getApps().isEmpty()) {
                logger.info("Initializing Firebase for project with bucket: {}", storageBucket);

                // This file should be in src/main/resources
                String serviceAccountPath = "mve-1-firebase-adminsdk.json";
                ClassPathResource resource = new ClassPathResource(serviceAccountPath);

                if (!resource.exists()) {
                    logger.error("!!! CRITICAL: Firebase service account file not found at classpath: {}. Firebase features will fail.", serviceAccountPath);
                    return;
                }
                
                try (InputStream serviceAccount = resource.getInputStream()) {
                    FirebaseOptions options = FirebaseOptions.builder()
                        .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                        .setStorageBucket(storageBucket)
                        .build();
                    
                    FirebaseApp.initializeApp(options);
                    logger.info(">>>> Firebase has been initialized successfully! <<<<");
                }
            } else {
                logger.info("Firebase is already initialized.");
            }
        } catch (Exception e) {
            logger.error("!!! CRITICAL: Failed to initialize Firebase. All Firebase-dependent features will fail.", e);
        }
    }
}


</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/JacksonConfig.java">
package com.classroomapp.classroombackend.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.hibernate6.Hibernate6Module;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

@Configuration
public class JacksonConfig {

    private static final String dateTimeFormat = "yyyy-MM-dd'T'HH:mm:ss";

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(dateTimeFormat)));
        
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new Hibernate6Module());
        objectMapper.registerModule(javaTimeModule);
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return objectMapper;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/MCPConfig.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/ModelMapperConfig.java">
package com.classroomapp.classroombackend.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperConfig {
    @Bean
    public ModelMapper modelMapper() {
        ModelMapper modelMapper = new ModelMapper();

        // Configure ModelMapper to be more lenient and handle ambiguity
        modelMapper.getConfiguration()
            .setSkipNullEnabled(true)
            .setAmbiguityIgnored(true)
            .setFieldMatchingEnabled(true)
            .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE);

        return modelMapper;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/ProductionApplicationConfig.java">
package com.classroomapp.classroombackend.config;

import java.util.Optional;
import java.util.concurrent.ThreadPoolExecutor;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.core.task.TaskExecutor;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
import org.springframework.web.client.RestTemplate;

import com.classroomapp.classroombackend.security.CustomUserDetails;

import jakarta.validation.Validator;
import lombok.extern.slf4j.Slf4j;

/**
 * Production-Ready Application Configuration for Classroom Management System
 *
 * This configuration class provides comprehensive setup for:
 * - Performance optimization (caching, async processing)
 * - Monitoring and observability (metrics, health checks)
 * - Security enhancements (auditing, validation)
 * - Production readiness features
 *
 * @author Classroom Management System
 * @version 1.0
 * @since 2025-01-09
 */
@Configuration
@EnableCaching
@EnableAsync
@EnableScheduling
@EnableTransactionManagement
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
@Slf4j
public class ProductionApplicationConfig {

    @Value("${spring.application.name:classroom-backend}")
    private String applicationName;

    @Value("${app.async.core-pool-size:5}")
    private int asyncCorePoolSize;

    @Value("${app.async.max-pool-size:20}")
    private int asyncMaxPoolSize;

    @Value("${app.async.queue-capacity:100}")
    private int asyncQueueCapacity;

    // ==================== PERFORMANCE OPTIMIZATION ====================

    /**
     * Cache Manager for improving application performance
     * Caches frequently accessed data like user sessions, classroom data, etc.
     */
    @Bean
    @Primary
    public CacheManager cacheManager() {
        log.info("🚀 Initializing Cache Manager for performance optimization");
        ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(
            "users",           // User data cache
            "classrooms",      // Classroom information cache
            "assignments",     // Assignment data cache
            "submissions",     // Submission data cache
            "announcements",   // Announcement cache
            "courses",         // Course data cache
            "schedules"        // Schedule cache
        );
        return cacheManager;
    }

    /**
     * Async Task Executor for non-blocking operations
     * Handles file uploads, email notifications, and background processing
     */
    @Bean(name = "taskExecutor")
    public TaskExecutor taskExecutor() {
        log.info("⚡ Configuring Async Task Executor - Core: {}, Max: {}, Queue: {}",
                asyncCorePoolSize, asyncMaxPoolSize, asyncQueueCapacity);

        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(asyncCorePoolSize);
        executor.setMaxPoolSize(asyncMaxPoolSize);
        executor.setQueueCapacity(asyncQueueCapacity);
        executor.setThreadNamePrefix("ClassroomApp-Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);
        executor.initialize();
        return executor;
    }

    /**
     * Email Task Executor for email notifications
     * Separate thread pool for email operations to prevent blocking
     */
    @Bean(name = "emailTaskExecutor")
    public TaskExecutor emailTaskExecutor() {
        log.info("📧 Configuring Email Task Executor");

        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("Email-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }

    // ==================== MONITORING & OBSERVABILITY ====================

    /**
     * Application Performance Monitoring
     * Simple performance tracking without external dependencies
     */
    @Bean
    public String performanceMonitor() {
        log.info("📊 Performance monitoring initialized for {}", applicationName);
        return "performance-monitor-active";
    }

    // ==================== SECURITY & AUDITING ====================

    /**
     * Auditor Provider for JPA Auditing
     * Tracks who created/modified entities
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication == null || !authentication.isAuthenticated()) {
                return Optional.of("system");
            }

            Object principal = authentication.getPrincipal();
            if (principal instanceof CustomUserDetails) {
                return Optional.of(((CustomUserDetails) principal).getUsername());
            } else if (principal instanceof String) {
                return Optional.of((String) principal);
            }

            return Optional.of("anonymous");
        };
    }

    /**
     * Bean Validator for comprehensive validation
     */
    @Bean
    @Primary
    public Validator validator() {
        return new LocalValidatorFactoryBean();
    }

    /**
     * RestTemplate for external API calls
     */
    @Bean
    public RestTemplate restTemplate() {
        log.info("🌐 Configuring RestTemplate for external API calls");
        return new RestTemplate();
    }

    // ==================== PRODUCTION FEATURES ====================

    /**
     * File Upload Configuration Properties
     */
    @Bean
    @ConfigurationProperties(prefix = "app.file-upload")
    public FileUploadProperties fileUploadProperties() {
        return new FileUploadProperties();
    }

    /**
     * Application Performance Metrics Configuration
     * Simple metrics tracking without external dependencies
     */
    @Bean
    public String metricsConfiguration() {
        log.info("📈 Application metrics configuration initialized");
        return "metrics-enabled";
    }

    /**
     * Development Profile Configuration
     * Additional logging and debugging features for development
     */
    @Bean
    @Profile("dev")
    public String developmentModeIndicator() {
        log.warn("🚧 Application running in DEVELOPMENT mode - additional logging enabled");
        return "development";
    }

    /**
     * Production Profile Configuration
     * Optimized settings for production environment
     */
    @Bean
    @Profile("prod")
    public String productionModeIndicator() {
        log.info("🚀 Application running in PRODUCTION mode - optimized for performance");
        return "production";
    }

    // ==================== INNER CLASSES ====================

    /**
     * File Upload Configuration Properties
     */
    public static class FileUploadProperties {
        private String uploadDir = "uploads/";
        private long maxFileSize = 10485760; // 10MB
        private long maxRequestSize = 52428800; // 50MB
        private String[] allowedExtensions = {".pdf", ".doc", ".docx", ".txt", ".jpg", ".png", ".gif"};

        // Getters and setters
        public String getUploadDir() { return uploadDir; }
        public void setUploadDir(String uploadDir) { this.uploadDir = uploadDir; }

        public long getMaxFileSize() { return maxFileSize; }
        public void setMaxFileSize(long maxFileSize) { this.maxFileSize = maxFileSize; }

        public long getMaxRequestSize() { return maxRequestSize; }
        public void setMaxRequestSize(long maxRequestSize) { this.maxRequestSize = maxRequestSize; }

        public String[] getAllowedExtensions() { return allowedExtensions; }
        public void setAllowedExtensions(String[] allowedExtensions) { this.allowedExtensions = allowedExtensions; }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/SecurityConfig.java">
package com.classroomapp.classroombackend.config;

import java.util.Arrays;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import com.classroomapp.classroombackend.filter.JwtAuthenticationFilter;

import lombok.extern.slf4j.Slf4j;

/**
 * Spring Security configuration for the application
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true)
@Slf4j
public class SecurityConfig {

    private static final Logger log = LoggerFactory.getLogger(SecurityConfig.class);
    
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }
    
    /**
     * Password encoder bean for password hashing
     * 
     * @return password encoder
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    /**
     * Authentication manager bean for Spring Security
     * 
     * @param authenticationConfiguration authentication configuration
     * @return authentication manager
     * @throws Exception if authentication manager cannot be created
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("Configuring security filter chain");
        http
            // First configure CORS
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            // Then disable CSRF
            .csrf(csrf -> csrf.disable())
            // Add the JWT filter before the standard authentication filter
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            // Then configure authorization rules
            .authorizeHttpRequests(authorize -> authorize
                // Allow OPTIONS requests for CORS preflight
                .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                
                // Public endpoints - Only truly public endpoints should be here
                .requestMatchers("/api/auth/login").permitAll()
                .requestMatchers("/api/auth/register").permitAll()
                .requestMatchers("/api/auth/google-login").permitAll()
                .requestMatchers("/api/auth/reset-password").permitAll()
                .requestMatchers("/api/auth/change-password").authenticated() // Requires authentication
                .requestMatchers("/api/auth/validate").authenticated() // Requires authentication for token validation
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/health").permitAll() // Health check endpoint
                .requestMatchers("/api/v1/health").permitAll() // Health check endpoint v1
                .requestMatchers("/api/test").permitAll() // Test endpoint
                .requestMatchers("/api/v1/greetings/hello").permitAll() // Only allow hello endpoint for health check
                .requestMatchers("/api/role-requests/**").permitAll()
                .requestMatchers("/role-requests/**").permitAll() // Allow both with and without /api prefix
                
                // Blog endpoints
                .requestMatchers("/api/blogs").permitAll()
                .requestMatchers("/api/blogs/published").permitAll()
                .requestMatchers("/api/blogs/{id:[\\d]+}").permitAll()
                .requestMatchers("/api/blogs/search").permitAll()
                .requestMatchers("/api/blogs/tag/**").permitAll()
                .requestMatchers("/api/blogs/author/**").permitAll()
                .requestMatchers("/api/blogs/{id:[\\d]+}/publish").authenticated()
                .requestMatchers("/api/blogs/{id:[\\d]+}/unpublish").authenticated()
                
                // Protected endpoints - Attendance system
                .requestMatchers("/api/v1/attendance/**").authenticated()
                .requestMatchers("/api/attendance-sessions/**").authenticated()
                .requestMatchers("/api/attendances/**").authenticated()

                // Protected endpoints - File operations
                .requestMatchers("/api/files/**").authenticated()
                .requestMatchers("/files/**").authenticated()

                // Protected endpoints - Assignments
                .requestMatchers("/api/assignments/**").authenticated()
                .requestMatchers("/api/timetable/**").authenticated()

                // Role-based endpoints
                .requestMatchers("/api/admin/requests/**").hasAnyRole("ADMIN", "MANAGER")
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/manager/**").hasRole("MANAGER")
                .requestMatchers("/api/teacher/**").hasAuthority("ROLE_TEACHER")
                .requestMatchers("/api/student/**").hasRole("STUDENT")
                
                // All other requests need authentication
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );
        
        log.info("Security filter chain configured successfully");
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // Cho phép origin từ frontend React và các nguồn khác
        configuration.setAllowedOriginPatterns(Arrays.asList(
            "http://localhost:*", 
            "https://localhost:*"
        ));
        
        configuration.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000", 
            "http://localhost:3001", 
            "http://localhost:8088", 
            "http://localhost", 
            "https://mvsclassroom.com"
        ));
        
        // Cho phép các phương thức HTTP
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"));
        
        // Cho phép các header HTTP
        configuration.setAllowedHeaders(Arrays.asList("*"));
        
        // Expose headers
        configuration.setExposedHeaders(Arrays.asList(
            "Authorization", 
            "Cache-Control", 
            "Content-Type", 
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Credentials"
        ));
        
        // Cho phép gửi thông tin xác thực
        configuration.setAllowCredentials(true);
        
        // Thời gian cache preflight request
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // Áp dụng cấu hình cho tất cả các đường dẫn
        source.registerCorsConfiguration("/**", configuration);
        log.info("CORS configuration registered with enhanced settings");
        return source;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/ThymeleafConfig.java">
package com.classroomapp.classroombackend.config;

import java.nio.charset.StandardCharsets;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.spring6.SpringTemplateEngine;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.ClassLoaderTemplateResolver;
import org.thymeleaf.templateresolver.ITemplateResolver;

@Configuration
public class ThymeleafConfig {

    @Bean(name = "webTemplateEngine")
    public TemplateEngine webTemplateEngine() {
        final SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.addTemplateResolver(htmlTemplateResolver());
        return templateEngine;
    }

    private ITemplateResolver htmlTemplateResolver() {
        final ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();
        templateResolver.setPrefix("templates/");
        templateResolver.setSuffix(".html");
        templateResolver.setTemplateMode(TemplateMode.HTML);
        templateResolver.setCharacterEncoding(StandardCharsets.UTF_8.name());
        templateResolver.setCacheable(false);
        return templateResolver;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/UTF8EncodingConfig.java">
package com.classroomapp.classroombackend.config;

import java.nio.charset.StandardCharsets;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.CharacterEncodingFilter;

import lombok.extern.slf4j.Slf4j;

/**
 * UTF-8 Encoding Configuration for Vietnamese Text Support
 * 
 * This configuration ensures that all HTTP requests and responses
 * use UTF-8 encoding to properly handle Vietnamese characters.
 */
@Slf4j
@Configuration
public class UTF8EncodingConfig {

    /**
     * Configure UTF-8 character encoding filter
     * This filter ensures all requests and responses use UTF-8 encoding
     */
    @Bean
    public FilterRegistrationBean<CharacterEncodingFilter> characterEncodingFilter() {
        log.info("🔧 Configuring UTF-8 character encoding filter for Vietnamese text support");
        
        CharacterEncodingFilter filter = new CharacterEncodingFilter();
        filter.setEncoding(StandardCharsets.UTF_8.name());
        filter.setForceEncoding(true);
        filter.setForceRequestEncoding(true);
        filter.setForceResponseEncoding(true);
        
        FilterRegistrationBean<CharacterEncodingFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(filter);
        registrationBean.addUrlPatterns("/*");
        registrationBean.setOrder(1); // Highest priority
        registrationBean.setName("UTF8EncodingFilter");
        
        log.info("✅ UTF-8 character encoding filter configured successfully");
        log.info("📝 Filter will apply UTF-8 encoding to all requests and responses");
        
        return registrationBean;
    }

    /**
     * System property configuration for UTF-8 support
     * This method sets JVM system properties to ensure UTF-8 is used throughout the application
     */
    @Bean
    public UTF8SystemPropertiesInitializer utf8SystemPropertiesInitializer() {
        return new UTF8SystemPropertiesInitializer();
    }

    /**
     * Inner class to initialize UTF-8 system properties
     */
    public static class UTF8SystemPropertiesInitializer {
        
        public UTF8SystemPropertiesInitializer() {
            log.info("🔧 Initializing UTF-8 system properties for Vietnamese text support");
            
            // Set file encoding to UTF-8
            System.setProperty("file.encoding", StandardCharsets.UTF_8.name());
            
            // Set default charset for HTTP connections
            System.setProperty("http.agent.charset", StandardCharsets.UTF_8.name());
            
            // Set default charset for URL encoding
            System.setProperty("url.encoding", StandardCharsets.UTF_8.name());
            
            // Set console encoding to UTF-8 (for Windows compatibility)
            System.setProperty("console.encoding", StandardCharsets.UTF_8.name());
            
            // Set SQL Server specific properties for Unicode support
            System.setProperty("sqlserver.charset", StandardCharsets.UTF_8.name());
            System.setProperty("sqlserver.sendStringParametersAsUnicode", "true");
            
            // Log current encoding settings
            logEncodingSettings();
            
            log.info("✅ UTF-8 system properties initialized successfully");
        }
        
        private void logEncodingSettings() {
            log.info("📊 Current encoding settings:");
            log.info("   - file.encoding: {}", System.getProperty("file.encoding"));
            log.info("   - Default charset: {}", java.nio.charset.Charset.defaultCharset());
            log.info("   - JVM default charset: {}", System.getProperty("file.encoding"));
            log.info("   - Console encoding: {}", System.getProperty("console.encoding"));
            
            // Test Vietnamese character support
            String testVietnamese = "Chúng tôi vui mừng thông báo hệ thống mới";
            byte[] utf8Bytes = testVietnamese.getBytes(StandardCharsets.UTF_8);
            String reconstructed = new String(utf8Bytes, StandardCharsets.UTF_8);
            
            boolean encodingWorking = testVietnamese.equals(reconstructed);
            log.info("   - Vietnamese encoding test: {} ({})", 
                encodingWorking ? "✅ PASSED" : "❌ FAILED",
                encodingWorking ? "Characters preserved" : "Characters corrupted"
            );
            
            if (!encodingWorking) {
                log.error("❌ Vietnamese character encoding test failed!");
                log.error("   Original: {}", testVietnamese);
                log.error("   Reconstructed: {}", reconstructed);
                log.error("   UTF-8 bytes length: {}", utf8Bytes.length);
            }
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/UTF8EncodingFixer.java">
package com.classroomapp.classroombackend.config;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;

import lombok.extern.slf4j.Slf4j;

/**
 * Component để sửa lỗi encoding UTF-8 cho dữ liệu tiếng Việt
 * Chạy sau khi ứng dụng khởi động để kiểm tra và sửa dữ liệu bị lỗi encoding
 */
@Component
@Order(1000) // Chạy sau khi data loader hoàn thành
@Slf4j
public class UTF8EncodingFixer implements CommandLineRunner {

    @Autowired
    private SubmissionRepository submissionRepository;

    @Override
    public void run(String... args) throws Exception {
        log.info("🔧 Starting UTF-8 encoding verification and fix...");
        
        // Set system properties for UTF-8
        System.setProperty("file.encoding", "UTF-8");
        System.setProperty("console.encoding", "UTF-8");
        System.setProperty("sun.jnu.encoding", "UTF-8");
        
        // Fix existing feedback data
        fixSubmissionFeedbackEncoding();
        
        log.info("✅ UTF-8 encoding verification and fix completed.");
    }

    /**
     * Sửa lỗi encoding cho feedback trong submissions
     */
    private void fixSubmissionFeedbackEncoding() {
        log.info("🔍 Checking submission feedback encoding...");
        
        List<Submission> submissions = submissionRepository.findAll();
        int fixedCount = 0;
        
        for (Submission submission : submissions) {
            if (submission.getFeedback() != null && !submission.getFeedback().isEmpty()) {
                String originalFeedback = submission.getFeedback();
                String fixedFeedback = fixUTF8Encoding(originalFeedback);
                
                if (!originalFeedback.equals(fixedFeedback)) {
                    log.info("🔧 Fixing feedback encoding for submission ID: {}", submission.getId());
                    log.info("   Before: {}", originalFeedback);
                    log.info("   After:  {}", fixedFeedback);
                    
                    submission.setFeedback(fixedFeedback);
                    submissionRepository.save(submission);
                    fixedCount++;
                }
            }
        }
        
        log.info("✅ Fixed {} submission feedbacks with encoding issues", fixedCount);
    }

    /**
     * Sửa lỗi encoding UTF-8 cho chuỗi text
     * @param text Chuỗi cần sửa
     * @return Chuỗi đã sửa lỗi encoding
     */
    private String fixUTF8Encoding(String text) {
        if (text == null || text.isEmpty()) {
            return text;
        }
        
        try {
            // Kiểm tra xem text có chứa ký tự lỗi encoding không
            if (text.contains("?") || text.contains(" ")) {
                // Thử decode/encode để sửa lỗi
                byte[] bytes = text.getBytes(StandardCharsets.ISO_8859_1);
                String fixed = new String(bytes, StandardCharsets.UTF_8);
                
                // Kiểm tra nếu kết quả có ý nghĩa hơn
                if (containsVietnameseCharacters(fixed)) {
                    return fixed;
                }
            }
            
            // Kiểm tra và sửa URL encoding issues
            if (text.contains("%")) {
                try {
                    String decoded = URLDecoder.decode(text, StandardCharsets.UTF_8.toString());
                    if (containsVietnameseCharacters(decoded)) {
                        return decoded;
                    }
                } catch (UnsupportedEncodingException e) {
                    // Ignore and continue
                }
            }
            
            // Nếu không có vấn đề, trả về text gốc
            return text;
            
        } catch (Exception e) {
            log.warn("Could not fix encoding for text: {}", text, e);
            return text;
        }
    }

    /**
     * Kiểm tra xem chuỗi có chứa ký tự tiếng Việt không
     */
    private boolean containsVietnameseCharacters(String text) {
        if (text == null) return false;
        
        String vietnamese = "àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđ" +
                           "ÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸĐ";
        
        return text.chars().anyMatch(c -> vietnamese.indexOf(c) >= 0);
    }

    /**
     * Test encoding với text mẫu
     */
    public void testEncoding() {
        String[] testTexts = {
            "Làm rất tốt! Bài làm chi tiết và đầy đủ.",
            "Xuất sắc! Phân tích chính xác.",
            "Cần cải thiện thêm về phần kết luận."
        };
        
        log.info("🧪 Testing UTF-8 encoding...");
        for (String text : testTexts) {
            log.info("Original: {}", text);
            log.info("Fixed:    {}", fixUTF8Encoding(text));
            log.info("---");
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/WebConfig.java">
package com.classroomapp.classroombackend.config;

import java.nio.charset.StandardCharsets;
import java.util.List;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    // Remove CORS configuration from here since it's handled in SecurityConfig
    // @Override
    // public void addCorsMappings(CorsRegistry registry) {
    //     // Moved to SecurityConfig to avoid conflicts
    // }
    
    @Bean
    public HttpMessageConverter<String> responseBodyConverter() {
        StringHttpMessageConverter converter = new StringHttpMessageConverter(StandardCharsets.UTF_8);
        converter.setWriteAcceptCharset(false);
        return converter;
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        log.info("🔧 Configuring UTF-8 message converters for Vietnamese text support");

        // Clear existing converters to ensure our UTF-8 converters take precedence
        converters.clear();

        // Add UTF-8 String converter with highest priority
        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(StandardCharsets.UTF_8);
        stringConverter.setWriteAcceptCharset(false);
        converters.add(stringConverter);

        // Add UTF-8 JSON converter with explicit charset
        MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();
        jsonConverter.setDefaultCharset(StandardCharsets.UTF_8);

        // Set supported media types with UTF-8 charset
        jsonConverter.setSupportedMediaTypes(List.of(
            new MediaType("application", "json", StandardCharsets.UTF_8),
            new MediaType("application", "*+json", StandardCharsets.UTF_8),
            new MediaType("text", "json", StandardCharsets.UTF_8)
        ));

        converters.add(jsonConverter);

        log.info("✅ UTF-8 message converters configured successfully");
    }

    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        log.info("🔧 Configuring content negotiation with UTF-8 default");
        configurer
            .defaultContentType(new MediaType("application", "json", StandardCharsets.UTF_8))
            .mediaType("json", new MediaType("application", "json", StandardCharsets.UTF_8))
            .mediaType("xml", new MediaType("application", "xml", StandardCharsets.UTF_8));
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/config/WebSocketConfig.java">
package com.classroomapp.classroombackend.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.lang.NonNull;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

import com.classroomapp.classroombackend.service.SignalingWebSocketHandler;

/**
 * WebSocket Configuration for Video Conference Signaling
 */
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Bean
    public SignalingWebSocketHandler signalingWebSocketHandler() {
        return new SignalingWebSocketHandler();
    }
    
    @Override
    public void registerWebSocketHandlers(@NonNull WebSocketHandlerRegistry registry) {
        // Register signaling handler for video conference
        registry.addHandler(signalingWebSocketHandler(), "/signaling")
                .setAllowedOrigins("*"); // In production, specify exact origins
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/constants/RoleConstants.java">
package com.classroomapp.classroombackend.constants;

public class RoleConstants {
    public static final int STUDENT = 1;
    public static final int TEACHER = 2;
    public static final int MANAGER = 3;
    public static final int ADMIN = 4;
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AcademicPerformanceController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

@RestController
@RequestMapping("/api/academic-performance")
public class AcademicPerformanceController {
    
    private static final Logger logger = LoggerFactory.getLogger(AcademicPerformanceController.class);

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private SubmissionRepository submissionRepository;
    
    @GetMapping("/student")
    public ResponseEntity<Map<String, Object>> getStudentAcademicPerformance(Authentication authentication) {
        try {
            String usernameOrEmail = authentication.getName();
            User currentUser;
            
            // Check if the authentication name is an email or username
            if (usernameOrEmail.contains("@")) {
                currentUser = userRepository.findByEmail(usernameOrEmail)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "email", usernameOrEmail));
            } else {
                currentUser = userRepository.findByUsername(usernameOrEmail)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", usernameOrEmail));
            }
            
            // Lấy dữ liệu thực từ database
            Map<String, Object> response = new HashMap<>();
            List<Submission> submissions = submissionRepository.findByStudent(currentUser);
            
            // Nhóm submissions theo môn học
            Map<String, List<Double>> scoresBySubject = new HashMap<>();
            
            for (Submission submission : submissions) {
                Assignment assignment = submission.getAssignment();
                if (assignment != null && submission.getScore() != null) {
                    String subjectName = "Unknown Subject";
                    if (assignment.getClassroom() != null && assignment.getClassroom().getSubject() != null) {
                        subjectName = assignment.getClassroom().getSubject();
                    }
                    
                    scoresBySubject.putIfAbsent(subjectName, new ArrayList<>());
                    scoresBySubject.get(subjectName).add(submission.getScore().doubleValue());
                }
            }
            
            // Tính điểm trung bình cho từng môn học
            List<Map<String, Object>> subjects = new ArrayList<>();
            double totalScore = 0;
            int subjectCount = 0;
            
            for (Map.Entry<String, List<Double>> entry : scoresBySubject.entrySet()) {
                String subject = entry.getKey();
                List<Double> scores = entry.getValue();
                
                if (!scores.isEmpty()) {
                    double sum = 0;
                    for (Double score : scores) {
                        sum += score;
                    }
                    double averageScore = sum / scores.size();
                    
                    Map<String, Object> subjectData = createSubject(subject, averageScore);
                    subjects.add(subjectData);
                    totalScore += averageScore;
                    subjectCount++;
                }
            }
            
            response.put("subjects", subjects);
            
            // Tính điểm trung bình tổng thể
            double overallAverageScore = subjectCount > 0 ? totalScore / subjectCount : 0;
            response.put("averageScore", Math.round(overallAverageScore * 100.0) / 100.0);
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Error calculating student academic performance", e);
            return ResponseEntity.status(500).body(Map.of("error", "An internal error occurred: " + e.getMessage()));
        }
    }
    
    private Map<String, Object> createSubject(String name, double score) {
        Map<String, Object> subject = new HashMap<>();
        subject.put("subject", name);
        subject.put("score", score);
        
        // Determine rank based on score
        String rank;
        if (score >= 8.5) {
            rank = "Giỏi";
        } else if (score >= 6.5) {
            rank = "Khá";
        } else {
            rank = "Trung bình";
        }
        subject.put("rank", rank);
        
        return subject;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AccomplishmentController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.AccomplishmentDto;
import com.classroomapp.classroombackend.service.AccomplishmentService;

@RestController
@RequestMapping("/api/accomplishments")
@PreAuthorize("hasAnyRole('STUDENT', 'TEACHER')")
public class AccomplishmentController {
    
    private final AccomplishmentService accomplishmentService;
    
    @Autowired
    public AccomplishmentController(AccomplishmentService accomplishmentService) {
        this.accomplishmentService = accomplishmentService;
    }
    
    @GetMapping("/my-accomplishments")
    public ResponseEntity<List<AccomplishmentDto>> getMyAccomplishments(@AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(accomplishmentService.getAccomplishmentsByOwner(userDetails));
    }
    
    @PostMapping
    public ResponseEntity<AccomplishmentDto> createAccomplishment(
            @RequestBody AccomplishmentDto accomplishmentDto,
            @AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(accomplishmentService.createAccomplishment(accomplishmentDto, userDetails));
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("@accomplishmentSecurityService.isOwner(authentication, #id)")
    public ResponseEntity<AccomplishmentDto> updateAccomplishment(
            @PathVariable Long id,
            @RequestBody AccomplishmentDto accomplishmentDto) {
        return ResponseEntity.ok(accomplishmentService.updateAccomplishment(id, accomplishmentDto));
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("@accomplishmentSecurityService.isOwner(authentication, #id)")
    public ResponseEntity<Void> deleteAccomplishment(@PathVariable Long id) {
        accomplishmentService.deleteAccomplishment(id);
        return ResponseEntity.ok().build();
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AdminController.java">
package com.classroomapp.classroombackend.controller;

import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.dto.usermanagement.UpdateUserRolesRequest;
import com.classroomapp.classroombackend.dto.usermanagement.UpdateUserStatusRequest;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.service.UserService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/admin/users")
@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
public class AdminController {

    @Autowired
    private UserService userService;

    @GetMapping
    public ResponseEntity<Page<UserDto>> getAllUsers(
            @RequestParam(required = false) String keyword,
            @PageableDefault(size = 10, sort = "fullName") Pageable pageable) {
        Page<UserDto> users = userService.findAllUsers(keyword, pageable);
        return ResponseEntity.ok(users);
    }

    @PutMapping("/{userId}/status")
    @PreAuthorize("hasRole('ADMIN')") // Chỉ Admin mới được đổi status
    public ResponseEntity<UserDto> updateUserStatus(
            @PathVariable Long userId,
            @Valid @RequestBody UpdateUserStatusRequest statusRequest) {
        UserDto updatedUser = userService.updateUserStatus(userId, statusRequest.getEnabled());
        return ResponseEntity.ok(updatedUser);
    }

    @PutMapping("/{userId}/roles")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> updateUserRoles(
            @PathVariable Long userId,
            @Valid @RequestBody UpdateUserRolesRequest rolesRequest) {
        try {
            UserDto updatedUser = userService.updateUserRoles(userId, rolesRequest.getRoles());
            return ResponseEntity.ok(updatedUser);
        } catch (BusinessLogicException e) {
            return ResponseEntity.badRequest().body(Map.of("message", e.getMessage()));
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AdminRequestController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.requestmanagement.RequestDTO;
import com.classroomapp.classroombackend.service.AdminRequestService;

@RestController
@RequestMapping("/api/admin/requests")
@PreAuthorize("hasRole('MANAGER')")
public class AdminRequestController {

    private final AdminRequestService adminRequestService;

    public AdminRequestController(AdminRequestService adminRequestService) {
        this.adminRequestService = adminRequestService;
    }

    @GetMapping
    public ResponseEntity<List<RequestDTO>> getAllRequests() {
        return ResponseEntity.ok(adminRequestService.getAllRequests());
    }

    @GetMapping("/pending")
    public ResponseEntity<List<RequestDTO>> getPendingRequests() {
        return ResponseEntity.ok(adminRequestService.getPendingRequests());
    }

    @PostMapping("/{id}/approve")
    public ResponseEntity<RequestDTO> approveRequest(@PathVariable Long id) {
        return ResponseEntity.ok(adminRequestService.approveRequest(id));
    }

    @PostMapping("/{id}/reject")
    public ResponseEntity<RequestDTO> rejectRequest(@PathVariable Long id, @RequestBody String reason) {
        return ResponseEntity.ok(adminRequestService.rejectRequest(id, reason));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AnnouncementController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.AnnouncementDto;
import com.classroomapp.classroombackend.dto.CreateAnnouncementDto;
import com.classroomapp.classroombackend.service.AnnouncementService;
import com.classroomapp.classroombackend.service.impl.AnnouncementServiceImpl;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/api/announcements")
@RequiredArgsConstructor
@Slf4j
public class AnnouncementController {

    private final AnnouncementService announcementService;
    private final AnnouncementServiceImpl announcementServiceImpl;


    @PostMapping
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    public ResponseEntity<AnnouncementDto> createAnnouncement(@Valid @RequestBody CreateAnnouncementDto createDto) {
        log.info("Request to create a new announcement with title: {}", createDto.getTitle());
        // For now, we pass a placeholder for the creator's ID. This should be extracted
        // from the security context in a real implementation.
        Long placeholderUserId = 1L;
        AnnouncementDto savedAnnouncement = announcementService.createAnnouncement(createDto, placeholderUserId);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedAnnouncement);
    }

    @PutMapping("/{announcementId}")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    public ResponseEntity<AnnouncementDto> updateAnnouncement(
            @PathVariable Long announcementId,
            @Valid @RequestBody CreateAnnouncementDto updateDto) {
        log.info("Request to update announcement ID: {}", announcementId);
        AnnouncementDto updatedAnnouncement = announcementService.updateAnnouncement(announcementId, updateDto);
        return ResponseEntity.ok(updatedAnnouncement);
    }

    @DeleteMapping("/{announcementId}")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    public ResponseEntity<Void> deleteAnnouncement(@PathVariable Long announcementId) {
        log.info("Request to delete announcement ID: {}", announcementId);
        announcementService.deleteAnnouncement(announcementId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/{announcementId}")
    public ResponseEntity<AnnouncementDto> getAnnouncementById(@PathVariable Long announcementId){
        log.info("Request to get announcement by Id: {}", announcementId);
        return ResponseEntity.ok(announcementService.getAnnouncementById(announcementId));
    }


    @GetMapping
    public ResponseEntity<List<AnnouncementDto>> getAllAnnouncements() {
        log.info("Request to get all announcements");
        List<AnnouncementDto> announcements = announcementServiceImpl.getAllAnnouncements();
        return ResponseEntity.ok(announcements);
    }

    @GetMapping("/student")
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<List<AnnouncementDto>> getAnnouncementsForStudent() {
        log.info("Request to get announcements for student");
        List<AnnouncementDto> announcements = announcementServiceImpl.getAnnouncementsForStudent();
        return ResponseEntity.ok(announcements);
    }

    // The old endpoints below are now either refactored or can be removed.
    // I am keeping them commented out for reference, but they should be cleaned up.
    /*
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<Announcement>> getAnnouncementsForUser(
            @PathVariable Long userId,
            @RequestParam(required = false, defaultValue = "all") String filter) {
        // ...
    }

    @PutMapping("/{announcementId}/read")
    public ResponseEntity<Void> markAnnouncementAsRead(@PathVariable Long announcementId) {
        // ...
    }

    @GetMapping("/user/{userId}/unread-count")
    public ResponseEntity<Integer> getUnreadCount(@PathVariable Long userId) {
        // ...
    }
    */
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AssignmentController.java">
package com.classroomapp.classroombackend.controller;

import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.AssignmentRubricDto;
import com.classroomapp.classroombackend.dto.AssignmentSubmissionDto;
import com.classroomapp.classroombackend.dto.BulkGradingDto;
import com.classroomapp.classroombackend.dto.BulkGradingResultDto;
import com.classroomapp.classroombackend.dto.CreateFeedbackDto;
import com.classroomapp.classroombackend.dto.CreateRubricDto;
import com.classroomapp.classroombackend.dto.FeedbackDto;
import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.GradeDto;
import com.classroomapp.classroombackend.dto.GradingAnalyticsDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateAssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.SubmissionDto;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.assignmentmanagement.SubmissionAttachment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AssignmentService;
import com.classroomapp.classroombackend.service.FileStorageService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/api/assignments")
@RequiredArgsConstructor
@Slf4j
public class AssignmentController {

    private final AssignmentService assignmentService;
    private final FileStorageService fileStorageService;
    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final SubmissionRepository submissionRepository;

    // Add endpoint to get all assignments (needed by frontend)
    @GetMapping
    // @PreAuthorize("permitAll()") // Temporarily disable security for testing
    public ResponseEntity<Map<String, Object>> GetAllAssignments() {
        List<AssignmentDto> assignments = assignmentService.GetAllAssignments();

        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "Retrieved all assignments successfully");
        response.put("data", assignments);

        return ResponseEntity.ok(response);
    }

    // Add endpoint to get assignments for the current teacher
    @GetMapping("/current-teacher")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<AssignmentDto>> GetAssignmentsByCurrentTeacher() {
        log.info("🔍 AssignmentController.GetAssignmentsByCurrentTeacher called");
        try {
            List<AssignmentDto> assignments = assignmentService.getAssignmentsByCurrentTeacher();
            log.info("✅ Successfully retrieved {} assignments for current teacher", assignments.size());
            return ResponseEntity.ok(assignments);
        } catch (Exception e) {
            log.error("❌ Error retrieving assignments for current teacher: {}", e.getMessage(), e);
            throw e;
        }
    }

    // Add endpoint to get assignments by student
    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<AssignmentDto>> GetAssignmentsByStudent(@PathVariable Long studentId) {
        return ResponseEntity.ok(assignmentService.GetAssignmentsByStudent(studentId));
    }

    @GetMapping("/teacher/{teacherId}")
    public ResponseEntity<List<AssignmentDto>> getAssignmentsByTeacher(@PathVariable Long teacherId) {
        log.info("🔍 AssignmentController.getAssignmentsByTeacher called with teacherId: {}", teacherId);
        try {
            List<AssignmentDto> assignments = assignmentService.getAssignmentsByTeacher(teacherId);
            log.info("✅ Successfully retrieved {} assignments for teacher {}", assignments.size(), teacherId);
            return ResponseEntity.ok(assignments);
        } catch (Exception e) {
            log.error("❌ Error retrieving assignments for teacher {}: {}", teacherId, e.getMessage(), e);
            throw e;
        }
    }

    // Add endpoint for currently authenticated student
    @GetMapping("/student/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<AssignmentDto>> GetAssignmentsForCurrentStudent() {
        return ResponseEntity.ok(assignmentService.getAssignmentsByCurrentStudent());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Map<String, Object>> GetAssignmentById(@PathVariable Long id) {
        AssignmentDto assignment = assignmentService.GetAssignmentById(id);
        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "Assignment retrieved successfully");
        response.put("data", assignment);
        return ResponseEntity.ok(response);
    }

    @PostMapping
    @PreAuthorize("hasAnyRole('TEACHER', 'ADMIN')")
    public ResponseEntity<AssignmentDto> CreateAssignment(@RequestBody CreateAssignmentDto createAssignmentDto,
                                                         java.security.Principal principal) {
        String teacherUsername = principal != null ? principal.getName() : null;
        return new ResponseEntity<>(assignmentService.CreateAssignment(createAssignmentDto, teacherUsername), HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<AssignmentDto> UpdateAssignment(
            @PathVariable Long id,
            @Valid @RequestBody CreateAssignmentDto updateAssignmentDto) {
        return ResponseEntity.ok(assignmentService.UpdateAssignment(id, updateAssignmentDto));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> DeleteAssignment(@PathVariable Long id) {
        assignmentService.DeleteAssignment(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/classroom/{classroomId}")
    // @PreAuthorize("permitAll()") // Temporarily disable security for testing
    public ResponseEntity<List<AssignmentDto>> GetAssignmentsByClassroom(@PathVariable Long classroomId) {
        return ResponseEntity.ok(assignmentService.GetAssignmentsByClassroom(classroomId));
    }

    @GetMapping("/classroom/{classroomId}/upcoming")
    public ResponseEntity<List<AssignmentDto>> GetUpcomingAssignmentsByClassroom(@PathVariable Long classroomId) {
        return ResponseEntity.ok(assignmentService.GetUpcomingAssignmentsByClassroom(classroomId));
    }

    @GetMapping("/classroom/{classroomId}/past")
    public ResponseEntity<List<AssignmentDto>> GetPastAssignmentsByClassroom(@PathVariable Long classroomId) {
        return ResponseEntity.ok(assignmentService.GetPastAssignmentsByClassroom(classroomId));
    }

    @GetMapping("/search")
    public ResponseEntity<List<AssignmentDto>> SearchAssignmentsByTitle(@RequestParam String title) {
        return ResponseEntity.ok(assignmentService.SearchAssignmentsByTitle(title));
    }
    
    // Temporary endpoint to create sample assignments for testing
    @GetMapping("/create-samples/{classroomId}")
    public ResponseEntity<Map<String, Object>> createSampleAssignments(@PathVariable Long classroomId) {
        try {
            // Find classroom
            Classroom classroom = classroomRepository.findById(classroomId).orElse(null);
            if (classroom == null) {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "error");
                response.put("message", "Classroom not found");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Create sample assignments
            List<Assignment> sampleAssignments = new ArrayList<>();
            
            Assignment assignment1 = new Assignment();
            assignment1.setTitle("Bài tập 1: Giới thiệu bản thân");
            assignment1.setDescription("Viết một đoạn văn ngắn giới thiệu về bản thân, sở thích và mục tiêu học tập. Độ dài khoảng 200-300 từ.");
            assignment1.setDueDate(LocalDateTime.of(2024, 12, 30, 23, 59, 59));
            assignment1.setPoints(100);
            assignment1.setClassroom(classroom);
            sampleAssignments.add(assignment1);
            
            Assignment assignment2 = new Assignment();
            assignment2.setTitle("Bài tập 2: Tìm hiểu về lập trình");
            assignment2.setDescription("Nghiên cứu về một ngôn ngữ lập trình mà bạn quan tâm. Trình bày ưu điểm, nhược điểm và ứng dụng thực tế.");
            assignment2.setDueDate(LocalDateTime.of(2025, 1, 15, 23, 59, 59));
            assignment2.setPoints(150);
            assignment2.setClassroom(classroom);
            sampleAssignments.add(assignment2);
            
            Assignment assignment3 = new Assignment();
            assignment3.setTitle("Bài tập 3: Dự án nhóm");
            assignment3.setDescription("Làm việc theo nhóm để tạo ra một ứng dụng web đơn giản. Yêu cầu có giao diện thân thiện và chức năng cơ bản.");
            assignment3.setDueDate(LocalDateTime.of(2025, 2, 1, 23, 59, 59));
            assignment3.setPoints(200);
            assignment3.setClassroom(classroom);
            sampleAssignments.add(assignment3);
            
            // Save assignments using service
            for (Assignment assignment : sampleAssignments) {
                assignmentService.CreateAssignment(convertToCreateDto(assignment), "system");
            }
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Sample assignments created successfully");
            response.put("count", sampleAssignments.size());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Error creating sample assignments: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // Helper method to convert Assignment to CreateAssignmentDto
    private CreateAssignmentDto convertToCreateDto(Assignment assignment) {
        CreateAssignmentDto dto = new CreateAssignmentDto();
        dto.setTitle(assignment.getTitle());
        dto.setDescription(assignment.getDescription());
        dto.setDueDate(assignment.getDueDate());
        dto.setPoints(assignment.getPoints());
        dto.setClassroomId(assignment.getClassroom().getId());
        return dto;
    }

    // Advanced Grading APIs for frontend AdvancedGrading.jsx
    @GetMapping("/{id}/submissions")
    @PreAuthorize("permitAll()") // Allow access for testing
    public ResponseEntity<List<AssignmentSubmissionDto>> getAssignmentSubmissions(@PathVariable Long id) {
        try {
            log.info("Getting submissions for assignment ID: " + id);
            List<AssignmentSubmissionDto> submissions = assignmentService.getAssignmentSubmissions(id);
            log.info("Found {} submissions for assignment {}", submissions.size(), id);
            return ResponseEntity.ok(submissions);
        } catch (Exception e) {
            log.error("Error getting submissions for assignment " + id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/{assignmentId}/submissions/{submissionId}/grade")
    public ResponseEntity<GradeDto> gradeSubmission(
            @PathVariable Long assignmentId,
            @PathVariable Long submissionId,
            @Valid @RequestBody GradeSubmissionDto gradeSubmissionDto) {
        log.info("Grading submission {} for assignment {}", submissionId, assignmentId);
        return ResponseEntity.ok(assignmentService.gradeSubmission(assignmentId, submissionId, gradeSubmissionDto));
    }

    @GetMapping("/{id}/rubric")
    public ResponseEntity<AssignmentRubricDto> getAssignmentRubric(@PathVariable Long id) {
        return ResponseEntity.ok(assignmentService.getAssignmentRubric(id));
    }

    @PostMapping("/{id}/rubric")
    public ResponseEntity<AssignmentRubricDto> createAssignmentRubric(
            @PathVariable Long id,
            @Valid @RequestBody CreateRubricDto createRubricDto) {
        return ResponseEntity.ok(assignmentService.createAssignmentRubric(id, createRubricDto));
    }

    @PostMapping("/{id}/bulk-grade")
    public ResponseEntity<BulkGradingResultDto> bulkGradeSubmissions(
            @PathVariable Long id,
            @Valid @RequestBody BulkGradingDto bulkGradingDto) {
        return ResponseEntity.ok(assignmentService.bulkGradeSubmissions(id, bulkGradingDto));
    }

    @GetMapping("/{id}/analytics")
    public ResponseEntity<GradingAnalyticsDto> getGradingAnalytics(@PathVariable Long id) {
        return ResponseEntity.ok(assignmentService.getGradingAnalytics(id));
    }

    @PostMapping("/{assignmentId}/feedback")
    public ResponseEntity<FeedbackDto> provideFeedback(
            @PathVariable Long assignmentId,
            @Valid @RequestBody CreateFeedbackDto createFeedbackDto) {
        return ResponseEntity.ok(assignmentService.provideFeedback(assignmentId, createFeedbackDto));
    }

    /**
     * Seed the database with mock assignment data
     * This endpoint is for development/testing purposes only
     */
    @PostMapping("/seed")
    public ResponseEntity<Map<String, Object>> seedMockData(
            @RequestBody(required = false) List<CreateAssignmentDto> mockData) {
        Map<String, Object> result = new HashMap<>();
        List<AssignmentDto> assignmentsCreated = new ArrayList<>();
        List<SubmissionDto> submissionsCreated = new ArrayList<>();

        try {
            log.info("Starting to seed mock assignment data");

            // If no mock data is provided, use default mock data
            if (mockData == null || mockData.isEmpty()) {
                // Find classrooms to associate assignments with
                List<Classroom> classrooms = classroomRepository.findAll();
                if (classrooms.isEmpty()) {
                    return ResponseEntity.badRequest()
                            .body(Map.of("status", "error", "message",
                                    "No classrooms available to create assignments"));
                }
                String defaultTeacherUsername = classrooms.get(0).getTeacher().getEmail();


                // Create default mock assignments
                CreateAssignmentDto assignment1 = new CreateAssignmentDto();
                assignment1.setTitle("Bài tập 1: Giải phương trình bậc 2");
                assignment1.setDescription("Làm các bài tập từ 1-10 trang 45 sách giáo khoa.");
                assignment1.setDueDate(LocalDateTime.now().plusDays(3));
                assignment1.setPoints(100);
                assignment1.setClassroomId(classrooms.get(0).getId());
                assignment1.setAttachments(new ArrayList<>()); // No attachments for this mock

                CreateAssignmentDto assignment2 = new CreateAssignmentDto();
                assignment2.setTitle("Bài tập 2: Viết đoạn văn tả mùa xuân");
                assignment2.setDescription("Viết một đoạn văn khoảng 200 từ tả cảnh mùa xuân ở quê hương em.");
                assignment2.setDueDate(LocalDateTime.now().plusDays(7));
                assignment2.setPoints(50);
                assignment2
                        .setClassroomId(classrooms.size() > 1 ? classrooms.get(1).getId() : classrooms.get(0).getId());

                CreateAssignmentDto assignment3 = new CreateAssignmentDto();
                assignment3.setTitle("Bài tập 3: Viết chương trình Hello World");
                assignment3.setDescription("Viết chương trình Java hiển thị dòng chữ \"Hello World\" ra màn hình.");
                assignment3.setDueDate(LocalDateTime.now().minusDays(2));
                assignment3.setPoints(20);
                assignment3
                        .setClassroomId(classrooms.size() > 2 ? classrooms.get(2).getId() : classrooms.get(0).getId());

                // Save mock assignments
                AssignmentDto created1 = assignmentService.CreateAssignment(assignment1, defaultTeacherUsername);
                AssignmentDto created2 = assignmentService.CreateAssignment(assignment2, defaultTeacherUsername);
                AssignmentDto created3 = assignmentService.CreateAssignment(assignment3, defaultTeacherUsername);
                assignmentsCreated.addAll(List.of(created1, created2, created3));

                log.info("Created {} mock assignments", assignmentsCreated.size());

                // Create some example submissions for these assignments
                List<User> students = userRepository.findByRoleId(1); // Assuming role_id 1 is student
                if (!students.isEmpty()) {
                    log.info("Found {} students for creating submissions", students.size());

                    // For assignment 1
                    Assignment assignment1Entity = assignmentService.findEntityById(created1.getId());

                    // Submission 1 for assignment 1
                    Submission submission1 = new Submission();
                    submission1.setAssignment(assignment1Entity);
                    submission1.setStudent(students.get(0));
                    submission1.setComment("Em đã hoàn thành bài tập. Có một số bài em chưa chắc chắn.");
                    SubmissionAttachment attachment1 = new SubmissionAttachment();
                    attachment1.setFileUrl("https://example.com/submission1.pdf");
                    attachment1.setFileName("submission1.pdf");
                    submission1.addAttachment(attachment1);
                    submission1.setSubmittedAt(LocalDateTime.now().minusDays(1));
                    submission1.setScore(85);
                    submission1.setFeedback("Bài làm tốt, cần cải thiện phần giải phương trình vô nghiệm.");
                    submission1.setGradedAt(LocalDateTime.now().minusHours(6));
                    if (students.size() > 1) { // Use another student as the grader (assume teaching assistant)
                        submission1.setGradedBy(students.get(1));
                    }

                    Submission savedSubmission1 = submissionRepository.save(submission1);
                    submissionsCreated.add(convertToSubmissionDto(savedSubmission1));

                    // If we have more students, create more submissions
                    if (students.size() > 2) {
                        // Submission 2 for assignment 1
                        Submission submission2 = new Submission();
                        submission2.setAssignment(assignment1Entity);
                        submission2.setStudent(students.get(1));
                        submission2.setComment("Em đã làm xong bài tập.");
                        SubmissionAttachment attachment2 = new SubmissionAttachment();
                        attachment2.setFileUrl("https://example.com/submission2.pdf");
                        attachment2.setFileName("submission2.pdf");
                        submission2.addAttachment(attachment2);
                        submission2.setSubmittedAt(LocalDateTime.now().minusDays(2));
                        submission2.setScore(92);
                        submission2.setFeedback("Bài làm rất tốt, đầy đủ và chính xác.");
                        submission2.setGradedAt(LocalDateTime.now().minusHours(12));
                        submission2.setGradedBy(students.get(2));

                        Submission savedSubmission2 = submissionRepository.save(submission2);
                        submissionsCreated.add(convertToSubmissionDto(savedSubmission2));
                    }

                    // For assignment 3 (ungraded submission)
                    Assignment assignment3Entity = assignmentService.findEntityById(created3.getId());
                    Submission submission3 = new Submission();
                    submission3.setAssignment(assignment3Entity);
                    submission3.setStudent(students.get(0));
                    submission3.setComment("Em đã nộp bài, mong thầy/cô góp ý.");
                    SubmissionAttachment attachment3 = new SubmissionAttachment();
                    attachment3.setFileUrl("https://example.com/submission3.java");
                    attachment3.setFileName("submission3.java");
                    submission3.addAttachment(attachment3);
                    submission3.setSubmittedAt(LocalDateTime.now().minusDays(3));

                    Submission savedSubmission3 = submissionRepository.save(submission3);
                    submissionsCreated.add(convertToSubmissionDto(savedSubmission3));

                    log.info("Created {} mock submissions", submissionsCreated.size());
                } else {
                    log.warn("No students found to create submissions");
                }

            } else {
                // Find the first teacher to act as the creator for all mock data
                User teacher = userRepository.findAll().stream()
                        .filter(u -> u.getRoleId() == 2 || u.getRoleId() == 3)
                        .findFirst()
                        .orElse(null);

                if (teacher == null) {
                    return ResponseEntity.badRequest()
                            .body(Map.of("status", "error", "message", "No teachers available to create assignments"));
                }
                String teacherUsername = teacher.getEmail();

                for (CreateAssignmentDto mockAssignment : mockData) {
                    assignmentsCreated.add(assignmentService.CreateAssignment(mockAssignment, teacherUsername));
                }
            }

            log.info("Finished seeding mock assignments. Created {} assignments.", assignmentsCreated.size());

            result.put("status", "success");
            result.put("message", "Mock data has been added to the database");
            result.put("assignments", assignmentsCreated);
            result.put("submissions", submissionsCreated);

            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Failed to seed mock data", e);
            result.put("status", "error");
            result.put("message", "Failed to seed mock data: " + e.getMessage());
            result.put("error", e.getClass().getSimpleName());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    /**
     * Helper method to convert Submission entity to DTO
     */
    private SubmissionDto convertToSubmissionDto(Submission submission) {
        SubmissionDto dto = new SubmissionDto();
        dto.setId(submission.getId());
        dto.setAssignmentId(submission.getAssignment().getId());
        dto.setStudentId(submission.getStudent().getId());
        dto.setStudentName(submission.getStudent().getFullName());
        dto.setComment(submission.getComment());
        if (submission.getAttachments() != null && !submission.getAttachments().isEmpty()) {
            dto.setFileSubmissionUrl(submission.getAttachments().get(0).getFileUrl());
        }
        dto.setSubmittedAt(submission.getSubmittedAt());
        dto.setScore(submission.getScore());
        dto.setFeedback(submission.getFeedback());
        dto.setGradedAt(submission.getGradedAt());
        if (submission.getGradedBy() != null) {
            dto.setGradedById(submission.getGradedBy().getId());
            dto.setGradedByName(submission.getGradedBy().getFullName());
        }
        return dto;
    }

    @PostMapping("/upload")
    @PreAuthorize("permitAll()") // Allow access for testing
    public ResponseEntity<Map<String, Object>> uploadAssignmentFile(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "assignmentId", required = false) Long assignmentId) {
        try {
            Map<String, Object> response = new HashMap<>();
            
            // Validate file
            if (file.isEmpty()) {
                response.put("status", "error");
                response.put("message", "File is empty");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Check file size (max 10MB)
            if (file.getSize() > 10 * 1024 * 1024) {
                response.put("status", "error");
                response.put("message", "File size too large. Maximum 10MB allowed.");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Check file type
            String filename = file.getOriginalFilename();
            if (filename == null || (!filename.endsWith(".pdf") && !filename.endsWith(".docx") 
                && !filename.endsWith(".doc") && !filename.endsWith(".txt") && !filename.endsWith(".zip"))) {
                response.put("status", "error");
                response.put("message", "Invalid file type. Only PDF, DOCX, DOC, TXT, ZIP files are allowed.");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Save file to a temporary location
            Path tempFile = Files.createTempFile("upload-", ".tmp");
            file.transferTo(tempFile);

            // Upload file to Firebase Storage
            FileUploadResponse uploadResponse;
            try {
                log.info("Uploading file to Firebase Storage: " + filename);
                uploadResponse = fileStorageService.save(file, "assignments");
                log.info("File uploaded successfully to Firebase: " + uploadResponse.getFileUrl());
            } catch (Exception e) {
                log.error("Error uploading file to Firebase: " + e.getMessage());
                response.put("status", "error");
                response.put("message", "Failed to upload file to Firebase: " + e.getMessage());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
            
            // Create submission record in database
            try {
                // For now, use a test student ID. In production, get from SecurityContext
                Long studentId = 185L; // Use the actual ID from database
                
                // Get assignment and student entities
                Assignment assignment = assignmentService.findEntityById(assignmentId);
                User student = userRepository.findById(studentId)
                    .orElseThrow(() -> new RuntimeException("Student not found"));
                
                // Check if submission already exists
                Optional<Submission> existingSubmission = submissionRepository.findByAssignmentAndStudent(assignment, student);
                
                Submission submission;
                if (existingSubmission.isEmpty()) {
                    // Create new submission
                    submission = new Submission();
                    submission.setAssignment(assignment);
                    submission.setStudent(student);
                    submission.setSubmittedAt(LocalDateTime.now());
                    submission.setComment("File submission: " + filename);
                } else {
                    // Update existing submission
                    submission = existingSubmission.get();
                    submission.setSubmittedAt(LocalDateTime.now());
                    submission.setComment("File submission: " + filename);
                }
                
                // Save submission
                submission = submissionRepository.save(submission);
                log.info("Submission created/updated with ID: " + submission.getId());
                
                // Create submission attachment
                SubmissionAttachment attachment = new SubmissionAttachment();
                attachment.setSubmission(submission);
                attachment.setFileName(uploadResponse.getFileName());
                attachment.setFileUrl(uploadResponse.getFileUrl());
                attachment.setFileType(uploadResponse.getFileType());
                attachment.setFileSize(uploadResponse.getSize());
                
                // Add attachment to submission
                submission.addAttachment(attachment);
                
                // Save submission again to persist the attachment
                submissionRepository.save(submission);
                log.info("Submission attachment created for file: " + filename);
                
            } catch (Exception e) {
                log.error("Error creating submission record: " + e.getMessage(), e);
                // Don't fail the upload if database operation fails
            }
            
            // Return success response
            response.put("status", "success");
            response.put("message", "File uploaded successfully to Firebase Storage");
            response.put("filename", uploadResponse.getFileName());
            response.put("originalFilename", filename);
            response.put("size", uploadResponse.getSize());
            response.put("url", uploadResponse.getFileUrl());
            response.put("fileType", uploadResponse.getFileType());
            response.put("assignmentId", assignmentId);
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("Upload error: " + e.getMessage(), e);
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Upload failed: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // Test endpoint to debug submissions
    @GetMapping("/{id}/submissions-debug")
    @PreAuthorize("permitAll()") // Allow access for testing
    public ResponseEntity<Map<String, Object>> getAssignmentSubmissionsDebug(@PathVariable Long id) {
        try {
            log.info("Debug: Getting submissions for assignment ID: " + id);
            Map<String, Object> result = new HashMap<>();
            
            // Get raw submissions from repository
            List<Submission> submissions = submissionRepository.findByAssignmentId(id);
            log.info("Debug: Found {} raw submissions", submissions.size());
            
            result.put("submissionCount", submissions.size());
            result.put("assignmentId", id);
            
            if (!submissions.isEmpty()) {
                Submission first = submissions.get(0);
                Map<String, Object> firstSubmission = new HashMap<>();
                firstSubmission.put("id", first.getId());
                firstSubmission.put("comment", first.getComment());
                firstSubmission.put("submittedAt", first.getSubmittedAt());
                firstSubmission.put("hasStudent", first.getStudent() != null);
                if (first.getStudent() != null) {
                    firstSubmission.put("studentId", first.getStudent().getId());
                    firstSubmission.put("studentName", first.getStudent().getFullName());
                }
                firstSubmission.put("attachmentCount", first.getAttachments().size());
                result.put("firstSubmission", firstSubmission);
            }
            
            // Try the service method
            try {
                List<AssignmentSubmissionDto> dtos = assignmentService.getAssignmentSubmissions(id);
                result.put("dtoCount", dtos.size());
                result.put("serviceWorking", true);
            } catch (Exception e) {
                result.put("serviceWorking", false);
                result.put("serviceError", e.getMessage());
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Debug endpoint error", e);
            Map<String, Object> error = new HashMap<>();
            error.put("error", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AttendanceController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceRecordDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceResultDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSubmitDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.MyAttendanceHistoryDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.TeachingHistoryDto;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AttendanceService;

import lombok.RequiredArgsConstructor;

/**
 * REST Controller for handling attendance related APIs.
 * This controller provides secure endpoints for managing and viewing attendance records.
 */
@RestController
@RequestMapping("/api/attendance")
@RequiredArgsConstructor
public class AttendanceController {

    private final AttendanceService attendanceService;
    private final UserRepository userRepository; // Needed to fetch user from security context

    // This controller is now mostly deprecated in favor of AttendanceSessionController.
    // The getAttendanceResult endpoint is kept here as it's a general query
    // not strictly tied to a single "session" action.

    @GetMapping("/classroom/{classroomId}/student/{studentId}")
    @PreAuthorize("hasAnyRole('TEACHER', 'STUDENT')")
    public ResponseEntity<AttendanceResultDto> getAttendanceResult(
            @PathVariable Long classroomId,
            @PathVariable Long studentId) {
        AttendanceResultDto result = attendanceService.getAttendanceResult(classroomId, studentId);
        return ResponseEntity.ok(result);
    }
    
    /**
     * Gets the attendance status for all enrolled students for a specific lecture.
     * Accessible only by users with the 'TEACHER' role.
     */
    @GetMapping("/lecture/{lectureId}")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<List<AttendanceRecordDto>> getAttendanceForLecture(
            @PathVariable Long lectureId,
            @RequestParam Long classroomId) {
        List<AttendanceRecordDto> records = attendanceService.getAttendanceForLecture(lectureId, classroomId);
        return ResponseEntity.ok(records);
    }

    /**
     * Gets the personal attendance history for the currently authenticated student in a specific classroom.
     * Accessible by any authenticated user for their own record.
     */
    @GetMapping("/my-history")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<MyAttendanceHistoryDto>> getMyAttendanceHistory(@RequestParam Long classroomId) {
        try {
            UserDetails userDetails = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            System.out.println("User from security context: " + userDetails.getUsername());
            
            User currentUser = userRepository.findByEmail(userDetails.getUsername())
                    .orElseThrow(() -> new RuntimeException("User not found from security context: " + userDetails.getUsername()));
            
            System.out.println("Found user: " + currentUser.getId() + " - " + currentUser.getEmail());
            System.out.println("Requesting attendance history for classroom: " + classroomId);

            List<MyAttendanceHistoryDto> history = attendanceService.getMyAttendanceHistory(currentUser.getId(), classroomId);
            System.out.println("Found " + history.size() + " attendance records");
            
            return ResponseEntity.ok(history);
        } catch (Exception e) {
            System.err.println("Error in getMyAttendanceHistory: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }
    
    /**
     * Gets the attendance history for a specific student in a specific classroom.
     * Accessible only by users with the 'TEACHER' role for viewing any student's record.
     */
    @GetMapping("/history/student/{studentId}")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<List<MyAttendanceHistoryDto>> getStudentAttendanceHistoryForTeacher(
            @PathVariable Long studentId,
            @RequestParam Long classroomId) {
        List<MyAttendanceHistoryDto> history = attendanceService.getMyAttendanceHistory(studentId, classroomId);
        return ResponseEntity.ok(history);
    }
    
    /**
     * Gets the teaching history for the currently authenticated teacher.
     * This endpoint shows all lectures where the teacher was automatically clocked-in.
     * Accessible only by users with the 'TEACHER' role.
     */
    @GetMapping("/teaching-history")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<List<TeachingHistoryDto>> getMyTeachingHistory() {
        UserDetails userDetails = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        User currentUser = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found from security context"));
        
        List<TeachingHistoryDto> history = attendanceService.getTeachingHistory(currentUser.getId());
        return ResponseEntity.ok(history);
    }
    
    /**
     * Gets the teaching history for a specific teacher.
     * Accessible only by users with the 'MANAGER' or 'ADMIN' role.
     */
    @GetMapping("/teaching-history/{teacherId}")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    public ResponseEntity<List<TeachingHistoryDto>> getTeacherTeachingHistory(@PathVariable Long teacherId) {
        List<TeachingHistoryDto> history = attendanceService.getTeachingHistory(teacherId);
        return ResponseEntity.ok(history);
    }

    /**
     * Submits attendance records for a lecture.
     * Accessible only by users with the 'TEACHER' role.
     */
    @PostMapping("/submit")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<String> submitAttendance(@RequestBody AttendanceSubmitDto submitDto) {
        attendanceService.submitAttendance(submitDto);
        return ResponseEntity.ok("Attendance records submitted successfully");
    }
}


</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AttendanceSessionController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceResultDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateAttendanceSessionDto;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/attendance-sessions")
@RequiredArgsConstructor
public class AttendanceSessionController {

    @PostMapping
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<AttendanceSessionDto> createSession(@RequestBody CreateAttendanceSessionDto dto) {
        // Implementation will be in AttendanceService
        // AttendanceSessionDto createdSession = attendanceService.createSession(dto);
        // return ResponseEntity.ok(createdSession);
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @GetMapping("/classroom/{classroomId}/active")
    @PreAuthorize("@classroomSecurityService.isMember(#classroomId, principal)")
    public ResponseEntity<AttendanceSessionDto> getActiveSession(@PathVariable Long classroomId) {
        // Implementation will be in AttendanceService
        // AttendanceSessionDto activeSession = attendanceService.getActiveSession(classroomId);
        // return ResponseEntity.ok(activeSession);
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @GetMapping("/{sessionId}")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<List<AttendanceResultDto>> getSessionResults(@PathVariable Long sessionId) {
        // Implementation will be in AttendanceService
        // List<AttendanceResultDto> results = attendanceService.getSessionResults(sessionId);
        // return ResponseEntity.ok(results);
        throw new UnsupportedOperationException("Not implemented yet");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/AuthController.java">
package com.classroomapp.classroombackend.controller;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.PasswordConfirmationDto;
import com.classroomapp.classroombackend.dto.requestmanagement.CreateRequestDto;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.security.JwtUtil;
import com.classroomapp.classroombackend.service.AuthService;
import com.classroomapp.classroombackend.service.RequestService;
import com.classroomapp.classroombackend.service.UserService;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseToken;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;

/**
 * Controller for authentication-related endpoints
 */
@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {

    private final AuthService authService;
    private final UserRepository userRepository;
    private final UserService userService;
    private final RequestService requestService; // Inject RequestService
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public AuthController(AuthService authService, UserRepository userRepository, 
                         UserService userService, RequestService requestService, JwtUtil jwtUtil, PasswordEncoder passwordEncoder) {
        this.authService = authService;
        this.userRepository = userRepository;
        this.userService = userService;
        this.requestService = requestService; // Initialize RequestService
        this.jwtUtil = jwtUtil;
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * Submits a registration request for a new user
     * 
     * @param createRequestDto registration request information
     * @return success message
     */
    @PostMapping("/register")
    public ResponseEntity<?> submitRegistrationRequest(@Valid @RequestBody CreateRequestDto createRequestDto) {
        requestService.createRegistrationRequest(createRequestDto);
        return ResponseEntity.ok(Map.of("message", "Request submitted successfully. Please wait for approval."));
    }

    /**
     * Authenticate user with username and password
     * 
     * @param loginRequest login information
     * @return login response with JWT token
     */
    @PostMapping("/login")
    public ResponseEntity<Map<String, String>> loginUser(@RequestBody Map<String, String> credentials) {
        try {
            String username = credentials.get("username");
            String password = credentials.get("password");

            System.out.println("Login attempt for user: " + username);
            System.out.println("Password provided: " + password);

            // Try to find user by username first, then by email
            User user = userRepository.findByUsername(username)
                    .orElse(userRepository.findByEmail(username).orElse(null));
            
            if (user == null) {
                System.out.println("User not found: " + username);
                Map<String, String> errorResponse = new HashMap<>();
                errorResponse.put("error", "User not found");
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            System.out.println("User found: " + user.getUsername() + " (email: " + user.getEmail() + ")");
            System.out.println("Stored password hash: " + user.getPassword());
            System.out.println("Password encoder matches: " + passwordEncoder.matches(password, user.getPassword()));

            if (!passwordEncoder.matches(password, user.getPassword())) {
                System.out.println("Invalid password for user: " + username);
                Map<String, String> errorResponse = new HashMap<>();
                errorResponse.put("error", "Invalid password");
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            Map<String, String> response = new HashMap<>();

            // Chuyển đổi roleId thành tên vai trò để thêm vào token
            String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
            System.out.println("Login successful for user: " + username + " with role: " + roleName + " (roleId: " + user.getRoleId() + ")");
            
            // FIX: Use email as the subject for consistency
            Map<String, Object> claims = new HashMap<>();
            claims.put("sub", user.getEmail());
            claims.put("email", user.getEmail());
            claims.put("username", user.getUsername());
            claims.put("role", user.getRoleId());
            claims.put("roles", new String[]{roleName});
            
            // Generate JWT token mới với claims đầy đủ
            String token = Jwts.builder()
                .setClaims(claims)
                .setSubject(user.getEmail()) // CONSISTENT: Subject is always email
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) // 24 giờ
                .signWith(jwtUtil.getSecretKeyFromString(), SignatureAlgorithm.HS512)
                .compact();

            log.info("AuthController - Generated JWT token for user: {} with role: {}", user.getEmail(), user.getRoleId());
            
            System.out.println("Generated new token for user: " + username);
            
            response.put("role", roleName);
            response.put("roleId", user.getRoleId().toString());
            response.put("token", token);
            response.put("userId", user.getId().toString());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            System.out.println("Login error: " + e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("error", "Login failed: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }    /**
     * Request password reset
     * 
     * @param request password reset information
     * @return success message
     */
    @PostMapping("/forgot-password")
    public ResponseEntity<String> forgotPassword(@RequestBody Map<String, String> request) {
        String email = request.get("email");

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // Generate a password reset token with claims
        String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", user.getUsername());
        claims.put("email", user.getEmail());
        claims.put("role", user.getRoleId());
        claims.put("roles", new String[]{roleName});
        
        String resetToken = Jwts.builder()
            .setClaims(claims)
            .setSubject(user.getUsername())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000))
            .signWith(jwtUtil.getSecretKeyFromString(), SignatureAlgorithm.HS512)
            .compact();
            
        userService.sendPasswordResetEmail(user.getEmail(), resetToken);

        return ResponseEntity.ok("Password reset email sent successfully.");
    }

    /**
     * Reset password with token
     * 
     * @param passwordConfirmation password confirmation information
     * @return success message
     */
    @PostMapping("/reset-password")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody PasswordConfirmationDto passwordConfirmation) {
        log.info("Password reset confirmation received");
        authService.resetPassword(passwordConfirmation);
        return ResponseEntity.ok("Password reset successfully.");
    }    /**
     * Authenticate with Google ID token
     * 
     * @param credentials Google authentication information
     * @return login response with JWT token
     */
    @PostMapping("/google-login")
    public ResponseEntity<Map<String, Object>> googleLogin(@RequestBody Map<String, String> credentials) {
        String idToken = credentials.get("idToken");
        
        // Verify Google ID token
        FirebaseToken decodedToken;
        try {
            decodedToken = FirebaseAuth.getInstance().verifyIdToken(idToken);
        } catch (com.google.firebase.auth.FirebaseAuthException e) {
            log.error("Invalid Google ID token", e);
            throw new IllegalArgumentException("Token Google không hợp lệ", e);
        }
        
        String email = decodedToken.getEmail();
        log.info("Google login attempt with email: {}", email);
        
        // Check if user exists
        Map<String, Object> response = new HashMap<>();
        
        // Kiểm tra tài khoản tồn tại thay vì tự động tạo mới
        boolean userExists = userRepository.findByEmail(email).isPresent();
        if (!userExists) {
            log.warn("Google login failed: No account found for email: {}", email);
            response.put("success", false);
            response.put("message", "Tài khoản này chưa được đăng ký trong hệ thống");
            response.put("email", email);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
        
        User user = userRepository.findByEmail(email).get();
        log.info("User found with email {}, role: {}", email, user.getRoleId());
        
        // Generate JWT
        String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", user.getEmail());
        claims.put("email", user.getEmail());
        claims.put("role", user.getRoleId());
        claims.put("roles", new String[]{roleName});
        
        String token = Jwts.builder()
            .setClaims(claims)
            .setSubject(user.getEmail())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000))
            .signWith(jwtUtil.getSecretKeyFromString(), SignatureAlgorithm.HS512)
            .compact();
        
        response.put("success", true);
        response.put("message", "Đăng nhập thành công");
        response.put("role", roleName);
        response.put("roleId", user.getRoleId().toString());
        response.put("token", token);
        response.put("userId", user.getId().toString());
        
        return ResponseEntity.ok(response);
    }

    /**
     * Validate JWT token endpoint
     * This endpoint is used by the frontend to validate if the current token is still valid
     *
     * @return validation response
     */
    @GetMapping("/validate")
    public ResponseEntity<Map<String, Object>> validateToken() {
        log.info("Token validation endpoint called");
        try {
            // If we reach this point, the JWT filter has already validated the token
            // and set up the security context
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            log.info("Authentication object: {}", authentication != null ? authentication.getName() : "null");

            if (authentication == null || !authentication.isAuthenticated()) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("valid", false, "message", "Token is not valid"));
            }

            // Get user details from the authentication
            Object principal = authentication.getPrincipal();
            String username = null;

            if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
                username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
            } else {
                username = principal.toString();
            }

            log.info("Token validation successful for user: {}", username);

            Map<String, Object> response = new HashMap<>();
            response.put("valid", true);
            response.put("message", "Token is valid");
            response.put("username", username);
            response.put("authorities", authentication.getAuthorities().stream()
                .map(auth -> auth.getAuthority())
                .toArray());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Token validation error: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(Map.of("valid", false, "message", "Token validation failed: " + e.getMessage()));
        }
    }

    @PostMapping("/change-password")
    public ResponseEntity<String> changePassword(@RequestBody Map<String, String> request) {
        // Lấy thông tin người dùng đã xác thực từ Security Context
        Object principal = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        String username;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        
        if (username == null) {
             return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("User not authenticated");
        }

        String oldPassword = request.get("oldPassword");
        String newPassword = request.get("newPassword");
        
        // Basic validation
        if (oldPassword == null || newPassword == null || oldPassword.isEmpty() || newPassword.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Mật khẩu cũ và mật khẩu mới không được để trống");
        }
        
        if (oldPassword.equals(newPassword)) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Mật khẩu mới không được trùng với mật khẩu cũ");
        }
        
        if (newPassword.length() > 50) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Mật khẩu mới không được vượt quá 50 ký tự");
        }
        
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));
        
        // Verify old password
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Mật khẩu cũ không chính xác");
        }
        
        // Update password
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
        
        return ResponseEntity.ok("Đổi mật khẩu thành công");
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/BlogController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.BlogDto;
import com.classroomapp.classroombackend.dto.CreateBlogDto;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.BlogService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/blogs")
public class BlogController {

    private final BlogService blogService;
    private final UserRepository userRepository;


    @Autowired
    public BlogController(BlogService blogService, UserRepository userRepository) {
        this.blogService = blogService;
        this.userRepository = userRepository;
    }

    @PostMapping
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    public ResponseEntity<BlogDto> createBlog(
            @Valid @RequestBody CreateBlogDto createBlogDto,
            Authentication authentication) {
        
        Long userId = getUserIdFromAuthentication(authentication);
        BlogDto createdBlog = blogService.createBlog(createBlogDto, userId);
        return new ResponseEntity<>(createdBlog, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<BlogDto> getBlogById(@PathVariable Long id) {
        BlogDto blog = blogService.getBlogById(id);
        return ResponseEntity.ok(blog);
    }

    @GetMapping
    public ResponseEntity<List<BlogDto>> getAllBlogs() {
        List<BlogDto> blogs = blogService.getAllBlogs();
        return ResponseEntity.ok(blogs);
    }

    @GetMapping("/published")
    public ResponseEntity<List<BlogDto>> getPublishedBlogs() {
        List<BlogDto> blogs = blogService.getPublishedBlogs();
        return ResponseEntity.ok(blogs);
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<BlogDto> getBlogBySlug(@PathVariable String slug) {
        BlogDto blog = blogService.getBlogBySlug(slug);
        return ResponseEntity.ok(blog);
    }

    @GetMapping("/author/{authorId}")
    public ResponseEntity<List<BlogDto>> getBlogsByAuthor(@PathVariable Long authorId) {
        List<BlogDto> blogs = blogService.getBlogsByAuthor(authorId);
        return ResponseEntity.ok(blogs);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN') or @blogPermissionEvaluator.isAuthor(#id, authentication.principal)")
    public ResponseEntity<BlogDto> updateBlog(
            @PathVariable Long id,
            @Valid @RequestBody CreateBlogDto updateBlogDto,
            Authentication authentication) {
        
        Long userId = getUserIdFromAuthentication(authentication);
        BlogDto updatedBlog = blogService.updateBlog(id, updateBlogDto, userId);
        return ResponseEntity.ok(updatedBlog);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('MANAGER') or @blogPermissionEvaluator.isAuthor(#id, authentication.principal)")
    public ResponseEntity<Void> deleteBlog(@PathVariable Long id) {
        blogService.deleteBlog(id);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{id}/publish")
    @PreAuthorize("hasRole('MANAGER') or @blogPermissionEvaluator.isAuthor(#id, authentication.principal)")
    public ResponseEntity<BlogDto> publishBlog(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long userId = getUserIdFromAuthentication(authentication);
        BlogDto publishedBlog = blogService.publishBlog(id, userId);
        return ResponseEntity.ok(publishedBlog);
    }

    @PutMapping("/{id}/unpublish")
    @PreAuthorize("hasRole('MANAGER') or @blogPermissionEvaluator.isAuthor(#id, authentication.principal)")
    public ResponseEntity<BlogDto> unpublishBlog(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long userId = getUserIdFromAuthentication(authentication);
        BlogDto unpublishedBlog = blogService.unpublishBlog(id, userId);
        return ResponseEntity.ok(unpublishedBlog);
    }

    @GetMapping("/search")
    public ResponseEntity<List<BlogDto>> searchBlogs(@RequestParam String keyword) {
        try {
            // Log the received search keyword
            System.out.println("Received search request with keyword: " + keyword);
            
            // Sanitize input - prevent potential injection or bad requests
            if (keyword == null || keyword.isEmpty()) {
                // Return published blogs if no keyword provided
                return ResponseEntity.ok(blogService.getPublishedBlogs());
            }
            
            List<BlogDto> blogs = blogService.searchBlogs(keyword);
            System.out.println("Search completed, returning " + blogs.size() + " results");
            return ResponseEntity.ok(blogs);
        } catch (Exception e) {
            // Log the error with more details
            System.err.println("Error in /search endpoint for keyword '" + keyword + "': " + e.getMessage());
            e.printStackTrace();
            
            // Return empty list instead of error
            return ResponseEntity.ok(List.of());
        }
    }

    @GetMapping("/tag/{tag}")
    public ResponseEntity<List<BlogDto>> getBlogsByTag(@PathVariable String tag) {
        List<BlogDto> blogs = blogService.getBlogsByTag(tag);
        return ResponseEntity.ok(blogs);
    }
    
    // Helper method to extract user ID from Authentication
    private Long getUserIdFromAuthentication(Authentication authentication) {
        if (authentication == null || !(authentication.getPrincipal() instanceof UserDetails)) {
            // Or throw an exception if authentication is required
            throw new RuntimeException("User is not authenticated or user details are not available.");
        }

        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        String username = userDetails.getUsername(); // This is typically the email

        // Find the user by email (username) and return their ID
        return userRepository.findByEmail(username)
                .map(User::getId)
                .orElseThrow(() -> new RuntimeException("Authenticated user not found in database: " + username));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/ClassroomController.java">
package com.classroomapp.classroombackend.controller;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CreateClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.EnrollmentRequestDto;
import com.classroomapp.classroombackend.dto.classroommanagement.UpdateClassroomDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamDto;
import com.classroomapp.classroombackend.service.ClassroomService;
import com.classroomapp.classroombackend.service.ExamService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/api/classrooms")
@RequiredArgsConstructor
@Slf4j
public class ClassroomController {

    private final ClassroomService classroomService;
    private final ExamService examService;

    // Add endpoint to get all classrooms (centralized from FrontendApiBridgeController)
    @GetMapping
    public ResponseEntity<List<ClassroomDto>> getAllClassrooms() {
        log.info("🔍 ClassroomController.getAllClassrooms called");
        try {
            List<ClassroomDto> classrooms = classroomService.getAllClassrooms();
            log.info("✅ Successfully retrieved {} classrooms", classrooms.size());
            return ResponseEntity.ok(classrooms);
        } catch (Exception e) {
            log.error("❌ Error retrieving all classrooms: {}", e.getMessage(), e);
            throw e;
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<ClassroomDto> GetClassroomById(@PathVariable Long id) {
        return ResponseEntity.ok(classroomService.GetClassroomById(id));
    }
    
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<ClassroomDetailsDto> CreateClassroom(
            @Valid @RequestBody CreateClassroomDto createClassroomDto) {
        return new ResponseEntity<>(classroomService.createClassroom(createClassroomDto), HttpStatus.CREATED);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'TEACHER')")
    public ResponseEntity<ClassroomDto> UpdateClassroom(
            @PathVariable Long id,
            @Valid @RequestBody UpdateClassroomDto updateClassroomDto,
            @AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(classroomService.UpdateClassroom(id, updateClassroomDto, userDetails));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> DeleteClassroom(@PathVariable Long id) {
        classroomService.DeleteClassroom(id);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/teacher/{teacherId}")
    public ResponseEntity<List<ClassroomDto>> GetClassroomsByTeacher(@PathVariable Long teacherId) {
        return ResponseEntity.ok(classroomService.GetClassroomsByTeacher(teacherId));
    }
    
    @GetMapping("/current-teacher")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<ClassroomDto>> GetClassroomsByCurrentTeacher() {
        log.info("🔍 ClassroomController.GetClassroomsByCurrentTeacher called");
        try {
            List<ClassroomDto> classrooms = classroomService.GetClassroomsByCurrentTeacher();
            log.info("✅ Successfully retrieved {} classrooms for current teacher", classrooms.size());
            return ResponseEntity.ok(classrooms);
        } catch (Exception e) {
            log.error("❌ Error retrieving classrooms for current teacher: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    @GetMapping("/current-student")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<ClassroomDto>> GetClassroomsByCurrentStudent() {
        log.info("🔍 ClassroomController.GetClassroomsByCurrentStudent called");
        try {
            List<ClassroomDto> classrooms = classroomService.getClassroomsByCurrentStudent();
            log.info("✅ Successfully retrieved {} classrooms for current student", classrooms.size());
            return ResponseEntity.ok(classrooms);
        } catch (Exception e) {
            log.error("❌ Error retrieving classrooms for current student: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    @GetMapping("/student/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<ClassroomDto>> GetMyStudentCourses() {
        return ResponseEntity.ok(classroomService.getClassroomsByCurrentStudent());
    }
    
    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<ClassroomDto>> GetClassroomsByStudent(@PathVariable Long studentId) {
        return ResponseEntity.ok(classroomService.GetClassroomsByStudent(studentId));
    }
    
    @PostMapping("/{classroomId}/enrollments")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'TEACHER')")
    public ResponseEntity<Void> enrollStudent(@PathVariable Long classroomId, @Valid @RequestBody EnrollmentRequestDto enrollmentRequest) {
        classroomService.EnrollStudent(classroomId, enrollmentRequest.getStudentId());
        return ResponseEntity.ok().build();
    }
    
    @DeleteMapping("/{classroomId}/students/{studentId}")
    public ResponseEntity<Void> UnenrollStudent(
            @PathVariable Long classroomId,
            @PathVariable Long studentId) {
        classroomService.UnenrollStudent(classroomId, studentId);
        return ResponseEntity.ok().build();
    }
    
    @GetMapping("/search")
    public ResponseEntity<List<ClassroomDto>> SearchClassrooms(@RequestParam String name) {
        return ResponseEntity.ok(classroomService.SearchClassroomsByName(name));
    }
    
    @GetMapping("/subject/{subject}")
    public ResponseEntity<List<ClassroomDto>> GetClassroomsBySubject(@PathVariable String subject) {
        return ResponseEntity.ok(classroomService.GetClassroomsBySubject(subject));
    }
    
    @GetMapping("/{id}/details")
    public ResponseEntity<CourseDetailsDto> GetCourseDetails(@PathVariable Long id) {
        return ResponseEntity.ok(classroomService.GetCourseDetails(id));
    }
    
    /**
     * Get students in a classroom
     * @param classroomId classroom ID
     * @return list of students in the classroom
     */
    @GetMapping("/{classroomId}/students")
    public ResponseEntity<List<UserDto>> GetClassroomStudents(@PathVariable Long classroomId) {
        List<UserDto> students = classroomService.getStudentsInClassroom(classroomId).stream()
                .map(user -> {
                    UserDto dto = new UserDto();
                    dto.setId(user.getId());
                    dto.setName(user.getFullName());
                    dto.setEmail(user.getEmail());
                    dto.setEnabled("active".equalsIgnoreCase(user.getStatus()));
                    dto.setRoles(Collections.singleton(user.getRole()));
                    return dto;
                }).collect(Collectors.toList());
        return ResponseEntity.ok(students);
    }

    @GetMapping("/{classroomId}/exams")
    // @PreAuthorize("hasAnyAuthority('STUDENT', 'MANAGER', 'ADMIN')")
    public ResponseEntity<List<ExamDto>> getExamsByClassroomId(@PathVariable Long classroomId) {
        System.out.println("=== DEBUG: Getting exams for classroom " + classroomId + " ===");
        try {
            List<ExamDto> exams = examService.getExamsByClassroomId(classroomId);
            System.out.println("=== DEBUG: Found " + exams.size() + " exams ===");
            return ResponseEntity.ok(exams);
        } catch (Exception e) {
            System.out.println("=== DEBUG: Error getting exams: " + e.getMessage() + " ===");
            throw e;
        }
    }
    
    @GetMapping("/{classroomId}/exams/debug")
    public ResponseEntity<String> debugExams(@PathVariable Long classroomId) {
        try {
            List<ExamDto> exams = examService.getExamsByClassroomId(classroomId);
            return ResponseEntity.ok("Found " + exams.size() + " exams for classroom " + classroomId);
        } catch (Exception e) {
            return ResponseEntity.ok("Error: " + e.getMessage());
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/CourseController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;
import com.classroomapp.classroombackend.service.CourseService;
import com.classroomapp.classroombackend.service.LectureService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/courses")
@RequiredArgsConstructor
@CrossOrigin(origins = "http://localhost:3000")
public class CourseController {

    private final CourseService courseService;
    private final LectureService lectureService;

    @GetMapping
    public ResponseEntity<List<CourseDetailsDto>> getAllCourses() {
        return ResponseEntity.ok(courseService.getAllCourses());
    }

    // Compatibility endpoint: fetch lectures by course (classroom) ID
    // Delegates to LectureService which already supports fetching by classroomId
    @GetMapping("/{courseId}/lectures")
    public ResponseEntity<List<LectureDto>> getLecturesByCourse(@PathVariable Long courseId) {
        return ResponseEntity.ok(lectureService.getLecturesByClassroomId(courseId));
    }

    // NOTE: All other mock-data-based endpoints are removed.
    // They should be re-implemented properly using the service and repository layers
    // if their functionality is still required.
    // (createLecture, updateLecture, deleteLecture, getLecturesByCourse, etc.)
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/CourseFeedbackController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.CourseFeedbackDto;
import com.classroomapp.classroombackend.service.CourseFeedbackService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/feedback")
@CrossOrigin(origins = "http://localhost:3000")
public class CourseFeedbackController {
    
    @Autowired
    private CourseFeedbackService feedbackService;
    
    // Create new feedback
    @PostMapping
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<CourseFeedbackDto> createFeedback(@Valid @RequestBody CourseFeedbackDto feedbackDto) {
        try {
            CourseFeedbackDto createdFeedback = feedbackService.createFeedback(feedbackDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdFeedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }
    
    // Get feedback by ID
    @GetMapping("/{feedbackId}")
    public ResponseEntity<CourseFeedbackDto> getFeedbackById(@PathVariable Long feedbackId) {
        try {
            CourseFeedbackDto feedback = feedbackService.getFeedbackById(feedbackId);
            return ResponseEntity.ok(feedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get all feedback by student
    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByStudent(@PathVariable Long studentId) {
        try {
            List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByStudent(studentId);
            return ResponseEntity.ok(feedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get all feedback for a classroom
    @GetMapping("/classroom/{classroomId}")
    @PreAuthorize("hasAnyRole('TEACHER', 'MANAGER')")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByClassroom(@PathVariable Long classroomId) {
        try {
            List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByClassroom(classroomId);
            return ResponseEntity.ok(feedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get all feedback for a teacher
    @GetMapping("/teacher/{teacherId}")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByTeacher(@PathVariable Long teacherId) {
        try {
            List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByTeacher(teacherId);
            return ResponseEntity.ok(feedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get feedback by status
    @GetMapping("/status/{status}")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByStatus(@PathVariable String status) {
        List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByStatus(status);
        return ResponseEntity.ok(feedback);
    }
    
    // Get feedback by category
    @GetMapping("/category/{category}")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByCategory(@PathVariable String category) {
        List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByCategory(category);
        return ResponseEntity.ok(feedback);
    }
    
    // Get feedback by rating range
    @GetMapping("/rating")
    public ResponseEntity<List<CourseFeedbackDto>> getFeedbackByRatingRange(
            @RequestParam Integer minRating, 
            @RequestParam Integer maxRating) {
        List<CourseFeedbackDto> feedback = feedbackService.getFeedbackByRatingRange(minRating, maxRating);
        return ResponseEntity.ok(feedback);
    }
    
    // Search feedback
    @GetMapping("/search")
    public ResponseEntity<List<CourseFeedbackDto>> searchFeedback(@RequestParam String keyword) {
        List<CourseFeedbackDto> feedback = feedbackService.searchFeedback(keyword);
        return ResponseEntity.ok(feedback);
    }
    
    // Get recent feedback
    @GetMapping("/recent")
    public ResponseEntity<List<CourseFeedbackDto>> getRecentFeedback(@RequestParam(defaultValue = "30") Integer days) {
        List<CourseFeedbackDto> feedback = feedbackService.getRecentFeedback(days);
        return ResponseEntity.ok(feedback);
    }
    
    // Get anonymous feedback
    @GetMapping("/anonymous")
    public ResponseEntity<List<CourseFeedbackDto>> getAnonymousFeedback() {
        List<CourseFeedbackDto> feedback = feedbackService.getAnonymousFeedback();
        return ResponseEntity.ok(feedback);
    }
    
    // Review feedback (by teacher or admin)
    @PutMapping("/{feedbackId}/review")
    public ResponseEntity<CourseFeedbackDto> reviewFeedback(
            @PathVariable Long feedbackId,
            @RequestParam String response,
            @RequestParam Long reviewerId) {
        try {
            CourseFeedbackDto reviewedFeedback = feedbackService.reviewFeedback(feedbackId, response, reviewerId);
            return ResponseEntity.ok(reviewedFeedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Acknowledge feedback
    @PutMapping("/{feedbackId}/acknowledge")
    public ResponseEntity<CourseFeedbackDto> acknowledgeFeedback(@PathVariable Long feedbackId) {
        try {
            CourseFeedbackDto acknowledgedFeedback = feedbackService.acknowledgeFeedback(feedbackId);
            return ResponseEntity.ok(acknowledgedFeedback);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Check if student already gave feedback for classroom
    @GetMapping("/check/{studentId}/{classroomId}")
    public ResponseEntity<Boolean> hasStudentGivenFeedback(
            @PathVariable Long studentId, 
            @PathVariable Long classroomId) {
        boolean hasFeedback = feedbackService.hasStudentGivenFeedback(studentId, classroomId);
        return ResponseEntity.ok(hasFeedback);
    }
    
    // Get average rating for classroom
    @GetMapping("/classroom/{classroomId}/average-rating")
    public ResponseEntity<Double> getAverageRatingByClassroom(@PathVariable Long classroomId) {
        Double averageRating = feedbackService.getAverageRatingByClassroom(classroomId);
        return ResponseEntity.ok(averageRating);
    }
    
    // Get average teaching quality for teacher
    @GetMapping("/teacher/{teacherId}/average-teaching-quality")
    public ResponseEntity<Double> getAverageTeachingQualityByTeacher(@PathVariable Long teacherId) {
        Double averageQuality = feedbackService.getAverageTeachingQualityByTeacher(teacherId);
        return ResponseEntity.ok(averageQuality);
    }
    
    // Count feedback by status for teacher
    @GetMapping("/teacher/{teacherId}/count/{status}")
    public ResponseEntity<Long> countFeedbackByTeacherAndStatus(
            @PathVariable Long teacherId, 
            @PathVariable String status) {
        Long count = feedbackService.countFeedbackByTeacherAndStatus(teacherId, status);
        return ResponseEntity.ok(count);
    }
    
    // Delete feedback
    @DeleteMapping("/{feedbackId}")
    public ResponseEntity<Void> deleteFeedback(@PathVariable Long feedbackId) {
        try {
            feedbackService.deleteFeedback(feedbackId);
            return ResponseEntity.noContent().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get all feedback (admin only)
    @GetMapping("/all")
    public ResponseEntity<List<CourseFeedbackDto>> getAllFeedback() {
        List<CourseFeedbackDto> feedback = feedbackService.getAllFeedback();
        return ResponseEntity.ok(feedback);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/CourseMaterialController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.CourseMaterialDto;
import com.classroomapp.classroombackend.dto.UploadMaterialDto;
import com.classroomapp.classroombackend.service.CourseMaterialService;

@RestController
@RequestMapping("/api/materials")
@CrossOrigin(origins = "*")
public class CourseMaterialController {

    @Autowired
    private CourseMaterialService courseMaterialService;

    /**
     * Upload a new course material
     */
    @PostMapping("/upload")
    public ResponseEntity<CourseMaterialDto> uploadMaterial(
            @RequestParam("file") MultipartFile file,
            @RequestParam("title") String title,
            @RequestParam("description") String description,
            @RequestParam("classroomId") Long classroomId,
            @RequestParam(value = "isPublic", defaultValue = "true") Boolean isPublic,
            @RequestParam("uploadedBy") Long uploadedBy) {
        try {
            UploadMaterialDto uploadDto = new UploadMaterialDto();
            uploadDto.setTitle(title);
            uploadDto.setDescription(description);
            uploadDto.setClassroomId(classroomId);
            uploadDto.setIsPublic(isPublic);

            CourseMaterialDto material = courseMaterialService.uploadMaterial(uploadDto, file, uploadedBy);
            return ResponseEntity.ok(material);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Get all materials for a classroom
     */
    @GetMapping("/classroom/{classroomId}")
    public ResponseEntity<List<CourseMaterialDto>> getMaterialsByClassroom(@PathVariable Long classroomId) {
        try {
            List<CourseMaterialDto> materials = courseMaterialService.getMaterialsByClassroom(classroomId);
            return ResponseEntity.ok(materials);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Get materials by course ID (alias for classroom ID)
     * Added to match frontend API expectation
     */
    @GetMapping("/course/{courseId}")
    public ResponseEntity<List<CourseMaterialDto>> getMaterialsByCourse(@PathVariable Long courseId) {
        try {
            // Course ID is equivalent to classroom ID in this context
            List<CourseMaterialDto> materials = courseMaterialService.getMaterialsByClassroom(courseId);
            return ResponseEntity.ok(materials);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Get public materials for a classroom
     */
    @GetMapping("/classroom/{classroomId}/public")
    public ResponseEntity<List<CourseMaterialDto>> getPublicMaterialsByClassroom(@PathVariable Long classroomId) {
        try {
            List<CourseMaterialDto> materials = courseMaterialService.getPublicMaterialsByClassroom(classroomId);
            return ResponseEntity.ok(materials);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Download a material file
     */
    @GetMapping("/download/{materialId}")
    public ResponseEntity<Resource> downloadMaterial(@PathVariable Long materialId) {
        try {
            CourseMaterialDto material = courseMaterialService.getMaterialById(materialId);
            byte[] fileContent = courseMaterialService.downloadMaterial(materialId);
            
            ByteArrayResource resource = new ByteArrayResource(fileContent);
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(material.getFileType()))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + material.getFileName() + "\"")
                    .body(resource);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    /**
     * Delete a material
     */
    @DeleteMapping("/{materialId}")
    public ResponseEntity<Void> deleteMaterial(@PathVariable Long materialId) {
        try {
            courseMaterialService.deleteMaterial(materialId);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Search materials
     */
    @GetMapping("/search")
    public ResponseEntity<List<CourseMaterialDto>> searchMaterials(
            @RequestParam Long classroomId,
            @RequestParam String searchTerm) {
        try {
            List<CourseMaterialDto> materials = courseMaterialService.searchMaterials(classroomId, searchTerm);
            return ResponseEntity.ok(materials);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Get materials by file type
     */
    @GetMapping("/classroom/{classroomId}/type/{fileType}")
    public ResponseEntity<List<CourseMaterialDto>> getMaterialsByFileType(
            @PathVariable Long classroomId, 
            @PathVariable String fileType) {
        try {
            List<CourseMaterialDto> materials = courseMaterialService.getMaterialsByFileType(classroomId, fileType);
            return ResponseEntity.ok(materials);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Get total downloads for a classroom
     */
    @GetMapping("/classroom/{classroomId}/downloads/total")
    public ResponseEntity<Long> getTotalDownloads(@PathVariable Long classroomId) {
        try {
            Long totalDownloads = courseMaterialService.getTotalDownloadsByClassroom(classroomId);
            return ResponseEntity.ok(totalDownloads);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/DatabaseHealthController.java">
package com.classroomapp.classroombackend.controller;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/health")
public class DatabaseHealthController {

    @Autowired
    private DataSource dataSource;

    @GetMapping("/database")
    public ResponseEntity<Map<String, Object>> checkDatabaseHealth() {
        Map<String, Object> response = new HashMap<>();
        
        try (Connection connection = dataSource.getConnection()) {
            DatabaseMetaData metaData = connection.getMetaData();
            
            response.put("status", "SUCCESS");
            response.put("connected", true);
            response.put("databaseProductName", metaData.getDatabaseProductName());
            response.put("databaseProductVersion", metaData.getDatabaseProductVersion());
            response.put("driverName", metaData.getDriverName());
            response.put("driverVersion", metaData.getDriverVersion());
            response.put("url", metaData.getURL());
            response.put("username", metaData.getUserName());
            
            // Test a simple query
            boolean queryResult = connection.createStatement()
                .execute("SELECT 1 as test_connection");
            response.put("queryTest", queryResult ? "SUCCESS" : "FAILED");
            
        } catch (SQLException e) {
            response.put("status", "ERROR");
            response.put("connected", false);
            response.put("error", e.getMessage());
            response.put("sqlState", e.getSQLState());
            response.put("errorCode", e.getErrorCode());
        }
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/tables")
    public ResponseEntity<Map<String, Object>> checkTables() {
        Map<String, Object> response = new HashMap<>();
        
        try (Connection connection = dataSource.getConnection()) {
            DatabaseMetaData metaData = connection.getMetaData();
            
            // Check for some key tables
            String[] tableNames = {"users", "classrooms", "schedules", "announcements"};
            Map<String, Boolean> tableStatus = new HashMap<>();
            
            for (String tableName : tableNames) {
                try (var rs = metaData.getTables(null, null, tableName, new String[]{"TABLE"})) {
                    tableStatus.put(tableName, rs.next());
                }
            }
            
            response.put("status", "SUCCESS");
            response.put("tables", tableStatus);
            
        } catch (SQLException e) {
            response.put("status", "ERROR");
            response.put("error", e.getMessage());
        }
        
        return ResponseEntity.ok(response);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/DebugController.java">
package com.classroomapp.classroombackend.controller;

import java.time.LocalTime;
import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.ScheduleRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/debug")
@RequiredArgsConstructor
public class DebugController {

    private final UserRepository userRepository;
    private final ScheduleRepository scheduleRepository;
    private final ClassroomRepository classroomRepository;

    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers() {
        List<User> users = userRepository.findAll();
        return ResponseEntity.ok(users.stream().map(user ->
            "ID: " + user.getId() + ", Username: " + user.getUsername() +
            ", Role: " + user.getRoleId() + ", Name: " + user.getFullName()
        ).toList());
    }

    @GetMapping("/database-state")
    public ResponseEntity<?> getDatabaseState() {
        // Get all users
        List<User> allUsers = userRepository.findAll();

        // Get all schedules
        List<Schedule> allSchedules = scheduleRepository.findAll();

        // Group schedules by teacher ID
        java.util.Map<Long, List<Schedule>> schedulesByTeacher = allSchedules.stream()
            .collect(java.util.stream.Collectors.groupingBy(s -> s.getTeacher().getId()));

        // Find teacher specifically
        User teacher = userRepository.findByUsername("teacher").orElse(null);

        java.util.Map<String, Object> result = new java.util.HashMap<>();
        result.put("totalUsers", allUsers.size());
        result.put("totalSchedules", allSchedules.size());

        result.put("users", allUsers.stream().map(user ->
            java.util.Map.of(
                "id", user.getId(),
                "username", user.getUsername(),
                "name", user.getFullName(),
                "role", user.getRoleId()
            )
        ).toList());

        result.put("schedulesByTeacher", schedulesByTeacher.entrySet().stream()
            .collect(java.util.stream.Collectors.toMap(
                entry -> "Teacher_" + entry.getKey(),
                entry -> entry.getValue().size()
            )));

        if (teacher != null) {
            List<Schedule> teacherSchedules = scheduleRepository.findByTeacherId(teacher.getId());
            result.put("mainTeacher", java.util.Map.of(
                "id", teacher.getId(),
                "username", teacher.getUsername(),
                "name", teacher.getFullName(),
                "scheduleCount", teacherSchedules.size()
            ));
        } else {
            result.put("mainTeacher", "NOT FOUND");
        }

        return ResponseEntity.ok(result);
    }

    @GetMapping("/teacher")
    public ResponseEntity<?> getTeacher() {
        User teacher = userRepository.findByUsername("teacher").orElse(null);
        if (teacher == null) {
            return ResponseEntity.ok("Teacher not found");
        }

        List<Schedule> schedules = scheduleRepository.findByTeacherId(teacher.getId());

        return ResponseEntity.ok(java.util.Map.of(
            "teacher", "ID: " + teacher.getId() + ", Name: " + teacher.getFullName(),
            "scheduleCount", schedules.size(),
            "schedules", schedules.stream().map(s ->
                getDayName(s.getDayOfWeek()) + " " + s.getStartTime() + "-" + s.getEndTime() +
                " | " + s.getSubject() + " | Room: " + s.getRoom()
            ).toList()
        ));
    }

    @GetMapping("/test-schedule-api")
    public ResponseEntity<?> testScheduleApi() {
        User teacher = userRepository.findByUsername("teacher").orElse(null);
        if (teacher == null) {
            return ResponseEntity.badRequest().body("Teacher not found");
        }

        // Test the same logic as the ScheduleController
        java.time.LocalDate startDate = java.time.LocalDate.of(2025, 7, 1);
        java.time.LocalDate endDate = java.time.LocalDate.of(2025, 7, 31);

        List<Schedule> schedules = scheduleRepository.findByTeacherId(teacher.getId());

        return ResponseEntity.ok(java.util.Map.of(
            "teacherId", teacher.getId(),
            "teacherName", teacher.getFullName(),
            "dateRange", startDate + " to " + endDate,
            "totalSchedules", schedules.size(),
            "message", schedules.isEmpty() ?
                "❌ NO SCHEDULES FOUND - This is the problem!" :
                "✅ Schedules found - API should work",
            "sampleSchedules", schedules.stream().limit(5).map(s ->
                java.util.Map.of(
                    "day", getDayName(s.getDayOfWeek()),
                    "time", s.getStartTime() + "-" + s.getEndTime(),
                    "subject", s.getSubject(),
                    "room", s.getRoom()
                )
            ).toList()
        ));
    }

    @GetMapping("/force-create-schedules")
    public ResponseEntity<?> forceCreateSchedulesForTeacher() {
        return createSchedulesForTeacher();
    }

    @PostMapping("/create-schedules")
    public ResponseEntity<?> createSchedulesForTeacher() {
        User teacher = userRepository.findByUsername("teacher").orElse(null);
        if (teacher == null) {
            return ResponseEntity.badRequest().body("Teacher not found");
        }

        List<Classroom> classrooms = classroomRepository.findAll();
        if (classrooms.isEmpty()) {
            return ResponseEntity.badRequest().body("No classrooms found");
        }

        // Clear existing schedules for this teacher
        List<Schedule> existingSchedules = scheduleRepository.findByTeacherId(teacher.getId());
        if (!existingSchedules.isEmpty()) {
            scheduleRepository.deleteAll(existingSchedules);
        }

        int scheduleCount = 0;

        // Create comprehensive weekly schedule for the teacher
        // Monday schedules
        Schedule mondayMorning = createSchedule(teacher, classrooms.get(0), 0, 
            LocalTime.of(8, 0), LocalTime.of(9, 30), "Room 101", "Java Programming - Fundamentals");
        scheduleRepository.save(mondayMorning);
        scheduleCount++;

        Schedule mondayAfternoon = createSchedule(teacher, classrooms.get(Math.min(1, classrooms.size()-1)), 0, 
            LocalTime.of(14, 0), LocalTime.of(15, 30), "Room 102", "Database Design - Theory");
        scheduleRepository.save(mondayAfternoon);
        scheduleCount++;

        // Tuesday schedules
        Schedule tuesdayMorning = createSchedule(teacher, classrooms.get(0), 1, 
            LocalTime.of(9, 0), LocalTime.of(10, 30), "Lab 201", "Java Programming - Practice");
        scheduleRepository.save(tuesdayMorning);
        scheduleCount++;

        Schedule tuesdayEvening = createSchedule(teacher, classrooms.get(Math.min(2, classrooms.size()-1)), 1, 
            LocalTime.of(18, 0), LocalTime.of(19, 30), "Online", "Evening Tutorial Session");
        scheduleRepository.save(tuesdayEvening);
        scheduleCount++;

        // Wednesday schedules
        Schedule wednesdayMorning = createSchedule(teacher, classrooms.get(Math.min(1, classrooms.size()-1)), 2, 
            LocalTime.of(8, 0), LocalTime.of(9, 30), "Room 102", "Database Design - Practice");
        scheduleRepository.save(wednesdayMorning);
        scheduleCount++;

        Schedule wednesdayAfternoon = createSchedule(teacher, classrooms.get(0), 2, 
            LocalTime.of(15, 0), LocalTime.of(16, 30), "Room 101", "Advanced Java Topics");
        scheduleRepository.save(wednesdayAfternoon);
        scheduleCount++;

        // Thursday schedules
        Schedule thursdayMorning = createSchedule(teacher, classrooms.get(Math.min(2, classrooms.size()-1)), 3, 
            LocalTime.of(10, 0), LocalTime.of(11, 30), "Room 103", "Software Engineering");
        scheduleRepository.save(thursdayMorning);
        scheduleCount++;

        // Friday schedules
        Schedule fridayMorning = createSchedule(teacher, classrooms.get(0), 4, 
            LocalTime.of(8, 0), LocalTime.of(9, 30), "Room 101", "Java Programming - Review");
        scheduleRepository.save(fridayMorning);
        scheduleCount++;

        Schedule fridayAfternoon = createSchedule(teacher, classrooms.get(Math.min(1, classrooms.size()-1)), 4, 
            LocalTime.of(13, 0), LocalTime.of(14, 30), "Lab 202", "Database Lab Session");
        scheduleRepository.save(fridayAfternoon);
        scheduleCount++;

        // Saturday workshop
        Schedule saturdayWorkshop = createSchedule(teacher, classrooms.get(0), 5, 
            LocalTime.of(10, 0), LocalTime.of(12, 0), "Workshop Hall", "Weekend Java Workshop");
        scheduleRepository.save(saturdayWorkshop);
        scheduleCount++;

        return ResponseEntity.ok(java.util.Map.of(
            "message", "Created " + scheduleCount + " schedules for teacher ID " + teacher.getId(),
            "teacherId", teacher.getId(),
            "teacherName", teacher.getFullName(),
            "schedulesCreated", scheduleCount
        ));
    }

    private Schedule createSchedule(User teacher, Classroom classroom, int dayOfWeek, 
                                  LocalTime startTime, LocalTime endTime, 
                                  String room, String subject) {
        Schedule schedule = new Schedule();
        schedule.setTeacher(teacher);
        schedule.setClassroom(classroom);
        schedule.setDayOfWeek(dayOfWeek);
        schedule.setStartTime(startTime);
        schedule.setEndTime(endTime);
        schedule.setRoom(room);
        schedule.setSubject(subject);
        schedule.setMaterialsUrl("https://drive.google.com/folder/" + classroom.getName().toLowerCase().replace(" ", "-"));
        schedule.setMeetUrl("https://meet.google.com/" + classroom.getName().toLowerCase().replace(" ", "-"));
        return schedule;
    }

    private String getDayName(int dayOfWeek) {
        String[] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        return days[dayOfWeek];
    }

    /**
     * Debug endpoint to check user role assignments
     */
    @GetMapping("/check-user-roles")
    public ResponseEntity<String> checkUserRoles() {
        StringBuilder result = new StringBuilder();

        // Check student user
        User student = userRepository.findByEmail("student@test.com").orElse(null);
        if (student != null) {
            result.append("Student User: ID=").append(student.getId())
                  .append(", Email=").append(student.getEmail())
                  .append(", Role=").append(student.getRole())
                  .append(", RoleId=").append(student.getRoleId()).append("\n");
        } else {
            result.append("Student user not found!\n");
        }

        // Check teacher user
        User teacher = userRepository.findByEmail("teacher@test.com").orElse(null);
        if (teacher != null) {
            result.append("Teacher User: ID=").append(teacher.getId())
                  .append(", Email=").append(teacher.getEmail())
                  .append(", Role=").append(teacher.getRole())
                  .append(", RoleId=").append(teacher.getRoleId()).append("\n");
        } else {
            result.append("Teacher user not found!\n");
        }

        // Check classrooms
        List<Classroom> classrooms = classroomRepository.findAll();
        result.append("Found ").append(classrooms.size()).append(" classrooms:\n");
        for (Classroom classroom : classrooms) {
            User classroomTeacher = classroom.getTeacher();
            result.append("- Classroom: ").append(classroom.getName())
                  .append(" (ID=").append(classroom.getId()).append(")")
                  .append(", Teacher: ").append(classroomTeacher != null ? classroomTeacher.getFullName() : "NULL")
                  .append(" (ID=").append(classroomTeacher != null ? classroomTeacher.getId() : "NULL")
                  .append(")\n");
        }

        return ResponseEntity.ok(result.toString());
    }

    /**
     * Force re-seed lectures for debugging
     */
    @PostMapping("/force-seed-lectures")
    public ResponseEntity<String> forceSeedLectures() {
        try {
            // This would require LectureSeeder injection, but let's keep it simple
            StringBuilder result = new StringBuilder();
            result.append("Force seed lectures endpoint called.\n");
            result.append("Check server logs for detailed seeding information.\n");
            result.append("Note: This endpoint requires backend restart to take effect.\n");

            return ResponseEntity.ok(result.toString());
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Error: " + e.getMessage());
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/EducationalRoleController.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/ExamController.java">
package com.classroomapp.classroombackend.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamDto;
import com.classroomapp.classroombackend.service.ExamService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/exams")
@RequiredArgsConstructor
public class ExamController {

    private final ExamService examService;

    @PostMapping
    @PreAuthorize("hasAnyAuthority('MANAGER', 'ADMIN') and @classroomSecurityService.isTeacher(#createExamDto.classroomId)")
    public ResponseEntity<ExamDto> createExam(@Valid @RequestBody CreateExamDto createExamDto) {
        ExamDto newExam = examService.createExam(createExamDto);
        return new ResponseEntity<>(newExam, HttpStatus.CREATED);
    }

    @GetMapping("/{examId}")
    @PreAuthorize("hasAnyAuthority('STUDENT', 'MANAGER', 'ADMIN')")
    public ResponseEntity<ExamDto> getExamById(@PathVariable Long examId) {
        // Here we should also check if the user is a member of the exam's classroom
        // This logic can be added in the service layer or with a more complex security expression
        ExamDto exam = examService.getExamById(examId);
        return ResponseEntity.ok(exam);
    }

    @PutMapping("/{examId}")
    @PreAuthorize("hasAnyAuthority('MANAGER', 'ADMIN')")
    public ResponseEntity<ExamDto> updateExam(@PathVariable Long examId, @Valid @RequestBody CreateExamDto createExamDto) {
        // Security check should ensure the user is the teacher of the classroom
        ExamDto updatedExam = examService.updateExam(examId, createExamDto);
        return ResponseEntity.ok(updatedExam);
    }

    @DeleteMapping("/{examId}")
    @PreAuthorize("hasAnyAuthority('MANAGER', 'ADMIN')")
    public ResponseEntity<Void> deleteExam(@PathVariable Long examId) {
        // Security check should ensure the user is the teacher of the classroom
        examService.deleteExam(examId);
        return ResponseEntity.noContent().build();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/ExamSubmissionController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.GradeExamDto;
import com.classroomapp.classroombackend.service.ExamSubmissionService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class ExamSubmissionController {

    private final ExamSubmissionService examSubmissionService;

    @PostMapping("/exams/{examId}/start")
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<ExamSubmissionDto> startExam(@PathVariable Long examId) {
        return ResponseEntity.ok(examSubmissionService.startExam(examId));
    }

    @PostMapping("/exam-submissions/{submissionId}")
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<ExamSubmissionDto> submitExam(@PathVariable Long submissionId, @Valid @RequestBody CreateExamSubmissionDto submissionDto) {
        // The service layer will verify that the submission belongs to the authenticated user
        return ResponseEntity.ok(examSubmissionService.submitExam(submissionId, submissionDto));
    }

    @GetMapping("/exams/{examId}/submissions")
    @PreAuthorize("hasAnyRole('TEACHER', 'ADMIN', 'MANAGER')")
    public ResponseEntity<List<ExamSubmissionDto>> getSubmissionsForExam(@PathVariable Long examId) {
        return ResponseEntity.ok(examSubmissionService.getSubmissionsForExam(examId));
    }

    @GetMapping("/exams/{examId}/submission/me")
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<ExamSubmissionDto> getMySubmissionForExam(@PathVariable Long examId) {
        return ResponseEntity.ok(examSubmissionService.getStudentSubmissionForExam(examId));
    }

    @PutMapping("/exam-submissions/{submissionId}/grade")
    @PreAuthorize("hasAnyRole('TEACHER', 'ADMIN', 'MANAGER')")
    public ResponseEntity<ExamSubmissionDto> gradeSubmission(@PathVariable Long submissionId, @Valid @RequestBody GradeExamDto gradeDto) {
        return ResponseEntity.ok(examSubmissionService.gradeSubmission(submissionId, gradeDto));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/FileDownloadController.java">
package com.classroomapp.classroombackend.controller;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/files")
public class FileDownloadController {

    private static final Logger logger = LoggerFactory.getLogger(FileDownloadController.class);

    @Value("${file.upload.dir:uploads}")
    private String uploadDir;

    @GetMapping("/download/{folder}/{filename:.+}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String folder, @PathVariable String filename) {
        try {
            Path filePath = Paths.get(uploadDir).resolve(folder).resolve(filename);
            
            if (!Files.exists(filePath)) {
                logger.warn("File not found: {}", filePath.toString());
                return ResponseEntity.notFound().build();
            }

            byte[] data = Files.readAllBytes(filePath);
            ByteArrayResource resource = new ByteArrayResource(data);

            // Try to determine content type
            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                contentType = "application/octet-stream";
            }

            // Extract original filename from UUID-prefixed filename
            String originalFilename = filename;
            if (filename.contains("_")) {
                originalFilename = filename.substring(filename.indexOf("_") + 1);
            }

            logger.info("Serving file: {} -> {}", filePath.toString(), originalFilename);

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + originalFilename + "\"")
                    .body(resource);

        } catch (IOException e) {
            logger.error("Error reading file: {}/{}", folder, filename, e);
            return ResponseEntity.internalServerError().build();
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/FileUploadController.java">
package com.classroomapp.classroombackend.controller;

import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.service.FileStorageService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/files")
@CrossOrigin(originPatterns = {"http://localhost:3000", "http://localhost:5173"}, maxAge = 3600, allowCredentials = "true")
@RequiredArgsConstructor
public class FileUploadController {

    private static final Logger logger = LoggerFactory.getLogger(FileUploadController.class);
    private final FileStorageService fileStorageService;
    
    /**
     * Handle OPTIONS preflight requests
     */
    @RequestMapping(method = RequestMethod.OPTIONS)
    public ResponseEntity<?> handleOptions() {
        return ResponseEntity.ok().build();
    }
    
    /**
     * Upload a file to the specified folder
     * 
     * @param file The file to upload
     * @param folder The folder to store the file in
     * @return The URL to access the uploaded file
     */
    @PostMapping("/upload")
    public ResponseEntity<Map<String, String>> uploadFile(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "folder", defaultValue = "uploads") String folder) {
        
        logger.info("Received file upload request: filename={}, contentType={}, size={}",
                file.getOriginalFilename(), file.getContentType(), file.getSize());
        
        try {
            FileUploadResponse response = fileStorageService.save(file, folder);
            String fileUrl = response.getFileUrl();
            
            logger.info("File uploaded successfully: {}", fileUrl);
            
            Map<String, String> responseMap = new HashMap<>();
            responseMap.put("url", fileUrl);
            
            return ResponseEntity.ok(responseMap);
        } catch (Exception e) {
            logger.error("Error uploading file: {}", e.getMessage(), e);
            
            Map<String, String> response = new HashMap<>();
            response.put("error", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/FrontendApiBridgeController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.StudentMessageDto;
import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AssignmentService;
import com.classroomapp.classroombackend.service.AttendanceService;
import com.classroomapp.classroombackend.service.ClassroomService;
import com.classroomapp.classroombackend.service.StudentMessageService;
import com.classroomapp.classroombackend.service.UserService;

import jakarta.validation.Valid;

/**
 * Frontend API Bridge Controller
 * This controller provides endpoints that match frontend expectations
 * to avoid breaking existing frontend calls while maintaining proper REST structure
 */
@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "http://localhost:3000")
public class FrontendApiBridgeController {

    @Autowired
    private ClassroomService classroomService;
    
    @Autowired
    private AssignmentService assignmentService;
    
    @Autowired
    private StudentMessageService messageService;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private AttendanceService attendanceService;
    
    @Autowired
    private UserRepository userRepository;

    /*
     * Bridge endpoint for updating current user profile
     * Frontend calls: /api/users/me (PUT)
     * This endpoint is now handled by UserController.updateCurrentUser and is removed here to prevent conflicts.
     */
    // @PutMapping("/users/me")
    // public ResponseEntity<?> updateCurrentUserProfile(@RequestBody Map<String, String> profileData) {
    //     // Mock implementation
    //     System.out.println("🌉 [Bridge] Received PUT /api/users/me with data: " + profileData);
    //     return ResponseEntity.ok(Map.of("status", "success", "message", "Profile updated via bridge."));
    // }

    /**
     * Bridge endpoint for getting all students
     * Frontend calls: /api/users/students
     * Maps to: /api/v1/users/students
     */
    @GetMapping("/users/students")
    public ResponseEntity<List<UserDto>> getAllStudents() {
        try {
            return ResponseEntity.ok(userService.FindUsersByRole(1)); // Role 1 = STUDENT
        } catch (Exception e) {
            System.err.println("Error fetching students: " + e.getMessage());
            e.printStackTrace();
            // Return empty list to prevent frontend crash
            return ResponseEntity.ok(new ArrayList<>());
        }
    }

    /**
     * Bridge endpoint for getting all teachers
     * Frontend calls: /api/users/teachers
     */
    @GetMapping("/users/teachers")
    public ResponseEntity<List<com.classroomapp.classroombackend.dto.UserDto>> getAllTeachers() {
        try {
            // Get teachers directly from repository since service method is broken
            List<User> teachers = userRepository.findByRoleId(2); // Role 2 = TEACHER
            List<com.classroomapp.classroombackend.dto.UserDto> teacherDtos = teachers.stream()
                .map(user -> {
                    com.classroomapp.classroombackend.dto.UserDto dto = new com.classroomapp.classroombackend.dto.UserDto();
                    dto.setId(user.getId());
                    dto.setUsername(user.getUsername());
                    dto.setEmail(user.getEmail());
                    dto.setFullName(user.getFullName());
                    dto.setRoleId(user.getRoleId());
                    dto.setStatus(user.getStatus());
                    return dto;
                })
                .collect(Collectors.toList());

            System.out.println("Found " + teacherDtos.size() + " teachers");
            return ResponseEntity.ok(teacherDtos);
        } catch (Exception e) {
            System.err.println("Error fetching teachers: " + e.getMessage());
            e.printStackTrace();
            // Return empty list to prevent frontend crash
            return ResponseEntity.ok(new ArrayList<>());
        }
    }
    
    // Note: Removed duplicate endpoints for /classrooms/student/{studentId} and /classrooms/teacher/{teacherId}
    // These are already handled by ClassroomController at /api/classrooms/student/{studentId} and /api/classrooms/teacher/{teacherId}
    
    // Note: Removed duplicate endpoint for /assignments
    // This is already handled by AssignmentController at /api/assignments
    
    /**
     * Bridge endpoint for getting student messages
     * Frontend calls: /student-messages/student/{studentId}
     * Maps to: /api/messages/received/{studentId}
     */
    @GetMapping("/student-messages/student/{studentId}")
    public ResponseEntity<List<StudentMessageDto>> getStudentMessages(@PathVariable Long studentId) {
        return ResponseEntity.ok(messageService.getReceivedMessages(studentId));
    }      /**
     * Direct endpoint for getting received messages
     * Frontend calls: /api/messages/received/{userId}
     */    @GetMapping("/messages/received/{userId}")
    public ResponseEntity<List<StudentMessageDto>> getReceivedMessages(@PathVariable Long userId) {
        try {
            System.out.println("=== GET RECEIVED MESSAGES DEBUG ===");
            System.out.println("User ID: " + userId);
            
            // Try to get messages from service first
            List<StudentMessageDto> messages = messageService.getReceivedMessages(userId);
            
            if (messages != null && !messages.isEmpty()) {
                System.out.println("Found " + messages.size() + " messages from service");
                return ResponseEntity.ok(messages);
            }
            
            // If no messages from service, return sample data for user 404
            if (userId.equals(404L)) {
                System.out.println("Returning sample messages for user 404");
                List<StudentMessageDto> sampleMessages = new ArrayList<>();
                
                StudentMessageDto msg1 = new StudentMessageDto();
                msg1.setId(1L);
                msg1.setSenderId(296L); // teacher
                msg1.setSenderName("Giảng viên Toán");
                msg1.setRecipientId(userId);
                msg1.setRecipientName("Học sinh " + userId);
                msg1.setSubject("Thông báo về bài tập");
                msg1.setContent("Nhớ nộp bài tập toán trước ngày mai nhé.");
                msg1.setMessageType("GENERAL");
                msg1.setPriority("MEDIUM");
                msg1.setStatus("DELIVERED");
                msg1.setIsRead(false);
                msg1.setCreatedAt(java.time.LocalDateTime.now().minusDays(1));
                msg1.setUpdatedAt(java.time.LocalDateTime.now().minusDays(1));
                
                StudentMessageDto msg2 = new StudentMessageDto();
                msg2.setId(2L);
                msg2.setSenderId(296L); // teacher
                msg2.setSenderName("Giảng viên Văn");
                msg2.setRecipientId(userId);
                msg2.setRecipientName("Học sinh " + userId);
                msg2.setSubject("Lịch kiểm tra");
                msg2.setContent("Thứ 6 tuần sau sẽ có kiểm tra văn. Các em chuẩn bị chương 1-3.");
                msg2.setMessageType("URGENT");
                msg2.setPriority("HIGH");
                msg2.setStatus("DELIVERED");
                msg2.setIsRead(false);
                msg2.setCreatedAt(java.time.LocalDateTime.now().minusHours(6));
                msg2.setUpdatedAt(java.time.LocalDateTime.now().minusHours(6));
                
                sampleMessages.add(msg1);
                sampleMessages.add(msg2);
                
                return ResponseEntity.ok(sampleMessages);
            }
            
            System.out.println("Returning empty list");
            System.out.println("=== END GET RECEIVED MESSAGES DEBUG ===");
            return ResponseEntity.ok(new ArrayList<>());
            
        } catch (Throwable e) {
            // Log error and return empty list instead of error to prevent frontend crash
            System.err.println("Error in getReceivedMessages controller: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.ok(new ArrayList<>());
        }
    }/**
     * Working messages endpoint
     */
    @GetMapping("/student-messages/received/{userId}")
    public ResponseEntity<List<StudentMessageDto>> getStudentReceivedMessages(@PathVariable Long userId) {
        // Create sample data for testing
        List<StudentMessageDto> sampleMessages = new ArrayList<>();
        
        StudentMessageDto msg1 = new StudentMessageDto();
        msg1.setId(1L);
        msg1.setSenderId(296L); // teacher
        msg1.setSenderName("Teacher User");
        msg1.setRecipientId(userId);
        msg1.setRecipientName("Student User");
        msg1.setSubject("Assignment Reminder");
        msg1.setContent("Don't forget to submit your math assignment by tomorrow.");
        msg1.setMessageType("GENERAL");
        msg1.setPriority("MEDIUM");
        msg1.setStatus("DELIVERED");
        msg1.setIsRead(false);
        msg1.setCreatedAt(java.time.LocalDateTime.now().minusDays(1));
        msg1.setUpdatedAt(java.time.LocalDateTime.now().minusDays(1));
        
        StudentMessageDto msg2 = new StudentMessageDto();
        msg2.setId(2L);
        msg2.setSenderId(296L); // teacher
        msg2.setSenderName("Teacher User");
        msg2.setRecipientId(userId);
        msg2.setRecipientName("Student User");
        msg2.setSubject("Test Schedule");
        msg2.setContent("We have a test next Friday. Please prepare chapters 1-3.");
        msg2.setMessageType("URGENT");
        msg2.setPriority("HIGH");
        msg2.setStatus("DELIVERED");
        msg2.setIsRead(false);
        msg2.setCreatedAt(java.time.LocalDateTime.now().minusHours(6));
        msg2.setUpdatedAt(java.time.LocalDateTime.now().minusHours(6));
        
        sampleMessages.add(msg1);
        sampleMessages.add(msg2);
        
        return ResponseEntity.ok(sampleMessages);
    }    /**
     * Bridge endpoint for sending student messages
     * Frontend calls: POST /student-messages
     * Maps to: POST /api/messages
     */
    @PostMapping("/student-messages")
    public ResponseEntity<StudentMessageDto> sendStudentMessage(@Valid @RequestBody StudentMessageDto messageDto) {
        return ResponseEntity.ok(messageService.sendMessage(messageDto));
    }
    
    /**
     * Send a new message
     */
    @PostMapping("/student-messages/send")
    public ResponseEntity<StudentMessageDto> sendMessage(@RequestBody StudentMessageDto messageData) {
        try {
            System.out.println("=== SEND MESSAGE DEBUG ===");
            System.out.println("Received message data: " + messageData);
            System.out.println("Sender ID: " + messageData.getSenderId());
            System.out.println("Recipient ID: " + messageData.getRecipientId());
            System.out.println("Content: " + messageData.getContent());
            
            // Save the message using the service
            StudentMessageDto savedMessage = messageService.sendMessage(messageData);
            
            System.out.println("Message saved successfully with ID: " + savedMessage.getId());
            System.out.println("=== END SEND MESSAGE DEBUG ===");
            
            return ResponseEntity.ok(savedMessage);
        } catch (Exception e) {
            System.err.println("=== SEND MESSAGE ERROR ===");
            System.err.println("Error saving message: " + e.getMessage());
            e.printStackTrace();
            System.err.println("=== END SEND MESSAGE ERROR ===");
            
            // If service fails, return the message with generated data as fallback
            messageData.setId(System.currentTimeMillis()); // Simple ID generation
            messageData.setStatus("DELIVERED");
            messageData.setIsRead(false);
            messageData.setCreatedAt(java.time.LocalDateTime.now());
            messageData.setUpdatedAt(java.time.LocalDateTime.now());
            
            return ResponseEntity.ok(messageData);
        }
    }

    // Note: Removed duplicate endpoint for /attendance/sessions/classroom/{classroomId}
    // This is already handled by AttendanceController at /api/attendance/sessions/classroom/{classroomId}
    
    // Note: Removed duplicate endpoints for /users/teachers and /users/students
    // These are already handled by UserController at /api/users/teachers and /api/users/students
    
    /**
     * REMOVED: Bridge endpoint for getting current teacher's classrooms
     * This endpoint was causing a conflict with ClassroomController.
     * Frontend should call: /api/classrooms/current-teacher directly
     * which is handled by ClassroomController.GetClassroomsByCurrentTeacher()
     */
    // @GetMapping("/classrooms/current-teacher")
    // public ResponseEntity<List<ClassroomDto>> getCurrentTeacherClassrooms(Authentication authentication) {
    //     // Extract user ID from JWT token
    //     String username = authentication.getName();
    //     User currentUser = userRepository.findByUsername(username)
    //             .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
    //     return ResponseEntity.ok(classroomService.GetClassroomsByTeacher(currentUser.getId()));
    // }
    
    /**
     * REMOVED: Bridge endpoint for getting current teacher's assignments
     * This endpoint was causing a conflict with AssignmentController.
     * Frontend should call: /api/assignments/current-teacher directly
     * which is handled by AssignmentController.GetAssignmentsByCurrentTeacher()
     */
    // @GetMapping("/assignments/current-teacher")
    // public ResponseEntity<List<AssignmentDto>> getCurrentTeacherAssignments(Authentication authentication) {
    //     // Extract user ID from JWT token
    //     String username = authentication.getName();
    //     User currentUser = userRepository.findByUsername(username)
    //             .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
    //     return ResponseEntity.ok(assignmentService.findByTeacherId(currentUser.getId()));
    // }
    
    /**
     * REMOVED: Bridge endpoint for getting current student's classrooms
     * This endpoint was causing a conflict with ClassroomController.
     * Frontend should call: /api/classrooms/current-student directly
     * which is handled by ClassroomController.GetClassroomsByCurrentStudent()
     */
    // @GetMapping("/classrooms/current-student")
    // public ResponseEntity<List<ClassroomDto>> getCurrentStudentClassrooms(Authentication authentication) {
    //     // Extract user ID from JWT token
    //     String username = authentication.getName();
    //     User currentUser = userRepository.findByUsername(username)
    //             .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
    //     return ResponseEntity.ok(classroomService.GetClassroomsByStudent(currentUser.getId()));
    // }
    
    /**
     * Bridge endpoint for getting current student's courses
     * Frontend calls: /courses/current-student
     * Gets current user from JWT token
     */
    @GetMapping("/courses/current-student")
    public ResponseEntity<List<ClassroomDto>> getCurrentStudentCourses(Authentication authentication) {
        // For now, return same as classrooms since we don't have separate course entity
        String username = authentication.getName();
        User currentUser = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
        return ResponseEntity.ok(classroomService.GetClassroomsByStudent(currentUser.getId()));
    }
    
    /**
     * Bridge endpoint for getting current student's attendance records
     * Frontend calls: /attendance/current-student
     * Gets attendance records for current student
     */
    @GetMapping("/attendance/current-student")
    public ResponseEntity<?> getCurrentStudentAttendance(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Get actual attendance data from service
            List<AttendanceDto> attendanceRecords = attendanceService.findByUserId(currentUser.getId());
            
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", attendanceRecords);
            }});
        } catch (Exception e) {
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", java.util.Collections.emptyList());
            }});
        }
    }



    /**
     * Bridge endpoint for getting unread message count for students
     * Frontend calls: /student-messages/unread-count
     */
    @GetMapping("/student-messages/unread-count")
    public ResponseEntity<?> getStudentUnreadMessageCount(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Get actual unread count from service
            Long unreadCount = messageService.countUnreadMessages(currentUser.getId());
            
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Long>() {{
                    put("count", unreadCount);
                }});
            }});
        } catch (Exception e) {
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Integer>() {{
                    put("count", 0);
                }});
            }});
        }
    }    /**
     * Bridge endpoint for getting attendance stats for teachers
     * Frontend calls: /attendance/current-teacher/stats
     */
    @GetMapping("/attendance/current-teacher/stats")
    public ResponseEntity<?> getTeacherAttendanceStats(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Get real stats based on teacher's classrooms
            List<ClassroomDto> classrooms = classroomService.GetClassroomsByTeacher(currentUser.getId());
            List<AssignmentDto> assignments = assignmentService.findByTeacherId(currentUser.getId());
            
            // Calculate stats
            final int totalStudents = classrooms.size() * 10; // Mock: 10 students per classroom
            final int totalSessions = assignments.size() * 4; // Assume 4 sessions per assignment
            final double attendanceRate = classrooms.isEmpty() ? 0.0 : 85.5; // 85.5% attendance rate
            
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Object>() {{
                    put("totalSessions", totalSessions);
                    put("averageAttendance", attendanceRate);
                    put("totalStudents", totalStudents);
                    put("totalClassrooms", classrooms.size());
                    put("totalAssignments", assignments.size());
                }});
            }});
        } catch (Exception e) {
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Object>() {{
                    put("totalSessions", 0);
                    put("averageAttendance", 0);
                }});
            }});
        }
    }
    
    /**
     * Bridge endpoint for getting unread message count for teachers
     * Frontend calls: /teacher-messages/unread-count
     */
    @GetMapping("/teacher-messages/unread-count")
    public ResponseEntity<?> getTeacherUnreadMessageCount(Authentication authentication) {
        try {
            String username = authentication.getName();
            userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Return mock data for now
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Integer>() {{
                    put("count", 0);
                }});
            }});
        } catch (Exception e) {
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("data", new java.util.HashMap<String, Integer>() {{
                    put("count", 0);
                }});
            }});
        }
    }

    /**
     * Bridge endpoint for getting courses by student ID
     * Frontend calls: /courses/student
     */
    @GetMapping("/courses/student")
    public ResponseEntity<List<ClassroomDto>> getStudentCourses(Authentication authentication) {
        // Extract user ID from JWT token
        String username = authentication.getName();
        User currentUser = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
        return ResponseEntity.ok(classroomService.GetClassroomsByStudent(currentUser.getId()));
    }

    /**
     * REMOVED: Bridge endpoint for getting assignments by specific teacher ID
     * This endpoint was causing a conflict with AssignmentController.
     * Frontend should call: /api/assignments/teacher/{teacherId} directly
     * which is handled by AssignmentController.getAssignmentsByTeacher()
     */
    // @GetMapping("/assignments/teacher/{teacherId}")
    // public ResponseEntity<List<AssignmentDto>> getAssignmentsByTeacher(@PathVariable Long teacherId) {
    //     return ResponseEntity.ok(assignmentService.findByTeacherId(teacherId));
    // }

    /**
     * Bridge endpoint for teacher profile management
     * Frontend calls: /teacher/profile
     */
    @GetMapping("/teacher/profile")
    public ResponseEntity<?> getTeacherProfile(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Return basic teacher profile - should be replaced with actual teacher profile service
            return ResponseEntity.ok(new java.util.HashMap<String, Object>() {{
                put("id", currentUser.getId());
                put("username", currentUser.getUsername());
                put("email", currentUser.getEmail());
                put("fullName", currentUser.getFullName());
                put("roleId", currentUser.getRoleId());
            }});
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    /**
     * Bridge endpoint for updating teacher profile
     * Frontend calls: PUT /teacher/profile
     */
    @PutMapping("/teacher/profile")
    public ResponseEntity<?> updateTeacherProfile(@RequestBody Map<String, Object> profileData, Authentication authentication) {
        try {
            String username = authentication.getName();
            userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Here you would update the teacher profile using userService
            // For now, just return success response
            return ResponseEntity.ok(new java.util.HashMap<String, String>() {{
                put("message", "Profile updated successfully");
            }});
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }

    /**
     * REMOVED: Bridge endpoint for getting current student's assignments
     * This endpoint was causing a potential conflict with AssignmentController.
     * Frontend should call: /api/assignments/student/me directly
     * which is handled by AssignmentController.GetAssignmentsForCurrentStudent()
     */
    // @GetMapping("/assignments/student")
    // public ResponseEntity<List<AssignmentDto>> getCurrentStudentAssignments(Authentication authentication) {
    //     // Extract user ID from JWT token
    //     String username = authentication.getName();
    //     User currentUser = userRepository.findByUsername(username)
    //             .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
    //     return ResponseEntity.ok(assignmentService.findByStudentId(currentUser.getId()));
    // }

    /**
     * REMOVED: Bridge endpoint for getting all classrooms
     * This endpoint should be centralized in ClassroomController.
     * Frontend should call: /api/classrooms directly
     * A GET /api/classrooms endpoint should be added to ClassroomController if needed.
     */
    // @GetMapping("/classrooms")
    // public ResponseEntity<List<ClassroomDto>> getAllClassrooms() {
    //     return ResponseEntity.ok(classroomService.getAllClassrooms());
    // }
    
    /**
     * REMOVED: Bridge endpoint for getting all assignments
     * This endpoint was causing a conflict with AssignmentController.
     * Frontend should call: /api/assignments directly
     * which is handled by AssignmentController.GetAllAssignments()
     */
    // @GetMapping("/assignments")
    // public ResponseEntity<List<AssignmentDto>> getAllAssignments() {
    //     return ResponseEntity.ok(assignmentService.getAllAssignments());
    // }

    /**
     * Test endpoint
     */
    @GetMapping("/messages/test")
    public ResponseEntity<String> testMessages() {
        return ResponseEntity.ok("Messages API is working!");
    }

    /**
     * Simple test endpoint for messages service
     */
    @GetMapping("/messages/debug/{userId}")
    public ResponseEntity<?> debugMessages(@PathVariable Long userId) {
        try {
            return ResponseEntity.ok("Debug: userId = " + userId);
        } catch (Throwable e) {
            return ResponseEntity.ok("Error: " + e.getMessage());
        }
    }    /**
     * Get conversation between two users
     */    @GetMapping("/student-messages/conversation/{userId1}/{userId2}")
    public ResponseEntity<List<StudentMessageDto>> getConversation(@PathVariable Long userId1, @PathVariable Long userId2) {
        try {
            System.out.println("=== GET CONVERSATION DEBUG ===");
            System.out.println("Getting conversation between user " + userId1 + " and user " + userId2);
            
            // Get real conversation from database - this will create sample messages if none exist
            List<StudentMessageDto> conversation = messageService.getConversation(userId1, userId2);
            
            System.out.println("Found " + conversation.size() + " messages in conversation");
            for (int i = 0; i < conversation.size(); i++) {
                StudentMessageDto msg = conversation.get(i);
                System.out.println("Message " + (i+1) + ": ID=" + msg.getId() + ", From=" + msg.getSenderId() + "(" + msg.getSenderName() + "), To=" + msg.getRecipientId() + "(" + msg.getRecipientName() + "), Content=" + msg.getContent());
            }
            System.out.println("=== END GET CONVERSATION DEBUG ===");
            
            return ResponseEntity.ok(conversation);
        } catch (Exception e) {
            System.err.println("=== GET CONVERSATION ERROR ===");
            System.err.println("Error getting conversation: " + e.getMessage());
            e.printStackTrace();
            System.err.println("=== END GET CONVERSATION ERROR ===");
            
            // Return empty list instead of sample data
            return ResponseEntity.ok(new ArrayList<>());
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/GreetingController.java">
package com.classroomapp.classroombackend.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/greetings")
public class GreetingController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Xin chào! Backend Spring Boot cho ứng dụng quản lý lớp học đã sẵn sàng tại hello controller!";
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/HealthController.java">
package com.classroomapp.classroombackend.controller;

import java.util.HashMap;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = {"http://localhost:3000", "http://localhost:3001"}, allowCredentials = "true")
public class HealthController {
    
    /**
     * Simple health check endpoint
     * @return Status information about the API server
     */
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> healthCheck() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("message", "API Server is running");
        response.put("timestamp", System.currentTimeMillis());
        return ResponseEntity.ok(response);
    }
    
    /**
     * Version 1 health check endpoint
     */
    @GetMapping("/v1/health")
    public ResponseEntity<Map<String, Object>> healthCheckV1() {
        return healthCheck();
    }
    
    /**
     * Ping endpoint for simple connectivity testing
     */
    @GetMapping("/ping")
    public ResponseEntity<String> ping() {
        return ResponseEntity.ok("pong");
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/LectureController.java">
package com.classroomapp.classroombackend.controller;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.LectureMaterialDto;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.LectureMaterial;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.repository.LectureMaterialRepository;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.FileStorageService;

@RestController
@RequestMapping("/api")
public class LectureController {

    @Autowired
    private LectureRepository lectureRepository;
    
    @Autowired
    private LectureMaterialRepository lectureMaterialRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private FileStorageService fileStorageService;

    // Get all lectures for a classroom - Changed endpoint to avoid conflict with CourseController
    @GetMapping("/lectures/classroom/{classroomId}")
    public ResponseEntity<List<LectureDto>> getLecturesByClassroom(@PathVariable Long classroomId) {
        List<Lecture> lectures = lectureRepository.findByClassroomId(classroomId);
        List<LectureDto> lectureDtos = new ArrayList<>();
        
        for (Lecture lecture : lectures) {
            LectureDto dto = new LectureDto();
            dto.setId(lecture.getId());
            dto.setTitle(lecture.getTitle());
            dto.setContent(lecture.getContent());
            dto.setLectureDate(lecture.getLectureDate());
            dto.setClassroomId(lecture.getClassroom().getId());
            
            // Get materials for this lecture
            List<LectureMaterial> materials = lectureMaterialRepository.findByLectureId(lecture.getId());
            List<LectureMaterialDto> materialDtos = new ArrayList<>();
            
            for (LectureMaterial material : materials) {
                LectureMaterialDto materialDto = new LectureMaterialDto();
                materialDto.setId(material.getId());
                materialDto.setFileName(material.getFileName());
                materialDto.setFilePath(material.getFilePath());
                materialDto.setFileSize(material.getFileSize());
                materialDto.setContentType(material.getContentType());
                materialDto.setDownloadUrl(material.getDownloadUrl());
                materialDto.setLectureId(lecture.getId());
                
                materialDtos.add(materialDto);
            }
            
            dto.setMaterials(materialDtos);
            lectureDtos.add(dto);
        }
        
        return ResponseEntity.ok(lectureDtos);
    }

    // Get a specific lecture
    @GetMapping("/lectures/{id}")
    public ResponseEntity<LectureDto> getLecture(@PathVariable Long id) {
        Optional<Lecture> lectureOpt = lectureRepository.findById(id);
        
        if (lectureOpt.isPresent()) {
            Lecture lecture = lectureOpt.get();
            LectureDto dto = new LectureDto();
            dto.setId(lecture.getId());
            dto.setTitle(lecture.getTitle());
            dto.setContent(lecture.getContent());
            dto.setLectureDate(lecture.getLectureDate());
            dto.setClassroomId(lecture.getClassroom().getId());
            
            // Get materials for this lecture
            List<LectureMaterial> materials = lectureMaterialRepository.findByLectureId(lecture.getId());
            List<LectureMaterialDto> materialDtos = new ArrayList<>();
            
            for (LectureMaterial material : materials) {
                LectureMaterialDto materialDto = new LectureMaterialDto();
                materialDto.setId(material.getId());
                materialDto.setFileName(material.getFileName());
                materialDto.setFilePath(material.getFilePath());
                materialDto.setFileSize(material.getFileSize());
                materialDto.setContentType(material.getContentType());
                materialDto.setDownloadUrl(material.getDownloadUrl());
                materialDto.setLectureId(lecture.getId());
                
                materialDtos.add(materialDto);
            }
            
            dto.setMaterials(materialDtos);
            return ResponseEntity.ok(dto);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Create a new lecture - New endpoint to match frontend
    @PostMapping("/lectures/classrooms/{classroomId}")
    public ResponseEntity<LectureDto> createLectureNew(@PathVariable Long classroomId, @RequestBody LectureDto lectureDto) {
        // Get current authenticated user
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String currentUserEmail = authentication.getName();

        System.out.println("🔍 [LectureController] Creating lecture for classroom " + classroomId + " by user: " + currentUserEmail);

        Optional<Classroom> classroomOpt = classroomRepository.findById(classroomId);

        if (classroomOpt.isPresent()) {
            Classroom classroom = classroomOpt.get();

            // Authorization check: Only the teacher of the classroom can create lectures
            if (!classroom.getTeacher().getEmail().equals(currentUserEmail)) {
                System.out.println("❌ [LectureController] Access denied: User " + currentUserEmail + " is not the teacher of classroom " + classroomId);
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            }

            System.out.println("✅ [LectureController] Authorization passed. Creating lecture...");

            Lecture lecture = new Lecture();
            lecture.setTitle(lectureDto.getTitle());
            lecture.setContent(lectureDto.getContent());
            lecture.setClassroom(classroom);
            lecture.setCreatedAt(LocalDateTime.now());
            lecture.setUpdatedAt(LocalDateTime.now());

            Lecture savedLecture = lectureRepository.save(lecture);

            System.out.println("✅ [LectureController] Lecture created successfully with ID: " + savedLecture.getId());

            LectureDto responseDto = new LectureDto();
            responseDto.setId(savedLecture.getId());
            responseDto.setTitle(savedLecture.getTitle());
            responseDto.setContent(savedLecture.getContent());
            responseDto.setLectureDate(savedLecture.getLectureDate());
            responseDto.setClassroomId(classroomId);

            return new ResponseEntity<>(responseDto, HttpStatus.CREATED);
        } else {
            System.out.println("❌ [LectureController] Classroom not found with ID: " + classroomId);
            return ResponseEntity.notFound().build();
        }
    }

    // Create a new lecture - Original endpoint
    @PostMapping("/courses/{classroomId}/lectures")
    public ResponseEntity<LectureDto> createLecture(@PathVariable Long classroomId, @RequestBody LectureDto lectureDto) {
        Optional<Classroom> classroomOpt = classroomRepository.findById(classroomId);
        
        if (classroomOpt.isPresent()) {
            Classroom classroom = classroomOpt.get();
            
            Lecture lecture = new Lecture();
            lecture.setTitle(lectureDto.getTitle());
            lecture.setContent(lectureDto.getContent());
            lecture.setLectureDate(lectureDto.getLectureDate() != null ? lectureDto.getLectureDate() : LocalDate.now());
            lecture.setClassroom(classroom);
            lecture.setCreatedAt(LocalDateTime.now());
            
            Lecture savedLecture = lectureRepository.save(lecture);
            
            LectureDto responseDto = new LectureDto();
            responseDto.setId(savedLecture.getId());
            responseDto.setTitle(savedLecture.getTitle());
            responseDto.setContent(savedLecture.getContent());
            responseDto.setLectureDate(savedLecture.getLectureDate());
            responseDto.setClassroomId(classroom.getId());
            
            return new ResponseEntity<>(responseDto, HttpStatus.CREATED);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Update a lecture
    @PutMapping("/courses/{classroomId}/lectures/{id}")
    public ResponseEntity<LectureDto> updateLecture(
            @PathVariable Long classroomId, 
            @PathVariable Long id, 
            @RequestBody LectureDto lectureDto) {
        
        Optional<Lecture> lectureOpt = lectureRepository.findById(id);
        
        if (lectureOpt.isPresent()) {
            Lecture lecture = lectureOpt.get();
            
            // Verify this lecture belongs to the specified classroom
            if (!lecture.getClassroom().getId().equals(classroomId)) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update fields
            lecture.setTitle(lectureDto.getTitle());
            lecture.setContent(lectureDto.getContent());
            if (lectureDto.getLectureDate() != null) {
                lecture.setLectureDate(lectureDto.getLectureDate());
            }
            lecture.setUpdatedAt(LocalDateTime.now());
            
            Lecture updatedLecture = lectureRepository.save(lecture);
            
            LectureDto responseDto = new LectureDto();
            responseDto.setId(updatedLecture.getId());
            responseDto.setTitle(updatedLecture.getTitle());
            responseDto.setContent(updatedLecture.getContent());
            responseDto.setLectureDate(updatedLecture.getLectureDate());
            responseDto.setClassroomId(classroomId);
            
            return ResponseEntity.ok(responseDto);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Delete a lecture
    @DeleteMapping("/courses/{classroomId}/lectures/{id}")
    public ResponseEntity<Void> deleteLecture(@PathVariable Long classroomId, @PathVariable Long id) {
        Optional<Lecture> lectureOpt = lectureRepository.findById(id);
        
        if (lectureOpt.isPresent()) {
            Lecture lecture = lectureOpt.get();
            
            // Verify this lecture belongs to the specified classroom
            if (!lecture.getClassroom().getId().equals(classroomId)) {
                return ResponseEntity.badRequest().build();
            }
            
            // Delete associated materials first
            List<LectureMaterial> materials = lectureMaterialRepository.findByLectureId(id);
            for (LectureMaterial material : materials) {
                lectureMaterialRepository.delete(material);
                
                // Optionally delete the actual file
                // fileStorageService.deleteFile(material.getFilePath());
            }
            
            // Now delete the lecture
            lectureRepository.delete(lecture);
            
            return ResponseEntity.noContent().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Get materials for a lecture
    @GetMapping("/lectures/{lectureId}/materials")
    public ResponseEntity<List<LectureMaterialDto>> getLectureMaterials(@PathVariable Long lectureId) {
        List<LectureMaterial> materials = lectureMaterialRepository.findByLectureId(lectureId);
        List<LectureMaterialDto> materialDtos = new ArrayList<>();
        
        for (LectureMaterial material : materials) {
            LectureMaterialDto dto = new LectureMaterialDto();
            dto.setId(material.getId());
            dto.setFileName(material.getFileName());
            dto.setFilePath(material.getFilePath());
            dto.setFileSize(material.getFileSize());
            dto.setContentType(material.getContentType());
            dto.setDownloadUrl(material.getDownloadUrl());
            dto.setLectureId(lectureId);
            
            materialDtos.add(dto);
        }
        
        return ResponseEntity.ok(materialDtos);
    }

    // Upload material for a lecture
    @PostMapping("/lectures/{lectureId}/materials")
    public ResponseEntity<LectureMaterialDto> uploadMaterial(
            @PathVariable Long lectureId,
            @RequestParam("file") MultipartFile file) {
        
        Optional<Lecture> lectureOpt = lectureRepository.findById(lectureId);
        
        if (lectureOpt.isPresent()) {
            try {
                // Save the file
                FileUploadResponse fileResponse = fileStorageService.save(file, "lectures");
                String fileName = fileResponse.getFileName();
                String filePath = fileName; // Simplified for example
                String downloadUrl = fileResponse.getFileUrl();
                
                // Create material record
                LectureMaterial material = new LectureMaterial();
                material.setLecture(lectureOpt.get());
                material.setFileName(file.getOriginalFilename());
                material.setFilePath(filePath);
                material.setFileSize(file.getSize());
                material.setContentType(file.getContentType());
                material.setDownloadUrl(downloadUrl);
                material.setCreatedAt(LocalDateTime.now());
                
                LectureMaterial savedMaterial = lectureMaterialRepository.save(material);
                
                // Create response DTO
                LectureMaterialDto dto = new LectureMaterialDto();
                dto.setId(savedMaterial.getId());
                dto.setFileName(savedMaterial.getFileName());
                dto.setFilePath(savedMaterial.getFilePath());
                dto.setFileSize(savedMaterial.getFileSize());
                dto.setContentType(savedMaterial.getContentType());
                dto.setDownloadUrl(savedMaterial.getDownloadUrl());
                dto.setLectureId(lectureId);
                return new ResponseEntity<>(dto, HttpStatus.CREATED);
            } catch (Exception e) {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Delete a material
    @DeleteMapping("/lectures/materials/{materialId}")
    public ResponseEntity<Void> deleteMaterial(@PathVariable Long materialId) {
        Optional<LectureMaterial> materialOpt = lectureMaterialRepository.findById(materialId);
        
        if (materialOpt.isPresent()) {
            LectureMaterial material = materialOpt.get();
            
            // Delete the material record
            lectureMaterialRepository.delete(material);
            
            // Optionally delete the actual file
            // fileStorageService.deleteFile(material.getFilePath());
            
            return ResponseEntity.noContent().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }
    
    // Create sample lectures for a classroom
    @PostMapping("/courses/{classroomId}/sample-lectures")
    public ResponseEntity<List<LectureDto>> createSampleLectures(@PathVariable Long classroomId) {
        Optional<Classroom> classroomOpt = classroomRepository.findById(classroomId);
        
        if (classroomOpt.isPresent()) {
            Classroom classroom = classroomOpt.get();
            List<LectureDto> createdLectures = new ArrayList<>();
            
            try {
                // Bài giảng 1: Giới thiệu khóa học
                Lecture lecture1 = new Lecture();
                lecture1.setTitle("Giới thiệu khóa học");
                lecture1.setContent("# Giới thiệu khóa học\n\n## Mục tiêu\n\n- Hiểu được các khái niệm cơ bản\n- Nắm vững các kỹ thuật nền tảng\n- Áp dụng kiến thức vào thực tiễn\n\n## Nội dung chính\n\n1. Tổng quan về môn học\n2. Các khái niệm cơ bản\n3. Phương pháp học tập hiệu quả");
                lecture1.setLectureDate(LocalDate.now());
                lecture1.setClassroom(classroom);
                lecture1.setCreatedAt(LocalDateTime.now());
                
                Lecture savedLecture1 = lectureRepository.save(lecture1);
                
                LectureDto dto1 = new LectureDto();
                dto1.setId(savedLecture1.getId());
                dto1.setTitle(savedLecture1.getTitle());
                dto1.setContent(savedLecture1.getContent());
                dto1.setLectureDate(savedLecture1.getLectureDate());
                dto1.setClassroomId(classroom.getId());
                
                createdLectures.add(dto1);
                
                // Bài giảng 2: Lý thuyết cơ bản
                Lecture lecture2 = new Lecture();
                lecture2.setTitle("Lý thuyết cơ bản");
                lecture2.setContent("# Lý thuyết cơ bản\n\n## Các khái niệm chính\n\n- Định nghĩa và ý nghĩa\n- Cấu trúc và thành phần\n- Quy trình hoạt động\n\n## Ứng dụng thực tiễn\n\n1. Phân tích trường hợp điển hình\n2. Giải quyết vấn đề thực tế\n3. Tối ưu hóa quy trình");
                lecture2.setLectureDate(LocalDate.now().plusDays(7));
                lecture2.setClassroom(classroom);
                lecture2.setCreatedAt(LocalDateTime.now());
                
                Lecture savedLecture2 = lectureRepository.save(lecture2);
                
                LectureDto dto2 = new LectureDto();
                dto2.setId(savedLecture2.getId());
                dto2.setTitle(savedLecture2.getTitle());
                dto2.setContent(savedLecture2.getContent());
                dto2.setLectureDate(savedLecture2.getLectureDate());
                dto2.setClassroomId(classroom.getId());
                
                createdLectures.add(dto2);
                
                // Bài giảng 3: Thực hành và ứng dụng
                Lecture lecture3 = new Lecture();
                lecture3.setTitle("Thực hành và ứng dụng");
                lecture3.setContent("# Thực hành và ứng dụng\n\n## Mục tiêu\n\n- Áp dụng lý thuyết vào thực tiễn\n- Phát triển kỹ năng thực hành\n- Giải quyết các bài toán thực tế\n\n## Nội dung\n\n1. Bài tập thực hành\n2. Dự án nhóm\n3. Đánh giá và phản hồi");
                lecture3.setLectureDate(LocalDate.now().plusDays(14));
                lecture3.setClassroom(classroom);
                lecture3.setCreatedAt(LocalDateTime.now());
                
                Lecture savedLecture3 = lectureRepository.save(lecture3);
                
                LectureDto dto3 = new LectureDto();
                dto3.setId(savedLecture3.getId());
                dto3.setTitle(savedLecture3.getTitle());
                dto3.setContent(savedLecture3.getContent());
                dto3.setLectureDate(savedLecture3.getLectureDate());
                dto3.setClassroomId(classroom.getId());
                
                createdLectures.add(dto3);
                
                return new ResponseEntity<>(createdLectures, HttpStatus.CREATED);
            } catch (Exception e) {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/MaterialController.java">
package com.classroomapp.classroombackend.controller;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

class MaterialDto {
    private Long id;
    private String fileName;
    private String fileType;
    private String downloadUrl;
    private String uploadDate;
    private String uploadedBy;
    private long fileSize;
    private String description;
    private String category;
    
    public MaterialDto() {}
    
    public MaterialDto(Long id, String fileName, String fileType, String uploadedBy) {
        this.id = id;
        this.fileName = fileName;
        this.fileType = fileType;
        this.uploadedBy = uploadedBy;
        this.downloadUrl = "/api/mock-materials/download/" + id;
        this.uploadDate = java.time.LocalDateTime.now().toString();
        this.fileSize = 1024000; // Mock size
        this.description = "Tài liệu học tập";
        this.category = "General";
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getFileName() { return fileName; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    public String getFileType() { return fileType; }
    public void setFileType(String fileType) { this.fileType = fileType; }
    public String getDownloadUrl() { return downloadUrl; }
    public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }
    public String getUploadDate() { return uploadDate; }
    public void setUploadDate(String uploadDate) { this.uploadDate = uploadDate; }
    public String getUploadedBy() { return uploadedBy; }
    public void setUploadedBy(String uploadedBy) { this.uploadedBy = uploadedBy; }
    public long getFileSize() { return fileSize; }
    public void setFileSize(long fileSize) { this.fileSize = fileSize; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getCategory() { return category; }
    public void setCategory(String category) { this.category = category; }
}

@RestController
@RequestMapping("/api/mock-materials")
@CrossOrigin(origins = "*")
public class MaterialController {

    private final Map<Long, MaterialDto> materials = new ConcurrentHashMap<>();
    private final Map<Long, byte[]> fileContents = new ConcurrentHashMap<>();
    private final AtomicLong materialIdCounter = new AtomicLong(3000);

    public MaterialController() {
        // Initialize mock materials
        MaterialDto material1 = new MaterialDto(materialIdCounter.getAndIncrement(), 
            "Java Programming Guide.pdf", "PDF", "Thầy Nguyễn Văn A");
        material1.setDescription("Hướng dẫn lập trình Java từ cơ bản đến nâng cao");
        material1.setCategory("Programming");
        materials.put(material1.getId(), material1);
        
        MaterialDto material2 = new MaterialDto(materialIdCounter.getAndIncrement(), 
            "Database Design Examples.docx", "DOCX", "Cô Trần Thị B");
        material2.setDescription("Các ví dụ thiết kế cơ sở dữ liệu");
        material2.setCategory("Database");
        materials.put(material2.getId(), material2);
        
        MaterialDto material3 = new MaterialDto(materialIdCounter.getAndIncrement(), 
            "Web Development Tutorial.mp4", "VIDEO", "Thầy Lê Văn C");
        material3.setDescription("Video hướng dẫn phát triển web");
        material3.setCategory("Web Development");
        materials.put(material3.getId(), material3);
        
        // Mock file contents
        String mockContent = "Đây là nội dung mock của file tài liệu";
        fileContents.put(material1.getId(), mockContent.getBytes());
        fileContents.put(material2.getId(), mockContent.getBytes());
        fileContents.put(material3.getId(), mockContent.getBytes());
    }

    // Get all materials
    @GetMapping
    public ResponseEntity<List<MaterialDto>> getAllMaterials(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String search) {
        System.out.println("Yêu cầu lấy danh sách tài liệu - Category: " + category + ", Search: " + search);
        
        List<MaterialDto> result = new ArrayList<>(materials.values());
        
        // Filter by category
        if (category != null && !category.isEmpty()) {
            result.removeIf(material -> !material.getCategory().equalsIgnoreCase(category));
        }
        
        // Filter by search term
        if (search != null && !search.isEmpty()) {
            result.removeIf(material -> 
                !material.getFileName().toLowerCase().contains(search.toLowerCase()) &&
                !material.getDescription().toLowerCase().contains(search.toLowerCase()));
        }
        
        return ResponseEntity.ok(result);
    }

    // Upload new material
    @PostMapping("/upload")
    public ResponseEntity<MaterialDto> uploadMaterial(
            @RequestParam("file") MultipartFile file,
            @RequestParam(required = false) String description,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String uploadedBy) {
        
        System.out.println("Yêu cầu upload file: " + file.getOriginalFilename());
        
        try {
            Long materialId = materialIdCounter.getAndIncrement();
            
            String fileName = file.getOriginalFilename();
            String fileType = getFileExtension(fileName);
            
            MaterialDto material = new MaterialDto(materialId, fileName, fileType, 
                uploadedBy != null ? uploadedBy : "Unknown User");
            material.setFileSize(file.getSize());
            material.setDescription(description != null ? description : "Uploaded material");
            material.setCategory(category != null ? category : "General");
            
            // Store file content
            fileContents.put(materialId, file.getBytes());
            materials.put(materialId, material);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(material);
            
        } catch (IOException e) {
            System.err.println("Lỗi upload file: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Download material
    @GetMapping("/download/{materialId}")
    public ResponseEntity<Resource> downloadMaterial(@PathVariable Long materialId) {
        System.out.println("Yêu cầu download tài liệu ID: " + materialId);
        
        MaterialDto material = materials.get(materialId);
        if (material == null) {
            return ResponseEntity.notFound().build();
        }
        
        byte[] content = fileContents.get(materialId);
        if (content == null) {
            // Create mock content if not exists
            content = ("Mock content for " + material.getFileName()).getBytes();
        }
        
        ByteArrayResource resource = new ByteArrayResource(content);
        
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(content.length)
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=\"" + material.getFileName() + "\"")
                .body(resource);
    }

    // Alternative download endpoint to match frontend service expectation
    @GetMapping("/{materialId}/download")
    public ResponseEntity<Resource> downloadMaterialAlternative(@PathVariable Long materialId) {
        return downloadMaterial(materialId);
    }

    // Get material details
    @GetMapping("/{materialId}")
    public ResponseEntity<MaterialDto> getMaterialDetails(@PathVariable Long materialId) {
        System.out.println("Yêu cầu lấy chi tiết tài liệu ID: " + materialId);
        
        MaterialDto material = materials.get(materialId);
        if (material != null) {
            return ResponseEntity.ok(material);
        }
        return ResponseEntity.notFound().build();
    }

    // Delete material
    @DeleteMapping("/{materialId}")
    public ResponseEntity<Void> deleteMaterial(@PathVariable Long materialId) {
        System.out.println("Yêu cầu xóa tài liệu ID: " + materialId);
        
        if (materials.containsKey(materialId)) {
            materials.remove(materialId);
            fileContents.remove(materialId);
            return ResponseEntity.ok().build();
        }
        return ResponseEntity.notFound().build();
    }
    
    // Get materials by course ID
    @GetMapping("/course/{courseId}")
    public ResponseEntity<List<MaterialDto>> getMaterialsByCourse(
            @PathVariable Long courseId,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String search) {
        System.out.println("Yêu cầu lấy danh sách tài liệu cho khóa học ID: " + courseId);
        
        // In a real implementation, you would filter materials by course ID from the database
        // For mock purposes, we'll return all materials with a mock filtering
        List<MaterialDto> result = new ArrayList<>(materials.values());
        
        // Apply some mock filtering based on course ID (in this case, we'll just return all materials)
        // For demo purposes, maybe filter based on some characteristic of the ID
        if (courseId % 2 == 0) {
            // For even course IDs, filter to keep only PDFs
            result.removeIf(material -> !material.getFileType().equalsIgnoreCase("PDF"));
        }
        
        // Filter by category if provided
        if (category != null && !category.isEmpty()) {
            result.removeIf(material -> !material.getCategory().equalsIgnoreCase(category));
        }
        
        // Filter by search term if provided
        if (search != null && !search.isEmpty()) {
            result.removeIf(material -> 
                !material.getFileName().toLowerCase().contains(search.toLowerCase()) &&
                !material.getDescription().toLowerCase().contains(search.toLowerCase()));
        }
        
        return ResponseEntity.ok(result);
    }
    
    private String getFileExtension(String fileName) {
        if (fileName == null || fileName.lastIndexOf('.') == -1) {
            return "UNKNOWN";
        }
        return fileName.substring(fileName.lastIndexOf('.') + 1).toUpperCase();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/MCPController.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/MCPTestController.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/NotificationController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.NotificationDto;
import com.classroomapp.classroombackend.model.Notification;
import com.classroomapp.classroombackend.repository.NotificationRepository;

@RestController
@RequestMapping("/api/notifications")
@CrossOrigin(origins = "http://localhost:3000")
public class NotificationController {

    private final NotificationRepository notificationRepository;

    @Autowired
    public NotificationController(NotificationRepository notificationRepository) {
        this.notificationRepository = notificationRepository;
    }

    // Task 37: Nhận thông báo cho giảng viên
    @GetMapping("/teacher")
    public ResponseEntity<List<NotificationDto>> getNotificationsForTeacher() {
        System.out.println("Yêu cầu lấy danh sách thông báo cho giảng viên.");
        List<Notification> notifications = new ArrayList<>();
        
        try {
            // Use type-based filtering for teacher notifications
            notifications = notificationRepository.findByTypeOrderByCreatedAtDesc("TEACHER");
        } catch (Exception e) {
            System.err.println("Error fetching teacher notifications: " + e.getMessage());
            // Fallback to all notifications
            notifications = notificationRepository.findAllByOrderByCreatedAtDesc();
        }
        
        return ResponseEntity.ok(convertToNotificationDtoList(notifications));
    }
    
    // Get notifications for specific user
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<NotificationDto>> getNotificationsForUser(@PathVariable Long userId) {
        System.out.println("Yêu cầu lấy danh sách thông báo cho user ID: " + userId);
        List<Notification> notifications = new ArrayList<>();
        
        try {
            // Use recipientId to find notifications for the specific user
            notifications = notificationRepository.findByRecipientIdOrderByCreatedAtDesc(userId);
        } catch (Exception e) {
            System.err.println("Error fetching user notifications: " + e.getMessage());
            // Fallback to simpler method
            notifications = notificationRepository.findByRecipientId(userId);
        }
        
        return ResponseEntity.ok(convertToNotificationDtoList(notifications));
    }
    
    // Get announcements (alias for notifications)
    @GetMapping("/announcements/user/{userId}")
    public ResponseEntity<List<NotificationDto>> getAnnouncementsForUser(@PathVariable Long userId) {
        System.out.println("Yêu cầu lấy danh sách thông báo cho user ID: " + userId);
        List<Notification> notifications = new ArrayList<>();
        
        try {
            // Use type and recipientId to find announcement-type notifications for user
            notifications = notificationRepository.findByTypeAndRecipientId("ANNOUNCEMENT", userId);
        } catch (Exception e) {
            System.err.println("Error fetching user announcements: " + e.getMessage());
            // Fallback to all notifications for user
            notifications = notificationRepository.findByRecipientId(userId);
        }
        
        return ResponseEntity.ok(convertToNotificationDtoList(notifications));
    }

    // Đánh dấu thông báo đã đọc
    @PutMapping("/{notificationId}/read")
    public ResponseEntity<Void> markNotificationAsRead(@PathVariable Long notificationId) {
        System.out.println("Yêu cầu đánh dấu thông báo ID: " + notificationId + " là đã đọc.");
        
        try {
            Optional<Notification> notificationOpt = notificationRepository.findById(notificationId);
            if (notificationOpt.isPresent()) {
                Notification notification = notificationOpt.get();
                notification.setIsRead(true);
                notificationRepository.save(notification);
                return ResponseEntity.ok().build();
            } 
        } catch (Exception e) {
            System.err.println("Error marking notification as read: " + e.getMessage());
        }
        
        return ResponseEntity.notFound().build();
    }
    
    // Helper method to convert entity to DTO
    private List<NotificationDto> convertToNotificationDtoList(List<Notification> notifications) {
        List<NotificationDto> dtos = new ArrayList<>();
        for (Notification notification : notifications) {
            dtos.add(new NotificationDto(
                notification.getId(),
                notification.getMessage(),
                notification.getCreatedAt(),
                notification.getIsRead(),
                notification.getSender()
            ));
        }
        return dtos;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/RoleRequestController.java">
package com.classroomapp.classroombackend.controller;

import java.util.Base64;
import java.util.List;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.RequestDTO;
import com.classroomapp.classroombackend.dto.RequestResponseDTO;
import com.classroomapp.classroombackend.dto.StudentRequestFormDTO;
import com.classroomapp.classroombackend.dto.TeacherRequestFormDTO;
import com.classroomapp.classroombackend.service.FileStorageService;
import com.classroomapp.classroombackend.service.RequestService;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/role-requests")
@RequiredArgsConstructor
@CrossOrigin(originPatterns = {"http://localhost:3000", "http://localhost:5173"}, allowedHeaders = "*", allowCredentials = "true")
public class RoleRequestController {
    private final RequestService requestService;
    private final ObjectMapper objectMapper;
    private final FileStorageService fileStorageService;
    
    private static final Logger logger = LoggerFactory.getLogger(RoleRequestController.class);

    /**
     * Xử lý đăng ký yêu cầu làm giáo viên
     */
    @PostMapping("/teacher")
    public ResponseEntity<RequestResponseDTO> submitTeacherRequest(
            @Valid @RequestBody TeacherRequestFormDTO teacherForm) {
        
        logger.info("Received teacher registration request: {}", teacherForm.getEmail());
        
        try {
            // Xử lý file CV dạng base64
            if (teacherForm.getCvFileData() != null && !teacherForm.getCvFileData().isEmpty()) {
                logger.info("Processing CV file data: {}, type: {}", 
                        teacherForm.getCvFileName(), teacherForm.getCvFileType());
                
                try {
                    // Tách tiền tố data:image/jpeg;base64, từ chuỗi base64
                    String base64Data = teacherForm.getCvFileData();
                    if (base64Data.contains(",")) {
                        base64Data = base64Data.split(",")[1];
                    }
                    
                    // Giải mã base64 thành byte array
                    byte[] fileBytes = Base64.getDecoder().decode(base64Data);
                    
                    // Tạo MultipartFile giả từ byte array
                    String originalFilename = teacherForm.getCvFileName() != null ? 
                            teacherForm.getCvFileName() : "cv-file-" + UUID.randomUUID() + ".pdf";
                    String contentType = teacherForm.getCvFileType() != null ? 
                            teacherForm.getCvFileType() : "application/pdf";
                    
                    MultipartFile multipartFile = new MockMultipartFile(
                            "file", 
                            originalFilename, 
                            contentType, 
                            fileBytes);
                    
                    // Upload lên Firebase Storage
                    try {
                        FileUploadResponse response = fileStorageService.save(multipartFile, "cv-files");
                        String fileUrl = response.getFileUrl();
                        logger.info("CV file uploaded successfully to: {}", fileUrl);
                        
                        // Cập nhật URL cho form
                        teacherForm.setCvFileUrl(fileUrl);
                    } catch (Exception e) {
                        logger.error("Firebase upload failed: {}", e.getMessage());
                        // Tạo một URL tạm thời khi không thể upload
                        String tempFileUrl = "pending://" + UUID.randomUUID() + "/" + originalFilename;
                        teacherForm.setCvFileUrl(tempFileUrl);
                    }
                    
                    // Xóa dữ liệu base64 để tránh lưu vào database
                    teacherForm.setCvFileData(null);
                } catch (Exception e) {
                    logger.error("Failed to process CV file: {}", e.getMessage(), e);
                    // Tạo URL tạm nếu xảy ra lỗi
                    String tempFileUrl = "error://" + UUID.randomUUID() + "/error-processing-file.pdf";
                    teacherForm.setCvFileUrl(tempFileUrl);
                    teacherForm.setCvFileData(null);
                }
            } else {
                logger.warn("No CV file data received");
                throw new RuntimeException("Thiếu file CV, vui lòng upload lại");
            }
            
            // Tiếp tục xử lý form như bình thường
            RequestDTO requestDTO = new RequestDTO();
            requestDTO.setEmail(teacherForm.getEmail());
            requestDTO.setFullName(teacherForm.getFullName());
            requestDTO.setPhoneNumber(teacherForm.getPhoneNumber());
            requestDTO.setRequestedRole("TEACHER");
            
            // Chuyển đổi form data thành JSON để lưu trữ
            String formDataJson = objectMapper.writeValueAsString(teacherForm);
            requestDTO.setFormResponses(formDataJson);
              RequestResponseDTO response = requestService.createRequest(requestDTO);
            logger.info("Teacher registration successful for: {}", teacherForm.getEmail());
            return ResponseEntity.ok(response);
        } catch (com.fasterxml.jackson.core.JsonProcessingException e) {
            logger.error("JSON processing error for teacher request: {}", e.getMessage());
            throw new RuntimeException("Lỗi xử lý dữ liệu form", e);
        } catch (Exception e) {
            logger.error("Error processing teacher request for {}: {}", teacherForm.getEmail(), e.getMessage(), e);
            // Let the global exception handler deal with this
            throw e;
        }
    }    /**
     * Xử lý đăng ký yêu cầu làm học sinh
     */
    @PostMapping("/student")
    public ResponseEntity<RequestResponseDTO> submitStudentRequest(
            @Valid @RequestBody StudentRequestFormDTO studentForm) {
        
        logger.info("Received student registration request: {}", studentForm.getEmail());
        
        RequestDTO requestDTO = new RequestDTO();
        requestDTO.setEmail(studentForm.getEmail());
        requestDTO.setFullName(studentForm.getFullName());
        requestDTO.setPhoneNumber(studentForm.getPhoneNumber());
        requestDTO.setRequestedRole("STUDENT");
          try {
            // Chuyển đổi form data thành JSON để lưu trữ
            String formDataJson = objectMapper.writeValueAsString(studentForm);
            requestDTO.setFormResponses(formDataJson);
            
            RequestResponseDTO response = requestService.createRequest(requestDTO);
            logger.info("Student registration successful for: {}", studentForm.getEmail());
            return ResponseEntity.ok(response);
        } catch (com.fasterxml.jackson.core.JsonProcessingException e) {
            logger.error("JSON processing error for student request: {}", e.getMessage());
            throw new RuntimeException("Lỗi xử lý dữ liệu form", e);
        } catch (Exception e) {
            logger.error("Error processing student request for {}: {}", studentForm.getEmail(), e.getMessage(), e);
            // Let the global exception handler deal with this
            throw e;
        }
    }
    
    /**
     * Kiểm tra trạng thái yêu cầu qua email và role
     */
    @GetMapping("/check")
    public ResponseEntity<Boolean> checkActiveRequest(
            @RequestParam String email,
            @RequestParam String role) {
        return ResponseEntity.ok(requestService.hasActiveRequest(email, role));
    }

    /**
     * Lấy các yêu cầu của một người dùng
     */
    @GetMapping("/my-requests")
    public ResponseEntity<List<RequestResponseDTO>> getMyRequests(@RequestParam String email) {
        return ResponseEntity.ok(requestService.getRequestsByEmail(email));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/ScheduleController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.ScheduleDto;
import com.classroomapp.classroombackend.service.ScheduleService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RestController
@RequestMapping("/api/schedules")
@RequiredArgsConstructor
@Slf4j
public class ScheduleController {

    private final ScheduleService scheduleService;

    @GetMapping
    public ResponseEntity<List<ScheduleDto>> getAllSchedules() {
        List<ScheduleDto> schedules = scheduleService.getAllSchedules();
        return ResponseEntity.ok(schedules);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ScheduleDto> getScheduleById(@PathVariable Long id) {
        ScheduleDto schedule = scheduleService.getScheduleById(id);
        return ResponseEntity.ok(schedule);
    }

    @GetMapping("/teacher/{teacherId}")
    public ResponseEntity<List<ScheduleDto>> getSchedulesByTeacherId(@PathVariable Long teacherId) {
        List<ScheduleDto> schedules = scheduleService.getSchedulesByTeacherId(teacherId);
        return ResponseEntity.ok(schedules);
    }

    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<ScheduleDto>> getSchedulesByStudentId(@PathVariable Long studentId) {
        List<ScheduleDto> schedules = scheduleService.getSchedulesByStudentId(studentId);
        return ResponseEntity.ok(schedules);
    }

    @GetMapping("/classroom/{classroomId}")
    public ResponseEntity<List<ScheduleDto>> getSchedulesByClassroomId(@PathVariable Long classroomId) {
        log.info("GET /api/schedules/classroom/{} - Fetching schedules for classroom", classroomId);
        List<ScheduleDto> schedules = scheduleService.getSchedulesByClassroomId(classroomId);
        log.info("Found {} schedules for classroom ID {}", schedules.size(), classroomId);
        return ResponseEntity.ok(schedules);
    }

    @GetMapping("/{scheduleId}/lectures")
    public ResponseEntity<List<LectureDto>> getLecturesBySchedule(@PathVariable Long scheduleId) {
        log.info("GET /api/schedules/{}/lectures - Fetching lectures for schedule", scheduleId);
        List<LectureDto> lectures = scheduleService.getLecturesByScheduleId(scheduleId);
        log.info("Found {} lectures for schedule ID {}", lectures.size(), scheduleId);
        return ResponseEntity.ok(lectures);
    }

    @PostMapping
    public ResponseEntity<ScheduleDto> createSchedule(@Valid @RequestBody ScheduleDto scheduleDto) {
        ScheduleDto createdSchedule = scheduleService.createSchedule(scheduleDto);
        return new ResponseEntity<>(createdSchedule, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ScheduleDto> updateSchedule(
            @PathVariable Long id, 
            @Valid @RequestBody ScheduleDto scheduleDto) {
        ScheduleDto updatedSchedule = scheduleService.updateSchedule(id, scheduleDto);
        return ResponseEntity.ok(updatedSchedule);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteSchedule(@PathVariable Long id) {
        scheduleService.deleteSchedule(id);
        return ResponseEntity.noContent().build();
    }
    
    @PostMapping("/sample/{classroomId}")
    public ResponseEntity<String> createSampleSchedules(@PathVariable Long classroomId) {
        log.info("POST /api/schedules/sample/{} - Creating sample schedules", classroomId);
        try {
            scheduleService.createSampleSchedules(classroomId);
            return ResponseEntity.ok("Đã tạo lịch học mẫu cho lớp học");
        } catch (Exception e) {
            log.error("Error creating sample schedules for classroom {}: {}", classroomId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Lỗi khi tạo lịch học mẫu: " + e.getMessage());
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/StudentController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

class StudentCourseDto {
    private Long id;
    private String name;
    private String instructor;
    private String status;
    private int progressPercentage;
    private String nextClass;
    
    public StudentCourseDto(Long id, String name, String instructor, String status, int progressPercentage, String nextClass) {
        this.id = id;
        this.name = name;
        this.instructor = instructor;
        this.status = status;
        this.progressPercentage = progressPercentage;
        this.nextClass = nextClass;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getInstructor() { return instructor; }
    public void setInstructor(String instructor) { this.instructor = instructor; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public int getProgressPercentage() { return progressPercentage; }
    public void setProgressPercentage(int progressPercentage) { this.progressPercentage = progressPercentage; }
    public String getNextClass() { return nextClass; }
    public void setNextClass(String nextClass) { this.nextClass = nextClass; }
}

class StudentTimetableDto {
    private Long id;
    private String courseName;
    private String dayOfWeek;
    private String startTime;
    private String endTime;
    private String room;
    private String instructor;
    private String type;
    
    public StudentTimetableDto(Long id, String courseName, String dayOfWeek, String startTime, String endTime, String room, String instructor, String type) {
        this.id = id;
        this.courseName = courseName;
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
        this.room = room;
        this.instructor = instructor;
        this.type = type;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getCourseName() { return courseName; }
    public void setCourseName(String courseName) { this.courseName = courseName; }
    public String getDayOfWeek() { return dayOfWeek; }
    public void setDayOfWeek(String dayOfWeek) { this.dayOfWeek = dayOfWeek; }
    public String getStartTime() { return startTime; }
    public void setStartTime(String startTime) { this.startTime = startTime; }
    public String getEndTime() { return endTime; }
    public void setEndTime(String endTime) { this.endTime = endTime; }
    public String getRoom() { return room; }
    public void setRoom(String room) { this.room = room; }
    public String getInstructor() { return instructor; }
    public void setInstructor(String instructor) { this.instructor = instructor; }
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
}

class StudentProgressDto {
    private Long courseId;
    private String courseName;
    private int completedLectures;
    private int totalLectures;
    private int completedAssignments;
    private int totalAssignments;
    private double averageGrade;
    private String lastAccessed;
    
    public StudentProgressDto(Long courseId, String courseName, int completedLectures, int totalLectures, int completedAssignments, int totalAssignments, double averageGrade, String lastAccessed) {
        this.courseId = courseId;
        this.courseName = courseName;
        this.completedLectures = completedLectures;
        this.totalLectures = totalLectures;
        this.completedAssignments = completedAssignments;
        this.totalAssignments = totalAssignments;
        this.averageGrade = averageGrade;
        this.lastAccessed = lastAccessed;
    }
    
    // Getters and setters
    public Long getCourseId() { return courseId; }
    public void setCourseId(Long courseId) { this.courseId = courseId; }
    public String getCourseName() { return courseName; }
    public void setCourseName(String courseName) { this.courseName = courseName; }
    public int getCompletedLectures() { return completedLectures; }
    public void setCompletedLectures(int completedLectures) { this.completedLectures = completedLectures; }
    public int getTotalLectures() { return totalLectures; }
    public void setTotalLectures(int totalLectures) { this.totalLectures = totalLectures; }
    public int getCompletedAssignments() { return completedAssignments; }
    public void setCompletedAssignments(int completedAssignments) { this.completedAssignments = completedAssignments; }
    public int getTotalAssignments() { return totalAssignments; }
    public void setTotalAssignments(int totalAssignments) { this.totalAssignments = totalAssignments; }
    public double getAverageGrade() { return averageGrade; }
    public void setAverageGrade(double averageGrade) { this.averageGrade = averageGrade; }
    public String getLastAccessed() { return lastAccessed; }
    public void setLastAccessed(String lastAccessed) { this.lastAccessed = lastAccessed; }
}

@RestController
@RequestMapping("/api/students")
@CrossOrigin(origins = "http://localhost:3000")
public class StudentController {

    private final Map<Long, List<StudentCourseDto>> studentCourses = new ConcurrentHashMap<>();
    private final Map<Long, List<StudentTimetableDto>> studentTimetables = new ConcurrentHashMap<>();
    private final Map<Long, List<StudentProgressDto>> studentProgress = new ConcurrentHashMap<>();

    public StudentController() {
        // Initialize mock data for student ID 1
        List<StudentCourseDto> courses1 = new ArrayList<>();
        courses1.add(new StudentCourseDto(1L, "Lập trình Java cơ bản", "Thầy Nguyễn Văn A", "Đang học", 75, "Thứ 2, 08:00"));
        courses1.add(new StudentCourseDto(2L, "Cơ sở dữ liệu", "Cô Trần Thị B", "Đang học", 60, "Thứ 3, 10:00"));
        courses1.add(new StudentCourseDto(3L, "Phát triển Web", "Thầy Lê Văn C", "Hoàn thành", 100, "Đã hoàn thành"));
        studentCourses.put(1L, courses1);
        
        // Initialize timetable for student ID 1
        List<StudentTimetableDto> timetable1 = new ArrayList<>();
        timetable1.add(new StudentTimetableDto(1L, "Lập trình Java cơ bản", "Thứ 2", "08:00", "10:00", "P.101", "Thầy Nguyễn Văn A", "Lý thuyết"));
        timetable1.add(new StudentTimetableDto(2L, "Lập trình Java cơ bản", "Thứ 4", "14:00", "16:00", "Lab.A1", "Thầy Nguyễn Văn A", "Thực hành"));
        timetable1.add(new StudentTimetableDto(3L, "Cơ sở dữ liệu", "Thứ 3", "10:00", "12:00", "P.205", "Cô Trần Thị B", "Lý thuyết"));
        timetable1.add(new StudentTimetableDto(4L, "Cơ sở dữ liệu", "Thứ 5", "08:00", "10:00", "Lab.B2", "Cô Trần Thị B", "Thực hành"));
        studentTimetables.put(1L, timetable1);
        
        // Initialize progress for student ID 1
        List<StudentProgressDto> progress1 = new ArrayList<>();
        progress1.add(new StudentProgressDto(1L, "Lập trình Java cơ bản", 8, 12, 3, 5, 8.5, "2025-06-10 15:30:00"));
        progress1.add(new StudentProgressDto(2L, "Cơ sở dữ liệu", 6, 10, 2, 4, 7.8, "2025-06-09 14:20:00"));
        progress1.add(new StudentProgressDto(3L, "Phát triển Web", 15, 15, 6, 6, 9.2, "2025-05-28 16:45:00"));
        studentProgress.put(1L, progress1);
    }

    // Get student's courses
    @GetMapping("/{studentId}/courses")
    public ResponseEntity<List<StudentCourseDto>> getStudentCourses(@PathVariable Long studentId) {
        System.out.println("Yêu cầu lấy danh sách khóa học của sinh viên ID: " + studentId);
        List<StudentCourseDto> courses = studentCourses.getOrDefault(studentId, new ArrayList<>());
        return ResponseEntity.ok(courses);
    }

    // Get student's timetable
    @GetMapping("/{studentId}/timetable")
    public ResponseEntity<List<StudentTimetableDto>> getStudentTimetable(@PathVariable Long studentId) {
        System.out.println("Yêu cầu lấy thời khóa biểu của sinh viên ID: " + studentId);
        List<StudentTimetableDto> timetable = studentTimetables.getOrDefault(studentId, new ArrayList<>());
        return ResponseEntity.ok(timetable);
    }

    // Get student's learning progress
    @GetMapping("/{studentId}/progress")
    public ResponseEntity<List<StudentProgressDto>> getStudentProgress(@PathVariable Long studentId) {
        System.out.println("Yêu cầu lấy tiến độ học tập của sinh viên ID: " + studentId);
        List<StudentProgressDto> progress = studentProgress.getOrDefault(studentId, new ArrayList<>());
        return ResponseEntity.ok(progress);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/StudentMessageController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.StudentMessageDto;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.StudentMessageService;

/**
 * Controller for managing student messages
 */
@RestController
@RequestMapping("/api/student-messages")
@CrossOrigin(origins = "*")
public class StudentMessageController {

    @Autowired
    private StudentMessageService messageService;
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * Get messages sent by the specified user ID
     * @param senderId
     * @return List of sent messages
     */
    @GetMapping("/sent/{senderId}")
    public ResponseEntity<List<StudentMessageDto>> getSentMessages(@PathVariable Long senderId) {
        try {
            System.out.println("=== GET SENT MESSAGES DEBUG ===");
            System.out.println("Sender ID: " + senderId);
            
            List<StudentMessageDto> messages = messageService.getSentMessages(senderId);
            
            System.out.println("Found " + messages.size() + " sent messages");
            System.out.println("=== END GET SENT MESSAGES DEBUG ===");
            
            return ResponseEntity.ok(messages);
        } catch (Exception e) {
            System.err.println("Error getting sent messages: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.ok(java.util.Collections.emptyList());
        }
    }
    
    /**
     * Get messages sent by the current authenticated user
     * @param authentication
     * @return List of sent messages
     */
    @GetMapping("/sent/current")
    public ResponseEntity<List<StudentMessageDto>> getCurrentUserSentMessages(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseGet(() -> userRepository.findByEmail(username)
                            .orElseThrow(() -> new RuntimeException("User not found: " + username)));
            
            List<StudentMessageDto> messages = messageService.getSentMessages(currentUser.getId());
            return ResponseEntity.ok(messages);
        } catch (Exception e) {
            System.err.println("Error getting current user sent messages: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.ok(java.util.Collections.emptyList());
        }
    }
    
    /**
     * Get messages by sender ID (alternative endpoint for compatibility)
     * @param senderId
     * @return List of messages
     */
    @GetMapping("/by-sender/{senderId}")
    public ResponseEntity<List<StudentMessageDto>> getMessagesBySender(@PathVariable Long senderId) {
        return getSentMessages(senderId);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/StudentQuestionController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.StudentQuestionDto;
import com.classroomapp.classroombackend.service.StudentQuestionService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/questions")
@CrossOrigin(origins = "http://localhost:3000")
public class StudentQuestionController {
    
    @Autowired
    private StudentQuestionService questionService;
    
    // Create a new question
    @PostMapping
    public ResponseEntity<StudentQuestionDto> createQuestion(@Valid @RequestBody StudentQuestionDto questionDto) {
        try {
            StudentQuestionDto createdQuestion = questionService.createQuestion(questionDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdQuestion);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }
    
    // Get question by ID
    @GetMapping("/{questionId}")
    public ResponseEntity<StudentQuestionDto> getQuestionById(@PathVariable Long questionId) {
        try {
            StudentQuestionDto question = questionService.getQuestionById(questionId);
            return ResponseEntity.ok(question);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get questions by student
    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<StudentQuestionDto>> getQuestionsByStudent(@PathVariable Long studentId) {
        try {
            List<StudentQuestionDto> questions = questionService.getQuestionsByStudent(studentId);
            return ResponseEntity.ok(questions);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get questions by teacher
    @GetMapping("/teacher/{teacherId}")
    public ResponseEntity<List<StudentQuestionDto>> getQuestionsByTeacher(@PathVariable Long teacherId) {
        try {
            List<StudentQuestionDto> questions = questionService.getQuestionsByTeacher(teacherId);
            return ResponseEntity.ok(questions);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get pending questions for teacher
    @GetMapping("/teacher/{teacherId}/pending")
    public ResponseEntity<List<StudentQuestionDto>> getPendingQuestionsByTeacher(@PathVariable Long teacherId) {
        try {
            List<StudentQuestionDto> questions = questionService.getPendingQuestionsByTeacher(teacherId);
            return ResponseEntity.ok(questions);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Get questions by status
    @GetMapping("/status/{status}")
    public ResponseEntity<List<StudentQuestionDto>> getQuestionsByStatus(@PathVariable String status) {
        List<StudentQuestionDto> questions = questionService.getQuestionsByStatus(status);
        return ResponseEntity.ok(questions);
    }
    
    // Get questions by priority
    @GetMapping("/priority/{priority}")
    public ResponseEntity<List<StudentQuestionDto>> getQuestionsByPriority(@PathVariable String priority) {
        List<StudentQuestionDto> questions = questionService.getQuestionsByPriority(priority);
        return ResponseEntity.ok(questions);
    }
    
    // Get conversation between student and teacher
    @GetMapping("/conversation")
    public ResponseEntity<List<StudentQuestionDto>> getConversation(
            @RequestParam Long studentId, @RequestParam Long teacherId) {
        try {
            List<StudentQuestionDto> questions = questionService.getConversation(studentId, teacherId);
            return ResponseEntity.ok(questions);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Search questions
    @GetMapping("/search")
    public ResponseEntity<List<StudentQuestionDto>> searchQuestions(@RequestParam String keyword) {
        List<StudentQuestionDto> questions = questionService.searchQuestions(keyword);
        return ResponseEntity.ok(questions);
    }
    
    // Get recent questions
    @GetMapping("/recent")
    public ResponseEntity<List<StudentQuestionDto>> getRecentQuestions() {
        List<StudentQuestionDto> questions = questionService.getRecentQuestions();
        return ResponseEntity.ok(questions);
    }
    
    // Answer a question
    @PutMapping("/{questionId}/answer")
    public ResponseEntity<StudentQuestionDto> answerQuestion(
            @PathVariable Long questionId,
            @RequestParam String answer,
            @RequestParam Long teacherId) {
        try {
            StudentQuestionDto answeredQuestion = questionService.answerQuestion(questionId, answer, teacherId);
            return ResponseEntity.ok(answeredQuestion);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }
    
    // Close a question
    @PutMapping("/{questionId}/close")
    public ResponseEntity<StudentQuestionDto> closeQuestion(@PathVariable Long questionId) {
        try {
            StudentQuestionDto closedQuestion = questionService.closeQuestion(questionId);
            return ResponseEntity.ok(closedQuestion);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Update question priority
    @PutMapping("/{questionId}/priority")
    public ResponseEntity<StudentQuestionDto> updateQuestionPriority(
            @PathVariable Long questionId, @RequestParam String priority) {
        try {
            StudentQuestionDto updatedQuestion = questionService.updateQuestionPriority(questionId, priority);
            return ResponseEntity.ok(updatedQuestion);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Count pending questions for teacher
    @GetMapping("/teacher/{teacherId}/pending/count")
    public ResponseEntity<Long> countPendingQuestionsByTeacher(@PathVariable Long teacherId) {
        try {
            Long count = questionService.countPendingQuestionsByTeacher(teacherId);
            return ResponseEntity.ok(count);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
    
    // Delete a question
    @DeleteMapping("/{questionId}")
    public ResponseEntity<Void> deleteQuestion(@PathVariable Long questionId) {
        try {
            questionService.deleteQuestion(questionId);
            return ResponseEntity.noContent().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/SubmissionController.java">
package com.classroomapp.classroombackend.controller;

import java.security.Principal;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.SubmissionDto;
import com.classroomapp.classroombackend.service.SubmissionService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/submissions")
@RequiredArgsConstructor
public class SubmissionController {

    private final SubmissionService submissionService;
    
    @GetMapping("/{id}")
    public ResponseEntity<SubmissionDto> GetSubmissionById(@PathVariable Long id) {
        return ResponseEntity.ok(submissionService.GetSubmissionById(id));
    }

    /**
     * Creates or updates a submission for the current user.
     * This single endpoint handles both initial submissions and resubmissions.
     */
    @PostMapping
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<SubmissionDto> submitOrUpdateSubmission(
            @Valid @RequestBody CreateSubmissionDto createSubmissionDto,
            Principal principal) {
        return ResponseEntity.ok(submissionService.submit(createSubmissionDto, principal.getName()));
    }

    /**
     * @deprecated Use the main POST /api/submissions endpoint which now handles updates.
     */
    @Deprecated
    @PostMapping("/create") // Kept old method temporarily on a different path to avoid breaking changes
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<SubmissionDto> CreateSubmission(
            @Valid @RequestBody CreateSubmissionDto createSubmissionDto,
            Principal principal) {
        return new ResponseEntity<>(submissionService.CreateSubmission(createSubmissionDto, principal.getName()), 
                HttpStatus.CREATED);
    }

    /**
     * @deprecated Use the main POST /api/submissions endpoint which now handles updates.
     */
    @Deprecated
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('STUDENT')")
    public ResponseEntity<SubmissionDto> UpdateSubmission(
            @PathVariable Long id,
            @Valid @RequestBody CreateSubmissionDto updateSubmissionDto) {
        return ResponseEntity.ok(submissionService.UpdateSubmission(id, updateSubmissionDto));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> DeleteSubmission(@PathVariable Long id) {
        submissionService.DeleteSubmission(id);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/assignment/{assignmentId}")
    public ResponseEntity<List<SubmissionDto>> GetSubmissionsByAssignment(@PathVariable Long assignmentId) {
        return ResponseEntity.ok(submissionService.GetSubmissionsByAssignment(assignmentId));
    }
    
    @GetMapping("/student/{studentId}")
    public ResponseEntity<List<SubmissionDto>> GetSubmissionsByStudent(@PathVariable Long studentId) {
        return ResponseEntity.ok(submissionService.GetSubmissionsByStudent(studentId));
    }
    
    @GetMapping(value = "/assignment/{assignmentId}/student/{studentId}", produces = "application/json;charset=UTF-8")
    public ResponseEntity<SubmissionDto> GetStudentSubmissionForAssignment(
            @PathVariable Long assignmentId,
            @PathVariable Long studentId) {
        return ResponseEntity.ok(submissionService.GetStudentSubmissionForAssignment(assignmentId, studentId));
    }
    
    @PutMapping("/{submissionId}/grade")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<SubmissionDto> GradeSubmission(
            @PathVariable Long submissionId,
            @Valid @RequestBody GradeSubmissionDto gradeSubmissionDto,
            Principal principal) {
        return ResponseEntity.ok(submissionService.GradeSubmission(submissionId, gradeSubmissionDto, principal.getName()));
    }
    
    @GetMapping("/assignment/{assignmentId}/graded")
    public ResponseEntity<List<SubmissionDto>> GetGradedSubmissionsByAssignment(@PathVariable Long assignmentId) {
        return ResponseEntity.ok(submissionService.GetGradedSubmissionsByAssignment(assignmentId));
    }
    
    @GetMapping("/assignment/{assignmentId}/ungraded")
    public ResponseEntity<List<SubmissionDto>> GetUngradedSubmissionsByAssignment(@PathVariable Long assignmentId) {
        return ResponseEntity.ok(submissionService.GetUngradedSubmissionsByAssignment(assignmentId));
    }
    
    @GetMapping("/assignment/{assignmentId}/statistics")
    public ResponseEntity<SubmissionService.SubmissionStatistics> GetSubmissionStatisticsForAssignment(
            @PathVariable Long assignmentId) {
        return ResponseEntity.ok(submissionService.GetSubmissionStatisticsForAssignment(assignmentId));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/TeacherController.java">
package com.classroomapp.classroombackend.controller;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.ScheduleDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceSessionRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.ClassroomService;
import com.classroomapp.classroombackend.service.ScheduleService;

import lombok.RequiredArgsConstructor;

/**
 * Teacher-specific controller for teacher dashboard, schedule, and courses
 */
@RestController
@RequestMapping("/api/teacher")
@RequiredArgsConstructor
public class TeacherController {

    private final UserRepository userRepository;
    private final ClassroomService classroomService;
    private final AssignmentRepository assignmentRepository;
    private final SubmissionRepository submissionRepository;
    private final AttendanceSessionRepository attendanceSessionRepository;
    private final AttendanceRepository attendanceRepository;
    private final ScheduleService scheduleService;

    /**
     * Get teacher's schedule
     * Frontend calls: /teacher/schedule
     */
    @GetMapping("/schedules")
    public ResponseEntity<?> getTeacherSchedule(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Define a date range, e.g., the current month
            LocalDate today = LocalDate.now();
            LocalDate startDate = today.withDayOfMonth(1);
            LocalDate endDate = today.withDayOfMonth(today.lengthOfMonth());

            // Use the more efficient, date-ranged query
            List<TimetableEventDto> schedules = scheduleService.getTimetableForUser(currentUser.getId(), startDate, endDate);
            
            return ResponseEntity.ok(schedules);
            
        } catch (Exception e) {
            System.err.println("Error in getTeacherSchedule: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
        }
    }
    
    /**
     * Get teacher's schedule by day
     * Frontend calls: /teacher/schedule/day/{dayOfWeek}
     */
    @GetMapping("/schedule/day/{dayOfWeek}")
    public ResponseEntity<?> getTeacherScheduleByDay(
            Authentication authentication,
            @PathVariable Integer dayOfWeek) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Validate day of week
            if (dayOfWeek < 0 || dayOfWeek > 6) {
                return ResponseEntity.badRequest().body("Day of week must be between 0 and 6");
            }
            
            // Get schedules for teacher and day
            List<ScheduleDto> schedules = scheduleService.getSchedulesByTeacherAndDay(
                    currentUser.getId(), dayOfWeek);
            
            return ResponseEntity.ok(schedules);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
        }
    }
    
    /**
     * Create a new schedule entry
     * Frontend calls: POST /teacher/schedule
     */
    @PostMapping("/schedule")
    public ResponseEntity<?> createSchedule(
            Authentication authentication,
            @RequestBody ScheduleDto scheduleDto) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Ensure the teacher ID is set to the current user
            scheduleDto.setTeacherId(currentUser.getId());
            
            // Create schedule
            ScheduleDto createdSchedule = scheduleService.createScheduleEntry(scheduleDto);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(createdSchedule);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
        }
    }

    /**
     * Get teacher's courses
     * Frontend calls: /teacher/courses
     */
    @GetMapping("/courses")
    public ResponseEntity<List<ClassroomDto>> getTeacherCourses(Authentication authentication) {
        try {
            String username = authentication.getName();
            User currentUser = userRepository.findByUsername(username)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
            
            // Use existing classroom service
            List<ClassroomDto> courses = classroomService.GetClassroomsByTeacher(currentUser.getId());
            return ResponseEntity.ok(courses);
            
        } catch (Exception e) {
            // Return empty list if error
            return ResponseEntity.ok(new ArrayList<>());
        }
    }

    /**
     * Get teacher dashboard stats
     * Frontend calls: /teacher/dashboard-stats
     */
    @GetMapping("/dashboard-stats")
    public ResponseEntity<Map<String, Object>> getTeacherDashboardStats(Authentication authentication) {
        try {
            String email = authentication.getName();
            
            // First try to find by email since authentication.getName() returns email in this context
            User currentUser = userRepository.findByEmail(email)
                    .orElseGet(() -> userRepository.findByUsername(email)
                                     .orElseThrow(() -> new ResourceNotFoundException("User not found with email/username: " + email)));
                                     
            long teacherId = currentUser.getId();
            
            // Get teacher's classrooms
            List<ClassroomDto> classrooms = classroomService.GetClassroomsByTeacher(teacherId);
            List<Long> classroomIds = classrooms.stream().map(ClassroomDto::getId).collect(Collectors.toList());
            
            long totalStudents = 0;
            long totalAssignments = 0;
            long pendingGrading = 0;
            long graded = 0;
            long totalAttendanceSessions = 0;
            Double averageAttendance = 0.0;

            if (!classroomIds.isEmpty()) {
                totalStudents = userRepository.countStudentsByClassroomIds(classroomIds);
                totalAssignments = assignmentRepository.countByClassroomIdIn(classroomIds);
                pendingGrading = submissionRepository.countPendingSubmissionsByClassroomIds(classroomIds);
                graded = submissionRepository.countGradedSubmissionsByClassroomIds(classroomIds);
                totalAttendanceSessions = attendanceSessionRepository.countByClassroomIdIn(classroomIds);
                averageAttendance = attendanceRepository.getAverageAttendanceByClassroomIds(classroomIds);
            }

            // Calculate stats
            Map<String, Object> stats = new HashMap<>();
            
            Map<String, Object> classStats = new HashMap<>();
            classStats.put("totalClasses", classrooms.size());
            classStats.put("activeClasses", classrooms.size()); 
            classStats.put("totalStudents", totalStudents);
            
            Map<String, Object> assignmentStats = new HashMap<>();
            assignmentStats.put("totalAssignments", totalAssignments);
            assignmentStats.put("pendingGrading", pendingGrading);

            assignmentStats.put("graded", graded);
            
            Map<String, Object> attendanceStats = new HashMap<>();
            attendanceStats.put("totalSessions", totalAttendanceSessions);
            averageAttendance = (averageAttendance != null) ? Math.round(averageAttendance * 10.0) / 10.0 : 0.0;
            attendanceStats.put("averageAttendance", averageAttendance);
            
            stats.put("classStats", classStats);
            stats.put("assignmentStats", assignmentStats);
            stats.put("attendanceStats", attendanceStats);
            
            return ResponseEntity.ok(stats);
            
        } catch (Exception e) {
            // Log the exception for debugging purposes
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Failed to retrieve dashboard stats: " + e.getMessage()));
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/TestController.java">
package com.classroomapp.classroombackend.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.security.CustomUserDetails;
import com.classroomapp.classroombackend.security.JwtUtil;
import com.classroomapp.classroombackend.service.AssignmentService;
import com.classroomapp.classroombackend.service.ClassroomService;

import jakarta.servlet.http.HttpServletRequest;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = {"http://localhost:3000", "http://localhost:3001"}, allowCredentials = "true")
public class TestController {

    @Autowired
    private ClassroomService classroomService;

    @Autowired
    private AssignmentService assignmentService;

    @Autowired
    private JwtUtil jwtUtil;

    @GetMapping("/test")
    public ResponseEntity<Map<String, Object>> testEndpoint() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "API is working!");
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cors-test")
    public ResponseEntity<String> testCors(@RequestBody(required = false) String body) {
        return ResponseEntity.ok("CORS test successful. Received: " + body);
    }
    
    @GetMapping("/debug/teacher/{teacherId}")
    public ResponseEntity<Map<String, Object>> debugTeacherData(@PathVariable Long teacherId) {
        Map<String, Object> response = new HashMap<>();

        try {
            List<ClassroomDto> classrooms = classroomService.GetClassroomsByTeacher(teacherId);
            List<AssignmentDto> assignments = assignmentService.getAssignmentsByTeacher(teacherId);

            response.put("teacherId", teacherId);
            response.put("classrooms", classrooms);
            response.put("assignments", assignments);
            response.put("classroomCount", classrooms.size());
            response.put("assignmentCount", assignments.size());
            response.put("status", "success");
        } catch (Exception e) {
            response.put("error", e.getMessage());
            response.put("status", "error");
        }

        return ResponseEntity.ok(response);
    }

    @GetMapping("/debug/auth")
    public ResponseEntity<Map<String, Object>> debugAuthentication(Authentication authentication, HttpServletRequest request) {
        Map<String, Object> response = new HashMap<>();

        try {
            // Basic authentication info
            response.put("isAuthenticated", authentication != null && authentication.isAuthenticated());
            response.put("principal", authentication != null ? authentication.getName() : null);
            response.put("authorities", authentication != null ?
                authentication.getAuthorities().stream()
                    .map(auth -> auth.getAuthority())
                    .collect(java.util.stream.Collectors.toList()) : null);

            // JWT token info
            String authHeader = request.getHeader("Authorization");
            response.put("authHeader", authHeader);
            response.put("hasBearer", authHeader != null && authHeader.startsWith("Bearer "));

            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                response.put("tokenLength", token.length());
                response.put("tokenValid", jwtUtil.validateToken(token));
                response.put("tokenSubject", jwtUtil.getSubjectFromToken(token));
                response.put("tokenRole", jwtUtil.getRoleFromToken(token));
            }

            // User details if available
            if (authentication != null && authentication.getPrincipal() instanceof CustomUserDetails) {
                CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
                response.put("userId", userDetails.getId());
                response.put("userEmail", userDetails.getUser().getEmail());
                response.put("userRoleId", userDetails.getUser().getRoleId());
                response.put("userRole", userDetails.getUser().getRole());
            }

            response.put("status", "success");
        } catch (Exception e) {
            response.put("error", e.getMessage());
            response.put("status", "error");
        }

        return ResponseEntity.ok(response);
    }

}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/TimetableController.java">
package com.classroomapp.classroombackend.controller;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.CreateEventDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;
import com.classroomapp.classroombackend.service.TimetableService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/timetable")
@RequiredArgsConstructor
public class TimetableController {

    private final TimetableService timetableService;

    // Root endpoint for timetable view
    @GetMapping
    public ResponseEntity<List<TimetableEventDto>> getTimetable(
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate,
            @RequestParam(required = false, defaultValue = "month") String view) {
        
        LocalDate start = startDate != null ? LocalDate.parse(startDate) : LocalDate.now().withDayOfMonth(1);
        LocalDate end = endDate != null ? LocalDate.parse(endDate) : start.plusMonths(1).minusDays(1);
        
        // Convert to LocalDateTime for service
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        // Use the service to get real data
        List<TimetableEventDto> events = timetableService.getEventsByDateRange(startDateTime, endDateTime);
        return ResponseEntity.ok(events);
    }

    // Get user's timetable
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<TimetableEventDto>> getUserTimetable(
            @PathVariable Long userId,
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate) {
        
        LocalDate start = startDate != null ? LocalDate.parse(startDate) : LocalDate.now().withDayOfMonth(1);
        LocalDate end = endDate != null ? LocalDate.parse(endDate) : start.plusMonths(1).minusDays(1);
        
        // Convert to LocalDateTime for service
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        // In a real implementation, we would get the classrooms for the user and fetch events
        // For now, just get all events
        List<TimetableEventDto> events = timetableService.getEventsByDateRange(startDateTime, endDateTime);
        return ResponseEntity.ok(events);
    }
    
    // Get timetable for the current authenticated user
    @GetMapping("/my-timetable")
    public ResponseEntity<List<TimetableEventDto>> getMyTimetable(
            Authentication authentication,
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate) {

        System.out.println("📅 TimetableController.getMyTimetable: Request received");
        System.out.println("   Authentication: " + (authentication != null ? authentication.getName() : "null"));
        System.out.println("   Start Date: " + startDate);
        System.out.println("   End Date: " + endDate);

        if (authentication == null) {
            System.out.println("❌ TimetableController.getMyTimetable: No authentication provided");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        try {
            // Get user ID from authentication
            String username = authentication.getName();
            System.out.println("📅 TimetableController.getMyTimetable: Username from auth: " + username);

            // For now, use a default user ID since we don't have UserRepository injected
            // TODO: Inject UserRepository and get actual user ID
            Long userId = 1L; // Default to student user

            LocalDate start = startDate != null ? LocalDate.parse(startDate) : LocalDate.now().withDayOfMonth(1);
            LocalDate end = endDate != null ? LocalDate.parse(endDate) : start.plusMonths(1).minusDays(1);

            System.out.println("📅 TimetableController.getMyTimetable: Date range: " + start + " to " + end);
            System.out.println("📅 TimetableController.getMyTimetable: Getting events for user ID: " + userId);

            // Convert to LocalDateTime for service
            LocalDateTime startDateTime = start.atStartOfDay();
            LocalDateTime endDateTime = end.atTime(23, 59, 59);

            // Get events for the authenticated user using the new method
            List<TimetableEventDto> events = timetableService.getEventsForUser(userId, startDateTime, endDateTime);
            System.out.println("📅 TimetableController.getMyTimetable: Found " + events.size() + " events for user");

            return ResponseEntity.ok(events);
        } catch (Exception e) {
            System.out.println("❌ TimetableController.getMyTimetable: Error - " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    // Get weekly timetable
    @GetMapping("/user/{userId}/week")
    public ResponseEntity<List<TimetableEventDto>> getWeeklyTimetable(
            @PathVariable Long userId,
            @RequestParam LocalDate startDate) {
        
        LocalDate endDate = startDate.plusDays(6);
        
        // Convert to LocalDateTime for service
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);
        
        List<TimetableEventDto> events = timetableService.getEventsByDateRange(startDateTime, endDateTime);
        return ResponseEntity.ok(events);
    }
    
    // Get daily timetable
    @GetMapping("/user/{userId}/day")
    public ResponseEntity<List<TimetableEventDto>> getDailyTimetable(
            @PathVariable Long userId,
            @RequestParam LocalDate date) {
        
        // Convert to LocalDateTime for service
        LocalDateTime startDateTime = date.atStartOfDay();
        LocalDateTime endDateTime = date.atTime(23, 59, 59);
        
        List<TimetableEventDto> events = timetableService.getEventsByDateRange(startDateTime, endDateTime);
        return ResponseEntity.ok(events);
    }
    
    // Get upcoming events
    @GetMapping("/upcoming")
    public ResponseEntity<List<TimetableEventDto>> getUpcomingEvents() {
        List<TimetableEventDto> events = timetableService.getUpcomingEvents(null);
        return ResponseEntity.ok(events);
    }
    
    // Create event
    @PostMapping("/events")
    public ResponseEntity<TimetableEventDto> createEvent(
            @Valid @RequestBody CreateEventDto createEventDto,
            Authentication authentication) {
        
        if (authentication == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        // In a real implementation, we would get the current user ID from the authentication
        // For now, use a placeholder user ID
        Long createdBy = 1L;
        
        TimetableEventDto createdEvent = timetableService.createEvent(createEventDto, createdBy);
        return new ResponseEntity<>(createdEvent, HttpStatus.CREATED);
    }
    
    // Update event
    @PutMapping("/events/{eventId}")
    public ResponseEntity<TimetableEventDto> updateEvent(
            @PathVariable Long eventId,
            @Valid @RequestBody CreateEventDto updateEventDto) {
        
        TimetableEventDto updatedEvent = timetableService.updateEvent(eventId, updateEventDto);
        return ResponseEntity.ok(updatedEvent);
    }
    
    // Delete event
    @DeleteMapping("/events/{eventId}")
    public ResponseEntity<Void> deleteEvent(@PathVariable Long eventId) {
        timetableService.deleteEvent(eventId);
        return ResponseEntity.noContent().build();
    }
    
    // Get event by ID
    @GetMapping("/events/{eventId}")
    public ResponseEntity<TimetableEventDto> getEventById(@PathVariable Long eventId) {
        TimetableEventDto event = timetableService.getEventById(eventId);
        return ResponseEntity.ok(event);
    }
    
    // Add test data (temporary endpoint)
    @GetMapping("/test-data")
    public ResponseEntity<String> addTestData() {
        try {
            // Sample timetable events for June 2025
            LocalDateTime now = LocalDateTime.now();
            int currentYear = now.getYear();
            int currentMonth = now.getMonthValue();
            
            // Create a math class event
            CreateEventDto mathClass = new CreateEventDto();
            mathClass.setTitle("Math Class");
            mathClass.setDescription("Regular math class for first-year students");
            mathClass.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, 15, 9, 0));
            mathClass.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, 15, 10, 30));
            mathClass.setEventType("CLASS");
            mathClass.setClassroomId(1L);
            mathClass.setLocation("Room 101");
            mathClass.setIsAllDay(false);
            mathClass.setColor("#007bff");
            timetableService.createEvent(mathClass, 1L);
            
            // Create a history exam event
            CreateEventDto historyExam = new CreateEventDto();
            historyExam.setTitle("History Exam");
            historyExam.setDescription("Mid-term history exam");
            historyExam.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, 17, 13, 0));
            historyExam.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, 17, 15, 0));
            historyExam.setEventType("EXAM");
            historyExam.setClassroomId(1L);
            historyExam.setLocation("Exam Hall A");
            historyExam.setIsAllDay(false);
            historyExam.setColor("#dc3545");
            timetableService.createEvent(historyExam, 1L);
            
            // Create a science project meeting event
            CreateEventDto scienceMeeting = new CreateEventDto();
            scienceMeeting.setTitle("Science Project Meeting");
            scienceMeeting.setDescription("Meeting to discuss science project progress");
            scienceMeeting.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, 19, 14, 0));
            scienceMeeting.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, 19, 15, 30));
            scienceMeeting.setEventType("MEETING");
            scienceMeeting.setClassroomId(2L);
            scienceMeeting.setLocation("Room 202");
            scienceMeeting.setIsAllDay(false);
            scienceMeeting.setColor("#28a745");
            timetableService.createEvent(scienceMeeting, 2L);
            
            // Create a literature assignment due event
            CreateEventDto literatureAssignment = new CreateEventDto();
            literatureAssignment.setTitle("Literature Assignment Due");
            literatureAssignment.setDescription("Submit literature essay");
            literatureAssignment.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, 20, 23, 59));
            literatureAssignment.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, 20, 23, 59));
            literatureAssignment.setEventType("ASSIGNMENT_DUE");
            literatureAssignment.setClassroomId(3L);
            literatureAssignment.setIsAllDay(true);
            literatureAssignment.setColor("#ffc107");
            timetableService.createEvent(literatureAssignment, 3L);
            
            // Create a holiday event
            CreateEventDto holiday = new CreateEventDto();
            holiday.setTitle("School Holiday");
            holiday.setDescription("National holiday - no classes");
            holiday.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, 22, 0, 0));
            holiday.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, 22, 23, 59));
            holiday.setEventType("HOLIDAY");
            holiday.setIsAllDay(true);
            holiday.setColor("#6c757d");
            timetableService.createEvent(holiday, 1L);
            
            return ResponseEntity.ok("Test data added successfully");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error adding test data: " + e.getMessage());
        }
    }

    // Get events for a classroom
    @GetMapping("/classroom/{classroomId}")
    public ResponseEntity<List<TimetableEventDto>> getClassroomEvents(
            @PathVariable Long classroomId,
            @RequestParam(required = false) String startDate,
            @RequestParam(required = false) String endDate) {
        
        LocalDate start = startDate != null ? LocalDate.parse(startDate) : LocalDate.now().withDayOfMonth(1);
        LocalDate end = endDate != null ? LocalDate.parse(endDate) : start.plusMonths(1).minusDays(1);
        
        // Convert to LocalDateTime for service
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        List<TimetableEventDto> events = timetableService.getEventsByClassroomAndDateRange(
                classroomId, startDateTime, endDateTime);
        return ResponseEntity.ok(events);
    }
    
    // Create sample data for a specific classroom
    @PostMapping("/create-sample-data/{classroomId}")
    public ResponseEntity<String> createSampleDataForClassroom(@PathVariable Long classroomId) {
        try {
            // Lấy thời gian hiện tại
            LocalDateTime now = LocalDateTime.now();
            int currentYear = now.getYear();
            int currentMonth = now.getMonthValue();
            int currentDay = now.getDayOfMonth();
            
            // Tạo lịch học trong tuần hiện tại và tuần tiếp theo
            
            // Buổi học lý thuyết
            CreateEventDto theoryClass = new CreateEventDto();
            theoryClass.setTitle("Bài giảng lý thuyết");
            theoryClass.setDescription("Giới thiệu các khái niệm cơ bản và lý thuyết nền tảng");
            theoryClass.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay, 8, 0));
            theoryClass.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay, 9, 30));
            theoryClass.setEventType("CLASS");
            theoryClass.setClassroomId(classroomId);
            theoryClass.setLocation("Phòng học 101");
            theoryClass.setIsAllDay(false);
            theoryClass.setColor("#007bff");
            timetableService.createEvent(theoryClass, 1L);
            
            // Buổi thực hành
            CreateEventDto practiceClass = new CreateEventDto();
            practiceClass.setTitle("Buổi thực hành");
            practiceClass.setDescription("Áp dụng kiến thức lý thuyết vào bài tập thực hành");
            practiceClass.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 2, 13, 0));
            practiceClass.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 2, 15, 30));
            practiceClass.setEventType("CLASS");
            practiceClass.setClassroomId(classroomId);
            practiceClass.setLocation("Phòng thực hành 202");
            practiceClass.setIsAllDay(false);
            practiceClass.setColor("#28a745");
            timetableService.createEvent(practiceClass, 1L);
            
            // Bài kiểm tra
            CreateEventDto examEvent = new CreateEventDto();
            examEvent.setTitle("Bài kiểm tra giữa kỳ");
            examEvent.setDescription("Kiểm tra kiến thức đã học trong nửa đầu khóa học");
            examEvent.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 7, 10, 0));
            examEvent.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 7, 11, 30));
            examEvent.setEventType("EXAM");
            examEvent.setClassroomId(classroomId);
            examEvent.setLocation("Phòng thi A");
            examEvent.setIsAllDay(false);
            examEvent.setColor("#dc3545");
            timetableService.createEvent(examEvent, 1L);
            
            // Hạn nộp bài tập
            CreateEventDto assignmentDue = new CreateEventDto();
            assignmentDue.setTitle("Hạn nộp bài tập lớn");
            assignmentDue.setDescription("Nộp báo cáo và mã nguồn của dự án");
            assignmentDue.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 10, 23, 59));
            assignmentDue.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 10, 23, 59));
            assignmentDue.setEventType("ASSIGNMENT_DUE");
            assignmentDue.setClassroomId(classroomId);
            assignmentDue.setIsAllDay(true);
            assignmentDue.setColor("#ffc107");
            timetableService.createEvent(assignmentDue, 1L);
            
            // Buổi hỏi đáp
            CreateEventDto meetingEvent = new CreateEventDto();
            meetingEvent.setTitle("Buổi hỏi đáp");
            meetingEvent.setDescription("Giải đáp thắc mắc và chuẩn bị cho kỳ thi cuối kỳ");
            meetingEvent.setStartDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 14, 15, 0));
            meetingEvent.setEndDatetime(LocalDateTime.of(currentYear, currentMonth, currentDay + 14, 16, 30));
            meetingEvent.setEventType("MEETING");
            meetingEvent.setClassroomId(classroomId);
            meetingEvent.setLocation("Phòng họp trực tuyến");
            meetingEvent.setIsAllDay(false);
            meetingEvent.setColor("#6f42c1");
            timetableService.createEvent(meetingEvent, 1L);
            
            return ResponseEntity.ok("Đã tạo dữ liệu lịch học mẫu thành công");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Lỗi khi tạo dữ liệu mẫu: " + e.getMessage());
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/UserController.java">
package com.classroomapp.classroombackend.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.dto.usermanagement.UserMapper;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.security.CustomUserDetails;
import com.classroomapp.classroombackend.service.UserService;

@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = {"http://localhost:3000", "http://localhost:3001"}, allowCredentials = "true")
public class UserController {
    
    private static final Logger logger = Logger.getLogger(UserController.class.getName());
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    /**
     * Get current user's profile.
     * This is the single authoritative endpoint for fetching the logged-in user's profile.
     * @return UserDto of the current user
     */
    @GetMapping("/me")
    public ResponseEntity<UserDto> getCurrentUserProfile() {
        try {
            Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

            if (principal == null) {
                logger.severe("Principal is null. User is likely not authenticated.");
                return ResponseEntity.status(401).build(); // Unauthorized
            }
            
            // Log principal type for diagnostic purposes
            logger.info("Principal class: " + (principal != null ? principal.getClass().getName() : "null"));
            
            if (principal instanceof CustomUserDetails) {
                // Use our custom UserDetails which has direct access to the User entity
                CustomUserDetails userDetails = (CustomUserDetails) principal;
                User user = userDetails.getUser();
                logger.info("Fetching profile for current user (CustomUserDetails): " + user.getEmail());
                UserDto userDto = UserMapper.toDto(user);
                return ResponseEntity.ok(userDto);
            } else if (principal instanceof UserDetails) {
                // Handle standard UserDetails - the username is actually the email in our system
                String email = ((UserDetails) principal).getUsername();
                logger.info("Fetching profile for current user (UserDetails): " + email);
                
                // Find user by email
                User user = userService.findUserEntityByEmail(email);
                if (user == null) {
                    logger.severe("User not found with email: " + email);
                    return ResponseEntity.status(404).build();
                }
                
                UserDto userDto = UserMapper.toDto(user);
                return ResponseEntity.ok(userDto);
            } else {
                // Fallback to string representation
                String username = principal.toString();
                logger.info("Fetching profile for current user (fallback): " + username);
                
                // Try to find by email first
                User user = userService.findUserEntityByEmail(username);
                if (user != null) {
                    logger.info("Found user by email: " + username);
                    UserDto userDto = UserMapper.toDto(user);
                    return ResponseEntity.ok(userDto);
                }
                
                // Fall back to username search
                logger.info("Attempting to find by username: " + username);
                UserDto userDto = userService.FindUserByUsername(username);
                return ResponseEntity.ok(userDto);
            }
        } catch (Exception e) {
            logger.severe("Error retrieving current user profile: " + e.getMessage());
            e.printStackTrace(); // Log stack trace for better debugging
            return ResponseEntity.status(500).build();
        }
    }
    
    /**
     * Update current user profile (mock implementation)
     * @param profileData updated profile data
     * @return updated profile response
     */
    @PutMapping("/me")
    public ResponseEntity<Map<String, Object>> updateCurrentUser(@RequestBody Map<String, Object> profileData) {
        try {
            // Mock update - in real implementation, you would update the actual user
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("data", profileData);
            response.put("message", "Profile updated successfully");
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("success", false);
            errorResponse.put("message", "Error updating profile: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    /**
     * Get all users
     * @return list of all users
     */
    @GetMapping
    public ResponseEntity<List<UserDto>> getUsers() {
        // This endpoint should be replaced by the one in AdminController
        // Returning what the old service method returns to maintain some functionality.
        return ResponseEntity.ok(userService.FindAllUsers());
    }

    /**
     * Get user by ID
     * @param id user ID
     * @return user with specified ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        // This endpoint should be replaced by AdminController or a /me endpoint
        return ResponseEntity.ok(userService.FindUserById(id));
    }

    /**
     * Get users by role ID
     * @param roleId role ID (1=STUDENT, 2=TEACHER, 3=MANAGER, 0=ADMIN)
     * @return list of users with specified role
     */
    @GetMapping("/role/{roleId}")
    public ResponseEntity<List<UserDto>> getUsersByRole(@PathVariable Long roleId) {
        // This method is likely broken due to Role entity changes.
        // Returning what the old service method returns to maintain some functionality.
        return ResponseEntity.ok(userService.FindUsersByRole(roleId.intValue()));
    }

    // Removed duplicate endpoint - now handled by FrontendApiBridgeController
    // @GetMapping("/teachers")
    // public ResponseEntity<List<UserDto>> getTeachers() {
    //     // Role 2 corresponds to TEACHER
    //     return ResponseEntity.ok(userService.FindUsersByRole(2));
    // }

    /**
     * Delete user
     * @param id user ID
     * @return no content response
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.DeleteUser(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/search")
    public List<UserDto> searchUsers(@RequestParam String keyword) {
        // This should use the new service method with pagination
        // For now, returning empty list.
        return new ArrayList<>();
    }

    public ResponseEntity<List<UserDto>> getAllUsers() {
        List<UserDto> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/UTF8TestController.java">
package com.classroomapp.classroombackend.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.config.UTF8EncodingFixer;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;

import lombok.extern.slf4j.Slf4j;

/**
 * Controller để kiểm tra và sửa lỗi UTF-8 encoding
 */
@RestController
@RequestMapping("/api/admin/utf8")
@Slf4j
public class UTF8TestController {

    @Autowired
    private SubmissionRepository submissionRepository;
    
    @Autowired
    private UTF8EncodingFixer utf8EncodingFixer;

    /**
     * Kiểm tra trạng thái encoding của submission feedback
     */
    @GetMapping("/check-submissions")
    public ResponseEntity<Map<String, Object>> checkSubmissionsEncoding() {
        log.info("Checking UTF-8 encoding for submissions...");
        
        List<Submission> submissions = submissionRepository.findAll();
        Map<String, Object> result = new HashMap<>();
        
        int totalSubmissions = submissions.size();
        int withFeedback = 0;
        int problematicFeedback = 0;
        
        for (Submission submission : submissions) {
            if (submission.getFeedback() != null && !submission.getFeedback().isEmpty()) {
                withFeedback++;
                
                // Check for encoding issues
                String feedback = submission.getFeedback();
                if (feedback.contains("?") || feedback.contains(" ") || 
                    hasEncodingIssues(feedback)) {
                    problematicFeedback++;
                    log.warn("Submission ID {} has encoding issues: {}", 
                            submission.getId(), feedback);
                }
            }
        }
        
        result.put("totalSubmissions", totalSubmissions);
        result.put("submissionsWithFeedback", withFeedback);
        result.put("problematicFeedback", problematicFeedback);
        result.put("encodingHealthy", problematicFeedback == 0);
        
        return ResponseEntity.ok(result);
    }

    /**
     * Test encoding với text cụ thể
     */
    @GetMapping("/test-text")
    public ResponseEntity<Map<String, String>> testTextEncoding(
            @RequestParam String text) {
        
        Map<String, String> result = new HashMap<>();
        result.put("original", text);
        result.put("hasVietnameseChars", String.valueOf(containsVietnameseCharacters(text)));
        result.put("hasEncodingIssues", String.valueOf(hasEncodingIssues(text)));
        
        // Test different encodings
        try {
            byte[] iso88591Bytes = text.getBytes("ISO-8859-1");
            String utf8FromIso = new String(iso88591Bytes, "UTF-8");
            result.put("iso88591ToUtf8", utf8FromIso);
        } catch (Exception e) {
            result.put("iso88591ToUtf8", "Error: " + e.getMessage());
        }
        
        try {
            byte[] windowsBytes = text.getBytes("windows-1252");
            String utf8FromWindows = new String(windowsBytes, "UTF-8");
            result.put("windows1252ToUtf8", utf8FromWindows);
        } catch (Exception e) {
            result.put("windows1252ToUtf8", "Error: " + e.getMessage());
        }
        
        return ResponseEntity.ok(result);
    }

    /**
     * Chạy test encoding
     */
    @PostMapping("/run-encoding-test")
    public ResponseEntity<String> runEncodingTest() {
        utf8EncodingFixer.testEncoding();
        return ResponseEntity.ok("Encoding test completed. Check logs for results.");
    }

    /**
     * Tạo dữ liệu test với tiếng Việt
     */
    @PostMapping("/create-test-feedback")
    public ResponseEntity<Map<String, Object>> createTestFeedback() {
        String[] vietnameseFeedbacks = {
            "Làm rất tốt! Bài làm chi tiết và đầy đủ.",
            "Xuất sắc! ERD thiết kế chính xác, SQL viết đúng chuẩn.",
            "Tốt! Bài làm đạt yêu cầu, thiết kế CSDL hợp lý.",
            "Khá! Nắm được kiến thức cơ bản về thiết kế CSDL.",
            "Cần cải thiện! Bài làm chưa đạt yêu cầu tối thiểu."
        };
        
        Map<String, Object> result = new HashMap<>();
        result.put("message", "Created test feedback data");
        result.put("testFeedbacks", vietnameseFeedbacks);
        
        // Log the feedbacks to check console encoding
        for (String feedback : vietnameseFeedbacks) {
            log.info("Test feedback: {}", feedback);
        }
        
        return ResponseEntity.ok(result);
    }

    private boolean hasEncodingIssues(String text) {
        if (text == null) return false;
        
        // Common signs of encoding issues
        return text.contains("?") || 
               text.contains(" ") || 
               text.contains("??t") || // "rất" becomes "r??t"
               text.contains("??ng") || // "đúng" becomes "??ng" 
               text.contains("??y") ||  // "đầy" becomes "??y"
               text.contains("?i?t");   // "điểm" becomes "?i?t"
    }

    private boolean containsVietnameseCharacters(String text) {
        if (text == null) return false;
        
        String vietnamese = "àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđ" +
                           "ÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸĐ";
        
        return text.chars().anyMatch(c -> vietnamese.indexOf(c) >= 0);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/VideoConferenceController.java">
package com.classroomapp.classroombackend.controller;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.service.ClassroomService;

/**
 * Video Conference Controller
 * Handles video conference room creation and management
 */
@RestController
@RequestMapping("/api/video-conference")
@CrossOrigin(origins = "*")
public class VideoConferenceController {
    
    @Autowired
    private ClassroomService classroomService;
    
    /**
     * Get all available classrooms for video conference
     */
    @GetMapping("/rooms")
    public ResponseEntity<List<ClassroomDto>> getAvailableRooms() {
        try {
            List<ClassroomDto> classrooms = classroomService.getAllClassrooms();
            return ResponseEntity.ok(classrooms);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    /**
     * Get classroom details for video conference
     */
    @GetMapping("/rooms/{classroomId}")
    public ResponseEntity<ClassroomDto> getClassroomForConference(@PathVariable Long classroomId) {
        try {
            ClassroomDto classroom = classroomService.getClassroomById(classroomId);
            if (classroom != null) {
                return ResponseEntity.ok(classroom);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    /**
     * Create a video conference session for a classroom
     */
    @PostMapping("/rooms/{classroomId}/start")
    public ResponseEntity<Map<String, Object>> startConference(@PathVariable Long classroomId, @RequestBody Map<String, Object> sessionData) {
        try {
            ClassroomDto classroom = classroomService.getClassroomById(classroomId);
            if (classroom == null) {
                return ResponseEntity.notFound().build();
            }
            
            // Create conference session data
            Map<String, Object> conferenceSession = Map.of(
                "roomId", "classroom_" + classroomId,
                "classroomId", classroomId,
                "classroomName", classroom.getName(),
                "signalingUrl", "ws://localhost:8080/signaling",
                "status", "active",
                "startedAt", System.currentTimeMillis()
            );
            
            return ResponseEntity.ok(conferenceSession);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    /**
     * End a video conference session
     */
    @PostMapping("/rooms/{classroomId}/end")
    public ResponseEntity<Map<String, String>> endConference(@PathVariable Long classroomId) {
        try {
            // Log conference end
            return ResponseEntity.ok(Map.of(
                "status", "ended",
                "message", "Conference ended successfully"
            ));
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    /**
     * Get conference status for a classroom
     */
    @GetMapping("/rooms/{classroomId}/status")
    public ResponseEntity<Map<String, Object>> getConferenceStatus(@PathVariable Long classroomId) {
        try {
            // In a real implementation, you would check actual conference status
            Map<String, Object> status = Map.of(
                "classroomId", classroomId,
                "isActive", false, // This would be checked against actual sessions
                "participantCount", 0
            );
            
            return ResponseEntity.ok(status);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/controller/VietnameseSpeechRecognitionController.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/debug/GradingWorkflowDebugger.java">
package com.classroomapp.classroombackend.debug;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;

@Component
public class GradingWorkflowDebugger {

    @Autowired
    private AssignmentRepository assignmentRepository;
    
    @Autowired
    private SubmissionRepository submissionRepository;

    public void generateGradingReport(Long classroomId) {
        System.out.println("\n" + "=".repeat(80));
        System.out.println("📊 BÁO CÁO TÌNH TRẠNG CHẤM ĐIỂM - CLASSROOM " + classroomId);
        System.out.println("=".repeat(80));
        System.out.println("⏰ Thời gian tạo báo cáo: " + LocalDateTime.now());
        System.out.println();

        List<Assignment> assignments = assignmentRepository.findByClassroomId(classroomId);
        
        if (assignments.isEmpty()) {
            System.out.println("⚠️  Không có assignment nào trong classroom này!");
            return;
        }

        for (Assignment assignment : assignments) {
            generateAssignmentReport(assignment);
        }

        generateSummaryReport(classroomId);
    }

    private void generateAssignmentReport(Assignment assignment) {
        System.out.println("📝 ASSIGNMENT: " + assignment.getTitle());
        System.out.println("   ├── ID: " + assignment.getId());
        System.out.println("   ├── Due Date: " + assignment.getDueDate());
        System.out.println("   ├── Points: " + assignment.getPoints());
        
        List<Submission> submissions = submissionRepository.findByAssignmentId(assignment.getId());
        
        if (submissions.isEmpty()) {
            System.out.println("   └── ❌ Chưa có sinh viên nào nộp bài");
            System.out.println();
            return;
        }

        // Thống kê theo trạng thái
        Map<String, Long> statusCount = submissions.stream()
            .collect(Collectors.groupingBy(this::getSubmissionStatus, Collectors.counting()));

        System.out.println("   ├── 📊 THỐNG KÊ SUBMISSIONS:");
        System.out.println("   │   ├── Tổng số bài nộp: " + submissions.size());
        System.out.println("   │   ├── Đã chấm điểm: " + statusCount.getOrDefault("GRADED", 0L));
        System.out.println("   │   ├── Chờ chấm điểm: " + statusCount.getOrDefault("SUBMITTED", 0L));
        System.out.println("   │   ├── Nộp muộn: " + statusCount.getOrDefault("LATE", 0L));
        System.out.println("   │   └── Chưa nộp: " + statusCount.getOrDefault("NOT_SUBMITTED", 0L));

        // Thống kê điểm số
        List<Submission> gradedSubmissions = submissions.stream()
            .filter(s -> s.getScore() != null)
            .collect(Collectors.toList());

        if (!gradedSubmissions.isEmpty()) {
            double avgGrade = gradedSubmissions.stream()
                .mapToDouble(Submission::getScore)
                .average().orElse(0.0);
            
            double maxGrade = gradedSubmissions.stream()
                .mapToDouble(Submission::getScore)
                .max().orElse(0.0);
            
            double minGrade = gradedSubmissions.stream()
                .mapToDouble(Submission::getScore)
                .min().orElse(0.0);

            System.out.println("   ├── 📈 THỐNG KÊ ĐIỂM SỐ:");
            System.out.println("   │   ├── Điểm trung bình: " + String.format("%.2f", avgGrade));
            System.out.println("   │   ├── Điểm cao nhất: " + String.format("%.2f", maxGrade));
            System.out.println("   │   └── Điểm thấp nhất: " + String.format("%.2f", minGrade));
        }

        // Chi tiết từng submission
        System.out.println("   └── 📋 CHI TIẾT SUBMISSIONS:");
        for (int i = 0; i < Math.min(submissions.size(), 5); i++) {
            Submission sub = submissions.get(i);
            String prefix = (i == Math.min(submissions.size(), 5) - 1) ? "       └── " : "       ├── ";
            
            System.out.printf("%s[%d] %s - %s", 
                prefix, 
                sub.getId(), 
                sub.getStudent().getFullName(),
                getSubmissionStatus(sub));
            
            if (sub.getScore() != null) {
                System.out.printf(" (%.1f điểm)", sub.getScore().doubleValue());
            }
            System.out.println();
        }
        
        if (submissions.size() > 5) {
            System.out.println("       └── ... và " + (submissions.size() - 5) + " submissions khác");
        }
        
        System.out.println();
    }

    private void generateSummaryReport(Long classroomId) {
        System.out.println("🔢 TỔNG KẾT CLASSROOM " + classroomId);
        System.out.println("-".repeat(50));

        List<Assignment> assignments = assignmentRepository.findByClassroomId(classroomId);
        List<Submission> allSubmissions = assignments.stream()
            .flatMap(a -> submissionRepository.findByAssignmentId(a.getId()).stream())
            .collect(Collectors.toList());

        int totalAssignments = assignments.size();
        int totalSubmissions = allSubmissions.size();
        long gradedSubmissions = allSubmissions.stream()
            .filter(s -> s.getScore() != null)
            .count();
        long pendingSubmissions = allSubmissions.stream()
            .filter(s -> s.getScore() == null)
            .count();

        System.out.println("📚 Tổng số assignments: " + totalAssignments);
        System.out.println("📝 Tổng số submissions: " + totalSubmissions);
        System.out.println("✅ Đã chấm điểm: " + gradedSubmissions);
        System.out.println("⏳ Chờ chấm điểm: " + pendingSubmissions);
        
        if (totalSubmissions > 0) {
            double gradingProgress = (double) gradedSubmissions / totalSubmissions * 100;
            System.out.printf("📊 Tiến độ chấm điểm: %.1f%%\n", gradingProgress);
        }

        System.out.println("-".repeat(50));
        System.out.println("✨ Sẵn sàng test grading workflow tại:");
        System.out.println("🌐 http://localhost:3000/teacher/courses/" + classroomId + "/assignments");
        System.out.println("=".repeat(80));
    }

    public void debugSubmissionDetails(Long submissionId) {
        Submission submission = submissionRepository.findById(submissionId).orElse(null);
        if (submission == null) {
            System.out.println("❌ Không tìm thấy submission với ID: " + submissionId);
            return;
        }

        System.out.println("\n" + "=".repeat(60));
        System.out.println("🔍 CHI TIẾT SUBMISSION #" + submissionId);
        System.out.println("=".repeat(60));
        System.out.println("👤 Sinh viên: " + submission.getStudent().getFullName());
        System.out.println("📧 Email: " + submission.getStudent().getEmail());
        System.out.println("📝 Assignment: " + submission.getAssignment().getTitle());
        System.out.println("📅 Ngày nộp: " + submission.getSubmittedAt());
        System.out.println("📊 Trạng thái: " + getSubmissionStatus(submission));
        
        if (submission.getScore() != null) {
            System.out.println("🎯 Điểm: " + submission.getScore());
            System.out.println("📅 Ngày chấm: " + submission.getGradedAt());
        }
        
        if (submission.getFeedback() != null && !submission.getFeedback().isEmpty()) {
            System.out.println("💬 Feedback:");
            System.out.println("   " + submission.getFeedback().replace("\n", "\n   "));
            
            // Check for encoding issues
            if (hasEncodingIssues(submission.getFeedback())) {
                System.out.println("⚠️  WARNING: Feedback có thể có vấn đề về encoding UTF-8!");
                System.out.println("   Raw feedback: " + submission.getFeedback());
            }
        }
        
        if (submission.getComment() != null && !submission.getComment().isEmpty()) {
            System.out.println("📄 Comment từ sinh viên:");
            String preview = submission.getComment().substring(0, 
                Math.min(200, submission.getComment().length()));
            System.out.println("   " + preview.replace("\n", "\n   ") + "...");
        }
        
        System.out.println("=".repeat(60));
    }

    public void validateGradingWorkflow() {
        System.out.println("\n🔧 KIỂM TRA GRADING WORKFLOW");
        System.out.println("-".repeat(40));
        
        // Test 1: Kiểm tra assignments có submissions
        List<Assignment> assignmentsWithSubmissions = assignmentRepository.findAll().stream()
            .filter(a -> !submissionRepository.findByAssignmentId(a.getId()).isEmpty())
            .collect(Collectors.toList());
        
        System.out.println("✅ Assignments có submissions: " + assignmentsWithSubmissions.size());
        
        // Test 2: Kiểm tra submissions chờ chấm điểm
        long pendingSubmissions = submissionRepository.findAll().stream()
            .filter(s -> s.getScore() == null)
            .count();
        
        System.out.println("⏳ Submissions chờ chấm điểm: " + pendingSubmissions);
        
        // Test 3: Kiểm tra graded submissions
        long gradedSubmissions = submissionRepository.findAll().stream()
            .filter(s -> s.getScore() != null)
            .count();
        
        System.out.println("✅ Submissions đã chấm điểm: " + gradedSubmissions);
        
        // Test 4: Kiểm tra UTF-8 encoding
        long feedbackWithEncodingIssues = submissionRepository.findAll().stream()
            .filter(s -> s.getFeedback() != null)
            .filter(s -> hasEncodingIssues(s.getFeedback()))
            .count();
        
        System.out.println("⚠️  Feedback có vấn đề encoding: " + feedbackWithEncodingIssues);
        
        System.out.println("-".repeat(40));
        
        if (pendingSubmissions > 0) {
            System.out.println("🎯 Sẵn sàng test grading workflow!");
            System.out.println("📝 Có " + pendingSubmissions + " submissions chờ được chấm điểm");
        } else {
            System.out.println("⚠️  Cần tạo thêm submissions để test grading workflow");
        }
        
        if (feedbackWithEncodingIssues > 0) {
            System.out.println("🔧 Có " + feedbackWithEncodingIssues + " feedback cần sửa lỗi encoding");
            System.out.println("   Chạy endpoint: GET /api/admin/utf8/check-submissions để kiểm tra chi tiết");
        }
    }

    /**
     * Lấy status của submission
     */
    private String getSubmissionStatus(Submission submission) {
        if (submission.getScore() != null) {
            return "GRADED";
        }
        
        if (submission.getSubmittedAt() != null) {
            // Check if submitted after due date
            if (submission.getAssignment().getDueDate() != null && 
                submission.getSubmittedAt().isAfter(submission.getAssignment().getDueDate())) {
                return "LATE";
            }
            return "SUBMITTED";
        }
        
        return "NOT_SUBMITTED";
    }

    /**
     * Kiểm tra xem feedback có vấn đề encoding không
     */
    private boolean hasEncodingIssues(String feedback) {
        if (feedback == null) return false;
        
        // Common signs of encoding issues in Vietnamese text
        return feedback.contains("?") || 
               feedback.contains(" ") || 
               feedback.contains("??t") || // "rất" becomes "r??t"
               feedback.contains("??ng") || // "đúng" becomes "??ng" 
               feedback.contains("??y") ||  // "đầy" becomes "??y"
               feedback.contains("?i?t");   // "điểm" becomes "?i?t"
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/assignmentmanagement/AssignmentDto.java">
package com.classroomapp.classroombackend.dto.assignmentmanagement;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonFormat;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssignmentDto {
    
    private Long id;
    
    @NotBlank(message = "Assignment title is required")
    @Size(min = 3, max = 100, message = "Title must be between 3 and 100 characters")
    private String title;
    
    @Size(max = 2000, message = "Description cannot exceed 2000 characters")
    private String description;
    
    @NotNull(message = "Due date is required")
    @Future(message = "Due date must be in the future")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime dueDate;
    
    @Min(value = 0, message = "Points must be non-negative")
    private Integer points;
    
    private String fileAttachmentUrl;
    
    // Classroom information
    private Long classroomId;
    private String classroomName;
    private String subject;
    
    // Additional metadata
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime createdAt;
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime updatedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/assignmentmanagement/CreateAssignmentDto.java">
package com.classroomapp.classroombackend.dto.assignmentmanagement;

import java.time.LocalDateTime;
import java.util.List;

import com.classroomapp.classroombackend.dto.FileUploadResponse;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateAssignmentDto {
    
    @NotBlank(message = "Assignment title is required")
    @Size(min = 3, max = 100, message = "Title must be between 3 and 100 characters")
    private String title;
    
    @Size(max = 2000, message = "Description cannot exceed 2000 characters")
    private String description;
    
    @NotNull(message = "Due date is required")
    @Future(message = "Due date must be in the future")
    private LocalDateTime dueDate;
    
    @Min(value = 0, message = "Points must be non-negative")
    private Integer points;
    
    private List<FileUploadResponse> attachments;
    
    @NotNull(message = "Classroom ID is required")
    private Long classroomId;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/assignmentmanagement/CreateSubmissionDto.java">
package com.classroomapp.classroombackend.dto.assignmentmanagement;

import java.util.List;

import com.classroomapp.classroombackend.dto.FileUploadResponse;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateSubmissionDto {
    
    @NotNull(message = "Assignment ID is required")
    private Long assignmentId;
    
    @Size(max = 2000, message = "Comment cannot exceed 2000 characters")
    private String comment;
    
    private List<FileUploadResponse> attachments;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/assignmentmanagement/GradeSubmissionDto.java">
package com.classroomapp.classroombackend.dto.assignmentmanagement;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GradeSubmissionDto {
    
    @NotNull(message = "Score is required")
    @Min(value = 0, message = "Score cannot be negative")
    @Max(value = 1000, message = "Score seems too high, must be less than 1000")
    private Integer score;
    
    @Size(max = 1000, message = "Feedback cannot exceed 1000 characters")
    private String feedback;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/assignmentmanagement/SubmissionDto.java">
package com.classroomapp.classroombackend.dto.assignmentmanagement;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SubmissionDto {
    
    private Long id;
    
    private Long assignmentId;
    
    private String assignmentTitle;
    
    private Long studentId;
    
    private String studentName;
    
    private String comment;
    
    private String fileSubmissionUrl;
    
    private LocalDateTime submittedAt;
    
    private Integer score;
    
    private String feedback;
    
    private LocalDateTime gradedAt;
    
    private Long gradedById;
    
    private String gradedByName;
    
    // Calculated fields
    private Boolean isLate;
    
    private Boolean isGraded;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/AttendanceDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceDto {
    private Long id;
    private Long userId;
    private String userName;
    private String userFullName;
    private String userPhotoUrl;
    private Long classroomId;
    private String classroomName;
    private LocalDateTime sessionDate;
    private boolean isPresent;
    private String attendanceType;
    private String comment;
    private String photoUrl;
    private Double latitude;
    private Double longitude;
    private String ipAddress;
    private Long markedById;
    private String markedByName;
    private LocalDateTime createdAt;
    private boolean isTeacherRecord;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/AttendanceRecordDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceRecordDto {
    @NotNull
    private Long studentId;
    private String studentName;
    private String studentEmail;
    @NotNull
    private AttendanceStatus status;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/AttendanceResultDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AttendanceResultDto {
    private long totalSessions;
    private long attendedSessions;
    private double attendancePercentage;
    private List<StudentAttendanceDto> detailedRecords;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/AttendanceSessionDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceSessionDto {
    private Long id;
    private Long classroomId;
    private String classroomName;
    private Long teacherId;
    private String teacherName;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String sessionType;
    private String status;
    private String title;
    private boolean autoMarkTeacherAttendance;
    private boolean isActive;
    private LocalDateTime createdAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/AttendanceSubmitDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for submitting attendance records for a lecture
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceSubmitDto {
    private Long lectureId;
    private Long classroomId;
    private List<AttendanceRecordUpdateDto> records;
    
    /**
     * Inner class representing an attendance record update
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AttendanceRecordUpdateDto {
        private Long studentId;
        private String status;
        private String note; // Optional note for the attendance record
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/CreateAttendanceSessionDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.time.Instant;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class CreateAttendanceSessionDto {
    @NotNull
    private Long classroomId;

    @NotNull
    @Future
    private Instant endTime;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/CreateOrUpdateAttendanceDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.util.List;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class CreateOrUpdateAttendanceDto {
    @NotNull
    private Long lectureId;
    @NotNull
    private Long classroomId;
    @NotEmpty
    private List<AttendanceRecordDto> records;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/MyAttendanceHistoryDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.time.LocalDate;

import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MyAttendanceHistoryDto {
    private Long lectureId;
    private String lectureTitle;
    private LocalDate sessionDate;
    private AttendanceStatus status;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/StudentAttendanceDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class StudentAttendanceDto {
    @NotNull
    private Long sessionId;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/attendancemanagement/TeachingHistoryDto.java">
package com.classroomapp.classroombackend.dto.attendancemanagement;

import java.time.LocalDate;
import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO để hiển thị lịch sử giảng dạy của giáo viên
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TeachingHistoryDto {
    private Long lectureId;
    private String lectureTitle;
    private Long classroomId;
    private String classroomName;
    private LocalDate lectureDate;
    private LocalDateTime clockInTime;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/ClassroomDetailsDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import java.util.List;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.usermanagement.UserDetailsDto;

import lombok.Data;


@Data
public class ClassroomDetailsDto {
    private Long id;
    private String name;
    private String description;
    
    // Thông tin lồng nhau
    private CourseDetailsDto course;
    private UserDetailsDto teacher;
    
    // Danh sách các bài giảng
    private List<LectureDto> lectures;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/ClassroomDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import java.util.Set;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ClassroomDto {
    
    private Long id;
    
    @NotBlank(message = "Classroom name is required")
    @Size(min = 3, max = 100, message = "Classroom name must be between 3 and 100 characters")
    private String name;
    
    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;
    
    private String section;
    
    private String subject;
    
    private Long teacherId;
    
    private String teacherName;
    
    private Set<Long> studentIds;
    
    private Integer studentCount;
    
    private Double progressPercentage;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/CourseDetailsDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import java.util.List;

import com.classroomapp.classroombackend.dto.ScheduleDto;
import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseDetailsDto {
    
    // Basic course information
    private Long id;
    private String name;
    private String description;
    private String section;
    private String subject;
    
    // Teacher information
    private UserDto teacher;
    
    // Student information
    private List<UserDto> students;
    private int totalStudents;
    
    // Course content
    private SyllabusDto syllabus;
    private List<ScheduleDto> schedules;
    
    // Assignments
    private List<AssignmentDto> assignments;
    private int totalAssignments;
    private int activeAssignments;
    
    // Statistics
    private CourseStatistics statistics;
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CourseStatistics {
        private int totalStudents;
        private int totalAssignments;
        private int activeAssignments;
        private int completedAssignments;
        private int totalSubmissions;
        private int gradedSubmissions;
        private double averageGrade;
        private double completionRate; // Percentage of assignments completed
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/CreateClassroomDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateClassroomDto {
    
    @NotBlank(message = "Classroom name is required")
    @Size(min = 3, max = 100, message = "Classroom name must be between 3 and 100 characters")
    private String name;
    
    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;
    
    private String section;
    
    private String subject;

    @NotNull(message = "Teacher is required")
    private Long teacherId;

    @NotNull(message = "Course is required")
    private Long courseId;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/EnrollmentRequestDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EnrollmentRequestDto {
    @NotNull(message = "Student ID is required")
    private Long studentId;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/SyllabusDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SyllabusDto {
    
    private Long id;
    
    @NotBlank(message = "Syllabus title is required")
    private String title;
    
    private String content;
    
    private String learningObjectives;
    
    private String requiredMaterials;
    
    private String gradingCriteria;
    
    private Long classroomId;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/classroommanagement/UpdateClassroomDto.java">
package com.classroomapp.classroombackend.dto.classroommanagement;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UpdateClassroomDto {
    @NotBlank(message = "Classroom name cannot be blank")
    @Size(min = 3, max = 100, message = "Classroom name must be between 3 and 100 characters")
    private String name;

    private String description;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/exammangement/CreateExamDto.java">
package com.classroomapp.classroombackend.dto.exammangement;

import java.time.Instant;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class CreateExamDto {

    @NotBlank(message = "Title is required")
    private String title;

    @NotNull(message = "Classroom ID is required")
    private Long classroomId;

    @NotNull(message = "Start time is required")
    private Instant startTime;

    @NotNull(message = "End time is required")
    private Instant endTime;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationInMinutes;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/exammangement/CreateExamSubmissionDto.java">
package com.classroomapp.classroombackend.dto.exammangement;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class CreateExamSubmissionDto {

    @NotNull
    private Long examId;

    private String content;

    // We don't need studentId here, as we'll get it from the authenticated principal.
    // We also don't need startedAt, as we'll set it on the server when submission starts.
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/exammangement/ExamDto.java">
package com.classroomapp.classroombackend.dto.exammangement;

import java.time.Instant;

import lombok.Data;

@Data
public class ExamDto {
    private Long id;
    private String title;
    private Long classroomId;
    private String classroomName;
    private Instant startTime;
    private Instant endTime;
    private Integer durationInMinutes;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/exammangement/ExamSubmissionDto.java">
package com.classroomapp.classroombackend.dto.exammangement;

import java.time.Instant;

import com.classroomapp.classroombackend.dto.usermanagement.UserDetailsDto;

import lombok.Data;

@Data
public class ExamSubmissionDto {
    private Long id;
    private Long examId;
    private UserDetailsDto student;
    private Instant startedAt;
    private Instant submittedAt;
    private String content;
    private Integer score;
    private String feedback;
    private Instant gradedAt;
    private UserDetailsDto gradedBy;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/exammangement/GradeExamDto.java">
package com.classroomapp.classroombackend.dto.exammangement;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class GradeExamDto {

    @NotNull
    @Min(0)
    private Integer score;

    private String feedback;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/requestmanagement/CreateRequestDto.java">
package com.classroomapp.classroombackend.dto.requestmanagement;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class CreateRequestDto {
    @NotBlank
    @Email
    private String email;

    @NotBlank
    private String fullName;

    @NotBlank
    private String phoneNumber;

    @NotBlank
    private String requestedRole; // "TEACHER" or "STUDENT"

    private String formResponses; // Dữ liệu JSON từ form
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/requestmanagement/RequestDTO.java">
package com.classroomapp.classroombackend.dto.requestmanagement;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

@Data
public class RequestDTO {
    private Long id;
    private String email;
    private String fullName;
    private String phoneNumber;
    private String requestedRole;
    private String formResponses;
    private String status;
    private String rejectReason;
    private String resultStatus; // APPROVED, REJECTED, null
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private java.time.LocalDateTime createdAt;
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private java.time.LocalDateTime processedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/usermanagement/UpdateUserRolesRequest.java">
package com.classroomapp.classroombackend.dto.usermanagement;

import java.util.Set;

import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class UpdateUserRolesRequest {
    @NotEmpty
    private Set<String> roles;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/usermanagement/UpdateUserStatusRequest.java">
package com.classroomapp.classroombackend.dto.usermanagement;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class UpdateUserStatusRequest {
    @NotNull
    private Boolean enabled;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/usermanagement/UserDetailsDto.java">
package com.classroomapp.classroombackend.dto.usermanagement;

import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDetailsDto {
    
    private Long id;
    private String username;
    private String email;
    private String fullName;
    private String role;
    private Integer roleId;
    private LocalDate hireDate;
    private String department;
    private String status;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/usermanagement/UserMapper.java">
package com.classroomapp.classroombackend.dto.usermanagement;

import java.util.Collections;

import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.model.usermanagement.User;

/**
 * UserMapper updated to work with consolidated UserDto
 * Maps User entity to the new consolidated UserDto structure
 */
public class UserMapper {

    public static UserDto toDto(User user) {
        if (user == null) {
            return null;
        }

        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setFullName(user.getFullName());
        dto.setName(user.getFullName()); // Map fullName to name for compatibility
        dto.setRoleId(user.getRoleId());
        dto.setEnabled("active".equalsIgnoreCase(user.getStatus()));
        dto.setStatus(user.getStatus());
        dto.setRoles(Collections.singleton(user.getRole()));
        dto.setCreatedAt(user.getCreatedAt());

        return dto;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AccomplishmentDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDate;

import com.fasterxml.jackson.annotation.JsonFormat;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AccomplishmentDto {
    private Long id;
    private Long userId;
    private String userName;

    // New fields for personal accomplishments
    private String title;
    private String description;
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate issueDate;

    // Legacy fields for academic records
    private String courseTitle;
    private String subject;
    private String teacherName;
    private Double grade;
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate completionDate;
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AddMaterialsRequest.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class AddMaterialsRequest {
    @NotEmpty
    private List<FileUploadResponse> files;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AnnouncementAttachmentDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementAttachmentDto {
    private Long id;
    private Long announcementId;
    private String fileName;
    private String filePath;
    private Long fileSize;
    private String fileType;
    private LocalDateTime uploadedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AnnouncementDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementDto {
    private Long id;
    private String title;
    private String content;
    private Long classroomId;
    private String classroomName;
    private Long createdBy;
    private String creatorName;
    private String targetAudience;
    private String priority;
    private LocalDateTime scheduledDate;
    private LocalDateTime expiryDate;
    private Boolean isPinned;
    private Integer attachmentsCount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String status;
    private List<AnnouncementAttachmentDto> attachments;
    private Boolean isRead;
    private Long readCount;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/ApiResponse.java">
package com.classroomapp.classroombackend.dto;

/**
 * Lớp mẫu chung cho tất cả các phản hồi API
 */
public class ApiResponse {
    private boolean success; // Trạng thái thành công hay thất bại
    private String message;  // Thông điệp phản hồi
    private Object data;     // Dữ liệu bổ sung (nếu có)

    /**
     * Constructor với trạng thái và thông điệp
     * 
     * @param success trạng thái thành công
     * @param message thông điệp phản hồi
     */
    public ApiResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
        this.data = null; // Mặc định không có dữ liệu bổ sung
    }

    /**
     * Constructor với trạng thái, thông điệp và dữ liệu
     * 
     * @param success trạng thái thành công
     * @param message thông điệp phản hồi
     * @param data dữ liệu bổ sung
     */
    public ApiResponse(boolean success, String message, Object data) {
        this.success = success;
        this.message = message;
        this.data = data;
    }

    /**
     * Kiểm tra trạng thái thành công
     * 
     * @return true nếu thành công, false nếu thất bại
     */
    public boolean isSuccess() {
        return success;
    }

    /**
     * Thiết lập trạng thái thành công
     * 
     * @param success trạng thái mới
     */
    public void setSuccess(boolean success) {
        this.success = success;
    }

    /**
     * Lấy thông điệp phản hồi
     * 
     * @return thông điệp phản hồi
     */
    public String getMessage() {
        return message;
    }

    /**
     * Thiết lập thông điệp phản hồi
     * 
     * @param message thông điệp phản hồi mới
     */
    public void setMessage(String message) {
        this.message = message;
    }

    /**
     * Lấy dữ liệu bổ sung
     * 
     * @return dữ liệu bổ sung
     */
    public Object getData() {
        return data;
    }

    /**
     * Thiết lập dữ liệu bổ sung
     * 
     * @param data dữ liệu bổ sung mới
     */
    public void setData(Object data) {
        this.data = data;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AssessmentDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssessmentDto {
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("title")
    private String title;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("courseId")
    private Long courseId;
    
    @JsonProperty("lectureId")
    private Long lectureId;
    
    @JsonProperty("type")
    private String type; // QUIZ, ASSIGNMENT, EXAM, PROJECT
    
    @JsonProperty("assessmentType")
    private String assessmentType;
    
    @JsonProperty("totalMarks")
    private Double totalMarks;
    
    @JsonProperty("passingMarks")
    private Double passingMarks;
    
    @JsonProperty("duration")
    private Integer duration; // in minutes
    
    @JsonProperty("timeLimit")
    private Integer timeLimit; // in minutes
    
    @JsonProperty("startTime")
    private LocalDateTime startTime;
    
    @JsonProperty("endTime")
    private LocalDateTime endTime;
    
    @JsonProperty("allowMultipleAttempts")
    private Boolean allowMultipleAttempts = false;
    
    @JsonProperty("maxAttempts")
    private Integer maxAttempts = 1;
    
    @JsonProperty("isVisible")
    private Boolean isVisible = true;
    
    @JsonProperty("instructions")
    private String instructions;
    
    @JsonProperty("questions")
    private List<String> questions;
    
    @JsonProperty("attachments")
    private List<String> attachments;
    
    @JsonProperty("createdAt")
    private LocalDateTime createdAt;
    
    @JsonProperty("createdDate")
    private LocalDateTime createdDate;
    
    @JsonProperty("updatedAt")
    private LocalDateTime updatedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AssignmentDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class AssignmentDto {
    
    private Long id;
    
    @NotBlank(message = "Assignment title is required")
    @Size(min = 3, max = 100, message = "Title must be between 3 and 100 characters")
    private String title;
    
    @Size(max = 2000, message = "Description cannot exceed 2000 characters")
    private String description;
    
    @NotNull(message = "Due date is required")
    @Future(message = "Due date must be in the future")
    private LocalDateTime dueDate;
    
    @Min(value = 0, message = "Points must be non-negative")
    private Integer points;
    
    private String fileAttachmentUrl;
    
    private Long classroomId;
    
    private String classroomName;
    
    // Added for frontend integration
    private String submissionStatus;
    
    // Added for frontend integration
    private Double score;
    
    // Constructor with all fields
    public AssignmentDto(Long id, String title, String description, LocalDateTime dueDate,
                         Integer points, String fileAttachmentUrl, Long classroomId, 
                         String classroomName, String submissionStatus, Double score) {
        this.id = id;
        this.title = title;
        this.description = description;
        this.dueDate = dueDate;
        this.points = points;
        this.fileAttachmentUrl = fileAttachmentUrl;
        this.classroomId = classroomId;
        this.classroomName = classroomName;
        this.submissionStatus = submissionStatus;
        this.score = score;
    }
    
    // Constructor without submission status and score for backward compatibility
    public AssignmentDto(Long id, String title, String description, LocalDateTime dueDate,
                         Integer points, String fileAttachmentUrl, Long classroomId, String classroomName) {
        this.id = id;
        this.title = title;
        this.description = description;
        this.dueDate = dueDate;
        this.points = points;
        this.fileAttachmentUrl = fileAttachmentUrl;
        this.classroomId = classroomId;
        this.classroomName = classroomName;
        this.submissionStatus = null;
        this.score = null;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AssignmentRubricDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssignmentRubricDto {
    private Long id;
    private Long assignmentId;
    private String title;
    private String description;
    private List<RubricCriteriaDto> criteria;
    private Double totalPoints;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AssignmentSubmissionDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssignmentSubmissionDto {
    private Long id;
    private Long studentId;
    private String studentName;
    private String submissionText;
    private String attachmentUrl;
    private LocalDateTime submissionDate;
    private String status; // SUBMITTED, GRADED, LATE
    private Double grade;
    private String feedback;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AttendanceDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceDto {
    private Long id;
    private Long userId;
    private String userName;
    private String userFullName;
    private String userPhotoUrl;
    private Long classroomId;
    private String classroomName;
    private Long sessionId;
    private LocalDateTime sessionDate;
    private boolean isPresent;
    private AttendanceStatus status;
    private String attendanceType;
    private String comment;
    private String photoUrl;
    private Double latitude;
    private Double longitude;
    private String ipAddress;
    private Long markedById;
    private String markedByName;
    private LocalDateTime markedAt;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private boolean isTeacherRecord;
    
    // Explicit getter to resolve compilation issues
    public Long getUserId() { return userId; }
}


</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/AttendanceSessionDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceSessionDto {
    private Long id;
    private String sessionName;
    private Long classroomId;
    private String classroomName;
    private Long teacherId;
    private String teacherName;
    private LocalDateTime sessionDate;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String sessionType;
    private String status;
    private String title;
    private String description;
    private Boolean locationRequired;
    private Double locationLatitude;
    private Double locationLongitude;
    private Integer locationRadiusMeters;
    private Boolean autoMarkTeacherAttendance;
    private List<AttendanceDto> attendanceRecords;
    private boolean isActive;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}


</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/BlogDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class BlogDto {
    
    private Long id;
    private String slug;
    
    @NotBlank(message = "Title is required")
    @Size(min = 3, max = 200, message = "Title must be between 3 and 200 characters")
    private String title;
    
    private String description;
    
    private String imageUrl;
    
    private String videoUrl;
    
    private LocalDateTime publishedDate;
    
    private LocalDateTime lastEditedDate;
    
    private Long authorId;
    
    private String authorName;
    
    private Long lastEditedById;
    
    private String lastEditedByName;
    
    private Boolean isPublished;
    
    private String status;
    
    private String tags;
    
    private String thumbnailUrl;
    
    private Integer viewCount;

    // Constructors
    public BlogDto() {}

    public BlogDto(Long id, String title, String description, String imageUrl, String videoUrl,
                  LocalDateTime publishedDate, LocalDateTime lastEditedDate, Long authorId,
                  String authorName, Long lastEditedById, String lastEditedByName,
                  Boolean isPublished, String status, String tags, String thumbnailUrl,
                  Integer viewCount) {
        this.id = id;
        this.title = title;
        this.description = description;
        this.imageUrl = imageUrl;
        this.videoUrl = videoUrl;
        this.publishedDate = publishedDate;
        this.lastEditedDate = lastEditedDate;
        this.authorId = authorId;
        this.authorName = authorName;
        this.lastEditedById = lastEditedById;
        this.lastEditedByName = lastEditedByName;
        this.isPublished = isPublished;
        this.status = status;
        this.tags = tags;
        this.thumbnailUrl = thumbnailUrl;
        this.viewCount = viewCount;
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getSlug() {
        return slug;
    }

    public void setSlug(String slug) {
        this.slug = slug;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public String getVideoUrl() {
        return videoUrl;
    }

    public void setVideoUrl(String videoUrl) {
        this.videoUrl = videoUrl;
    }

    public LocalDateTime getPublishedDate() {
        return publishedDate;
    }

    public void setPublishedDate(LocalDateTime publishedDate) {
        this.publishedDate = publishedDate;
    }

    public LocalDateTime getLastEditedDate() {
        return lastEditedDate;
    }

    public void setLastEditedDate(LocalDateTime lastEditedDate) {
        this.lastEditedDate = lastEditedDate;
    }

    public Long getAuthorId() {
        return authorId;
    }

    public void setAuthorId(Long authorId) {
        this.authorId = authorId;
    }

    public String getAuthorName() {
        return authorName;
    }

    public void setAuthorName(String authorName) {
        this.authorName = authorName;
    }

    public Long getLastEditedById() {
        return lastEditedById;
    }

    public void setLastEditedById(Long lastEditedById) {
        this.lastEditedById = lastEditedById;
    }

    public String getLastEditedByName() {
        return lastEditedByName;
    }

    public void setLastEditedByName(String lastEditedByName) {
        this.lastEditedByName = lastEditedByName;
    }

    public Boolean getIsPublished() {
        return isPublished;
    }

    public void setIsPublished(Boolean isPublished) {
        this.isPublished = isPublished;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getTags() {
        return tags;
    }

    public void setTags(String tags) {
        this.tags = tags;
    }

    public String getThumbnailUrl() {
        return thumbnailUrl;
    }

    public void setThumbnailUrl(String thumbnailUrl) {
        this.thumbnailUrl = thumbnailUrl;
    }

    public Integer getViewCount() {
        return viewCount;
    }

    public void setViewCount(Integer viewCount) {
        this.viewCount = viewCount;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/BulkGradeEntryDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BulkGradeEntryDto {
    private Long submissionId;
    private Double grade;
    private String feedback;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/BulkGradingDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BulkGradingDto {
    private List<BulkGradeEntryDto> grades;
    private String feedback;
    private boolean applyToAll;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/BulkGradingResultDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BulkGradingResultDto {
    private int totalProcessed;
    private int successfullyGraded;
    private int failed;
    private List<String> errors;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/ClassroomDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.Set;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ClassroomDto {
    
    private Long id;
    
    @NotBlank(message = "Classroom name is required")
    @Size(min = 3, max = 100, message = "Classroom name must be between 3 and 100 characters")
    private String name;
    
    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;
    
    private String section;
    
    private String subject;
    
    private Long teacherId;
    
    private String teacherName;
    
    private Set<Long> studentIds;
    
    private Integer studentCount;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CourseFeedbackDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseFeedbackDto {
    private Long id;
    
    @NotNull(message = "Student ID không được để trống")
    private Long studentId;
    private String studentName;
    
    @NotNull(message = "Classroom ID không được để trống")
    private Long classroomId;
    private String classroomName;
    
    @NotNull(message = "Teacher ID không được để trống")
    private Long teacherId;
    private String teacherName;
    
    @NotBlank(message = "Tiêu đề không được để trống")
    private String title;
    
    @NotBlank(message = "Nội dung feedback không được để trống")
    private String content;
    
    @NotNull(message = "Đánh giá tổng thể không được để trống")
    @Min(value = 1, message = "Đánh giá phải từ 1-5")
    @Max(value = 5, message = "Đánh giá phải từ 1-5")
    private Integer overallRating;
    
    @Min(value = 1, message = "Đánh giá phải từ 1-5")
    @Max(value = 5, message = "Đánh giá phải từ 1-5")
    private Integer teachingQualityRating;
    
    @Min(value = 1, message = "Đánh giá phải từ 1-5")
    @Max(value = 5, message = "Đánh giá phải từ 1-5")
    private Integer courseMaterialRating;
    
    @Min(value = 1, message = "Đánh giá phải từ 1-5")
    @Max(value = 5, message = "Đánh giá phải từ 1-5")
    private Integer supportRating;
    
    private String category = "GENERAL"; // GENERAL, TEACHING, MATERIAL, SUPPORT, SUGGESTION
    private String status = "SUBMITTED"; // SUBMITTED, REVIEWED, ACKNOWLEDGED
    
    private Boolean isAnonymous = false;
    
    private LocalDateTime reviewedAt;
    private Long reviewedById;
    private String reviewedByName;
    private String response;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Explicit getters to resolve compilation issues
    public Long getClassroomId() { return classroomId; }
    public String getTitle() { return title; }
    public String getContent() { return content; }
    public Integer getOverallRating() { return overallRating; }
    public Integer getTeachingQualityRating() { return teachingQualityRating; }
    public Integer getCourseMaterialRating() { return courseMaterialRating; }
    public Integer getSupportRating() { return supportRating; }
    public String getCategory() { return category; }
    public Boolean getIsAnonymous() { return isAnonymous; }
    
    // Explicit setters to resolve compilation issues
    public void setStudentName(String studentName) { this.studentName = studentName; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CourseMaterialDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseMaterialDto {
    private Long id;
    private String title;
    private String description;
    private String filePath;
    private String fileName;
    private Long fileSize;
    private String fileType;
    private LocalDateTime uploadDate;
    private Long classroomId;
    private Long uploadedBy;
    private String uploaderName;
    private Boolean isPublic;
    private Integer downloadCount;
    private Integer versionNumber;

    // Explicit getters for compilation issues
    public String getFileName() {
        return fileName;
    }

    public String getFileType() {
        return fileType;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CourseScheduleDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseScheduleDto {
    
    @JsonProperty("courseId")
    private Long courseId;
    
    @JsonProperty("courseName")
    private String courseName;
    
    @JsonProperty("scheduleItems")
    private List<ScheduleItemDto> scheduleItems;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateAnnouncementDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateAnnouncementDto {
    @NotBlank(message = "Title is required")
    private String title;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    private Long classroomId;
    
    private String targetAudience = "ALL";
    
    private String priority = "NORMAL";
    
    private LocalDateTime scheduledDate;
    
    private LocalDateTime expiryDate;
    
    private Boolean isPinned = false;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateAssessmentDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateAssessmentDto {
    
    @NotBlank(message = "Title is required")
    @JsonProperty("title")
    private String title;
    
    @JsonProperty("description")
    private String description;
    
    @NotNull(message = "Course ID is required")
    @JsonProperty("courseId")
    private Long courseId;
    
    @JsonProperty("lectureId")
    private Long lectureId;
    
    @NotBlank(message = "Assessment type is required")
    @JsonProperty("type")
    private String type; // QUIZ, ASSIGNMENT, EXAM, PROJECT
    
    @JsonProperty("assessmentType")
    private String assessmentType;
    
    @NotNull(message = "Total marks is required")
    @Min(value = 0, message = "Total marks must be non-negative")
    @JsonProperty("totalMarks")
    private Double totalMarks;
    
    @Min(value = 0, message = "Passing marks must be non-negative")
    @JsonProperty("passingMarks")
    private Double passingMarks;
    
    @JsonProperty("duration")
    private Integer duration; // in minutes
    
    @JsonProperty("timeLimit")
    private Integer timeLimit; // in minutes
    
    @NotNull(message = "Start time is required")
    @JsonProperty("startTime")
    private LocalDateTime startTime;
    
    @NotNull(message = "End time is required")
    @JsonProperty("endTime")
    private LocalDateTime endTime;
    
    @JsonProperty("allowMultipleAttempts")
    private Boolean allowMultipleAttempts = false;
    
    @JsonProperty("maxAttempts")
    private Integer maxAttempts = 1;
    
    @JsonProperty("isVisible")
    private Boolean isVisible = true;
    
    @JsonProperty("instructions")
    private String instructions;
    
    @JsonProperty("questions")
    private List<String> questions;
    
    @JsonProperty("attachments")
    private List<String> attachments;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateAssignmentDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateAssignmentDto {
    
    @NotBlank(message = "Assignment title is required")
    @Size(min = 3, max = 100, message = "Title must be between 3 and 100 characters")
    private String title;
    
    @Size(max = 2000, message = "Description cannot exceed 2000 characters")
    private String description;
    
    @NotNull(message = "Due date is required")
    @Future(message = "Due date must be in the future")
    private LocalDateTime dueDate;
    
    @Min(value = 0, message = "Points must be non-negative")
    private Integer points;
    
    private String fileAttachmentUrl;
    
    @NotNull(message = "Classroom ID is required")
    private Long classroomId;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateBlogDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateBlogDto {
    
    @NotBlank(message = "Title is required")
    @Size(min = 3, max = 200, message = "Title must be between 3 and 200 characters")
    private String title;
    
    private String description;
    
    private String imageUrl;
    
    private String videoUrl;
    
    private String tags;
    
    private String thumbnailUrl;
    
    private Boolean isPublished = false;

    // Getters and Setters
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public String getVideoUrl() {
        return videoUrl;
    }

    public void setVideoUrl(String videoUrl) {
        this.videoUrl = videoUrl;
    }

    public String getTags() {
        return tags;
    }

    public void setTags(String tags) {
        this.tags = tags;
    }

    public String getThumbnailUrl() {
        return thumbnailUrl;
    }

    public void setThumbnailUrl(String thumbnailUrl) {
        this.thumbnailUrl = thumbnailUrl;
    }

    public Boolean getIsPublished() {
        return isPublished;
    }

    public void setIsPublished(Boolean isPublished) {
        this.isPublished = isPublished;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateClassroomDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateClassroomDto {
    
    @NotBlank(message = "Classroom name is required")
    @Size(min = 3, max = 100, message = "Classroom name must be between 3 and 100 characters")
    private String name;
    
    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;
    
    private String section;
    
    private String subject;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateEventDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateEventDto {
    @NotBlank(message = "Title is required")
    private String title;
    
    private String description;
    
    @NotNull(message = "Start date and time is required")
    private LocalDateTime startDatetime;
    
    @NotNull(message = "End date and time is required")
    private LocalDateTime endDatetime;
    
    @NotNull(message = "Event type is required")
    private String eventType;
    
    private Long classroomId;
    
    private String location;
    
    private Boolean isAllDay = false;
    
    private Integer reminderMinutes = 15;
    
    private String color = "#007bff";
    
    private String recurringRule;
    
    private Long parentEventId;
    
    // Explicit setters to resolve compilation issues
    public void setTitle(String title) { this.title = title; }
    public void setDescription(String description) { this.description = description; }
    public void setStartDatetime(LocalDateTime startDatetime) { this.startDatetime = startDatetime; }
    public void setEndDatetime(LocalDateTime endDatetime) { this.endDatetime = endDatetime; }
    public void setEventType(String eventType) { this.eventType = eventType; }
    public void setClassroomId(Long classroomId) { this.classroomId = classroomId; }
    public void setClassroomId(long classroomId) { this.classroomId = classroomId; }
    public void setLocation(String location) { this.location = location; }
    public void setIsAllDay(Boolean isAllDay) { this.isAllDay = isAllDay; }
    public void setReminderMinutes(Integer reminderMinutes) { this.reminderMinutes = reminderMinutes; }
    public void setColor(String color) { this.color = color; }
    public void setRecurringRule(String recurringRule) { this.recurringRule = recurringRule; }
    public void setParentEventId(Long parentEventId) { this.parentEventId = parentEventId; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateFeedbackDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateFeedbackDto {
    private Long submissionId;
    private String feedbackText;
    private String feedbackType; // WRITTEN, AUDIO, VIDEO
    private List<String> attachments;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateLectureDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateLectureDto {

    @NotBlank(message = "Title is required")
    @Size(max = 255, message = "Title cannot exceed 255 characters")
    private String title;

    private String content;
    
    private List<CreateLectureMaterialDto> materials;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateLectureMaterialDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateLectureMaterialDto {
    
    private String fileName;
    private String fileUrl;
    private String fileType;
    private Long fileSize;
    private boolean localFile;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateRubricCriteriaDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateRubricCriteriaDto {
    private String name;
    private String description;
    private Double maxPoints;
    private List<String> performanceLevels;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateRubricDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateRubricDto {
    private String title;
    private String description;
    private List<CreateRubricCriteriaDto> criteria;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateScheduleItemDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalTime;

import com.fasterxml.jackson.annotation.JsonProperty;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateScheduleItemDto {
    
    @NotNull(message = "Day of week is required")
    @Min(value = 1, message = "Day of week must be between 1 and 7")
    @Max(value = 7, message = "Day of week must be between 1 and 7")
    @JsonProperty("dayOfWeek")
    private int dayOfWeek;
    
    @NotNull(message = "Start time is required")
    @JsonProperty("startTime")
    private LocalTime startTime;
    
    @NotNull(message = "End time is required")
    @JsonProperty("endTime")
    private LocalTime endTime;
    
    @JsonProperty("room")
    private String room;
    
    @JsonProperty("teacher")
    private String teacher;
    
    @JsonProperty("notes")
    private String notes;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateSubmissionDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateSubmissionDto {
    
    @NotNull(message = "Assignment ID is required")
    private Long assignmentId;
    
    @Size(max = 2000, message = "Comment cannot exceed 2000 characters")
    private String comment;
    
    private String fileSubmissionUrl;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/CreateUserDto.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/EventAttendeeDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EventAttendeeDto {
    private Long id;
    private Long eventId;
    private Long userId;
    private String userName;
    private String attendanceStatus;
    private LocalDateTime responseDate;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/FeedbackDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class FeedbackDto {
    private Long id;
    private Long submissionId;
    private String feedbackText;
    private String feedbackType;
    private List<String> attachments;
    private LocalDateTime createdDate;
    private String createdBy;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/FileUploadResponse.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileUploadResponse {
    private String fileName;
    private String fileUrl;
    private String fileType;
    private long size;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/GoogleAuthRequestDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object for Google authentication
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class GoogleAuthRequestDto {
    
    @NotBlank(message = "ID token is required")
    private String idToken;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/GradeDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GradeDto {
    private Long id;
    private Long submissionId;
    private Double grade;
    private String feedback;
    private LocalDateTime gradedDate;
    private String gradedBy;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/GradingAnalyticsDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.Map;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GradingAnalyticsDto {
    private int totalSubmissions;
    private int gradedSubmissions;
    private int pendingGrading;
    private double averageGrade;
    private double highestGrade;
    private double lowestGrade;
    private Map<String, Integer> gradeDistribution;
    private LocalDateTime lastGradedDate;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/JwtResponseDto.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LectureDetailsDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LectureDetailsDto {
    private Long id;
    private String title;
    private String content;
    private LocalDate lectureDate;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private List<LectureMaterialDto> materials;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LectureDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LectureDto {
    
    private Long id;
    private String title;
    private String content;
    private String description;
    private Long classroomId;
    private Long courseId;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String type;
    private String roomLocation;
    private Integer maxAttendees;
    private Boolean isRecordingEnabled;
    private String meetingUrl;
    private String status;
    private LocalDateTime createdDate;
    private LocalDateTime updatedDate;
    private LocalDate lectureDate;
    private List<LectureMaterialDto> materials = new ArrayList<>();
    
    public LectureDto(Long id, String title, String content, Long classroomId) {
        this.id = id;
        this.title = title;
        this.content = content;
        this.classroomId = classroomId;
        this.materials = new ArrayList<>();
    }
    
    public void addMaterial(LectureMaterialDto material) {
        if (this.materials == null) {
            this.materials = new ArrayList<>();
        }
        this.materials.add(material);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LectureMaterialDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LectureMaterialDto {
    
    private Long id;
    private String fileName;
    private String contentType;
    private String downloadUrl;
    private String filePath;
    private Long lectureId;
    private long fileSize;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LiveStreamDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LiveStreamDto {
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("lectureId")
    private Long lectureId;
    
    @JsonProperty("streamKey")
    private String streamKey;
    
    @JsonProperty("streamUrl")
    private String streamUrl;
    
    @JsonProperty("viewerUrl")
    private String viewerUrl;
    
    @JsonProperty("status")
    private String status; // OFFLINE, STARTING, LIVE, ENDING, ENDED
    
    @JsonProperty("viewerCount")
    private Integer viewerCount = 0;
    
    @JsonProperty("maxViewers")
    private Integer maxViewers = 0;
    
    @JsonProperty("startedAt")
    private LocalDateTime startedAt;
    
    @JsonProperty("startTime")
    private LocalDateTime startTime;
    
    @JsonProperty("endedAt")
    private LocalDateTime endedAt;
    
    @JsonProperty("endTime")
    private LocalDateTime endTime;
    
    @JsonProperty("quality")
    private String quality; // AUTO, 1080p, 720p, 480p, 360p
    
    @JsonProperty("isRecording")
    private Boolean isRecording = false;
    
    @JsonProperty("chatEnabled")
    private Boolean chatEnabled = true;
    
    @JsonProperty("viewers")
    private List<String> viewers; // List of viewer usernames
    
    @JsonProperty("chatMessages")
    private List<String> chatMessages;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LiveStreamStatusDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LiveStreamStatusDto {
    
    @JsonProperty("streamId")
    private Long streamId;
    
    @JsonProperty("lectureId")
    private Long lectureId;
    
    @JsonProperty("status")
    private String status; // OFFLINE, STARTING, LIVE, ENDING, ENDED
    
    @JsonProperty("isLive")
    private Boolean isLive;
    
    @JsonProperty("viewerCount")
    private Integer viewerCount;
    
    @JsonProperty("duration")
    private Long duration; // in seconds
    
    @JsonProperty("quality")
    private String quality;
    
    @JsonProperty("streamQuality")
    private String streamQuality;
    
    @JsonProperty("bitrate")
    private Integer bitrate;
    
    @JsonProperty("fps")
    private Integer fps;
    
    @JsonProperty("resolution")
    private String resolution;
    
    @JsonProperty("lastUpdate")
    private LocalDateTime lastUpdate;
    
    @JsonProperty("errorMessage")
    private String errorMessage;
    
    @JsonProperty("isRecording")
    private Boolean isRecording;
    
    @JsonProperty("chatEnabled")
    private Boolean chatEnabled;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LocationDataDto.java">
package com.classroomapp.classroombackend.dto;

/**
 * Lớp DTO lưu trữ thông tin vị trí GPS gửi từ client
 */
public class LocationDataDto {
    private double latitude;    // Vĩ độ
    private double longitude;   // Kinh độ
    private double accuracy;    // Độ chính xác (tính bằng mét)

    /**
     * Constructor mặc định
     */
    public LocationDataDto() {
    }

    /**
     * Constructor với tham số
     * 
     * @param latitude Vĩ độ
     * @param longitude Kinh độ
     * @param accuracy Độ chính xác
     */
    public LocationDataDto(double latitude, double longitude, double accuracy) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.accuracy = accuracy;
    }

    /**
     * Lấy vĩ độ
     * 
     * @return giá trị vĩ độ
     */
    public double getLatitude() {
        return latitude;
    }

    /**
     * Thiết lập vĩ độ
     * 
     * @param latitude giá trị vĩ độ mới
     */
    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    /**
     * Lấy kinh độ
     * 
     * @return giá trị kinh độ
     */
    public double getLongitude() {
        return longitude;
    }

    /**
     * Thiết lập kinh độ
     * 
     * @param longitude giá trị kinh độ mới
     */
    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    /**
     * Lấy độ chính xác
     * 
     * @return giá trị độ chính xác
     */
    public double getAccuracy() {
        return accuracy;
    }

    /**
     * Thiết lập độ chính xác
     * 
     * @param accuracy giá trị độ chính xác mới
     */
    public void setAccuracy(double accuracy) {
        this.accuracy = accuracy;
    }

    @Override
    public String toString() {
        return "LocationDataDto{" +
               "latitude=" + latitude +
               ", longitude=" + longitude +
               ", accuracy=" + accuracy +
               '}';
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LoginDto.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LoginRequest.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    private String username;
    private String password;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LoginRequestDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object for login requests
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDto {
    
    @NotBlank(message = "Username is required")
    private String username;
    
    @NotBlank(message = "Password is required")
    private String password;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/LoginResponseDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object for login responses
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDto {
    private String token;
    private String role;
    private Integer roleId;
    private String username;
    private String email;
    private Long userId;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/NotificationDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationDto {
    
    private Long id;
    private String message;
    private LocalDateTime createdAt;
    private Boolean isRead;
    private String sender;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/PasswordConfirmationDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object for password confirmation
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PasswordConfirmationDto {
    
    @NotBlank(message = "Token is required")
    private String token;
    
    @NotBlank(message = "New password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String newPassword;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/PasswordResetRequestDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object for password reset requests
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PasswordResetRequestDto {
    
    @Email(message = "Valid email is required")
    @NotBlank(message = "Email is required")
    private String email;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/ProgressAnalyticsDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProgressAnalyticsDto {
    private Long classroomId;
    private String classroomName;
    private Integer totalStudents;
    private BigDecimal averageProgress;
    private BigDecimal highestProgress;
    private BigDecimal lowestProgress;
    private Integer studentsAbove80Percent;
    private Integer studentsBelow50Percent;
    private List<StudentProgressDto> topPerformers;
    private List<StudentProgressDto> strugglingStudents;
    private Integer totalAssignments;
    private Integer completedAssignments;
    private Long totalTimeSpent;
    private BigDecimal averageTimePerStudent;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/RecordingSessionDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RecordingSessionDto {
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("lectureId")
    private Long lectureId;
    
    @JsonProperty("title")
    private String title;
    
    @JsonProperty("recordingUrl")
    private String recordingUrl;
    
    @JsonProperty("duration")
    private Long duration; // in seconds
    
    @JsonProperty("fileSize")
    private Long fileSize; // in bytes
    
    @JsonProperty("startTime")
    private LocalDateTime startTime;
    
    @JsonProperty("endTime")
    private LocalDateTime endTime;
    
    @JsonProperty("status")
    private String status; // RECORDING, PROCESSING, READY, FAILED
    
    @JsonProperty("quality")
    private String quality; // HD, SD, AUDIO_ONLY
    
    @JsonProperty("downloadUrl")
    private String downloadUrl;
    
    @JsonProperty("thumbnailUrl")
    private String thumbnailUrl;
    
    @JsonProperty("transcript")
    private String transcript;
    
    @JsonProperty("createdAt")
    private LocalDateTime createdAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/RegisterDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RegisterDto {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotBlank(message = "Full name is required")
    private String fullName;
    
    @NotNull(message = "Role ID is required")
    private Integer roleId;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/RequestDTO.java">
package com.classroomapp.classroombackend.dto;

import lombok.Data;

@Data
public class RequestDTO {
    private String email;
    private String fullName;
    private String phoneNumber;
    private String requestedRole;
    private String formResponses;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/RequestResponseDTO.java">
package com.classroomapp.classroombackend.dto;

import lombok.Data;

@Data
public class RequestResponseDTO {
    private Long id;
    private String email;
    private String fullName;
    private String phoneNumber;
    private String requestedRole;
    private String status;
    private String rejectReason;
    private String createdAt;
    private String processedAt;
    private String formResponses;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/RubricCriteriaDto.java">
package com.classroomapp.classroombackend.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RubricCriteriaDto {
    private Long id;
    private String name;
    private String description;
    private Double maxPoints;
    private List<String> performanceLevels;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/ScheduleDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.DayOfWeek;
import java.time.LocalTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Consolidated ScheduleDto that combines features from both previous versions
 * Supports both legacy integer day format and modern DayOfWeek enum
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ScheduleDto {
    private Long id;
    private Long teacherId;
    private String teacherName;
    private Long classroomId;
    private String className;
    private String classroomName;

    // Legacy support - Integer day format (0=Monday, 1=Tuesday, etc.)
    private Integer day;
    private String start; // Formatted as "HH:MM"
    private String end; // Formatted as "HH:MM"

    // Modern format - DayOfWeek enum and LocalTime
    @NotNull(message = "Day of week is required")
    private DayOfWeek dayOfWeek;
    private String dayName;

    @NotNull(message = "Start time is required")
    private LocalTime startTime;

    @NotNull(message = "End time is required")
    private LocalTime endTime;

    @NotBlank(message = "Location is required")
    private String location;
    private String room;
    private String subject;
    private String materialsUrl;
    private String meetUrl;
    private Integer studentCount;
    private String notes;
    private boolean isRecurring;

    // Legacy constructor that takes LocalTime for start and end and formats them
    public ScheduleDto(Long id, Long teacherId, String teacherName, Long classroomId, String className,
                     Integer day, LocalTime startTime, LocalTime endTime, String room,
                     String subject, String materialsUrl, String meetUrl, Integer studentCount) {
        this.id = id;
        this.teacherId = teacherId;
        this.teacherName = teacherName;
        this.classroomId = classroomId;
        this.className = className;
        this.day = day;
        this.start = startTime != null ? startTime.toString().substring(0, 5) : null; // Format as "HH:MM"
        this.end = endTime != null ? endTime.toString().substring(0, 5) : null; // Format as "HH:MM"
        this.startTime = startTime;
        this.endTime = endTime;
        this.room = room;
        this.location = room; // Map room to location for compatibility
        this.subject = subject;
        this.materialsUrl = materialsUrl;
        this.meetUrl = meetUrl;
        this.studentCount = studentCount;

        // Convert integer day to DayOfWeek for modern format
        if (day != null) {
            this.dayOfWeek = convertIntegerToDayOfWeek(day);
        }
    }

    // Helper method to format the day and time for display (from classroommanagement version)
    public String getFormattedSchedule() {
        if (dayOfWeek != null && startTime != null && endTime != null && location != null) {
            return dayOfWeek + " " + startTime + " - " + endTime + " at " + location;
        }
        return "Schedule not fully configured";
    }

    // Helper method to convert integer day to DayOfWeek
    private DayOfWeek convertIntegerToDayOfWeek(Integer day) {
        if (day == null) return null;
        switch (day) {
            case 0: return DayOfWeek.MONDAY;
            case 1: return DayOfWeek.TUESDAY;
            case 2: return DayOfWeek.WEDNESDAY;
            case 3: return DayOfWeek.THURSDAY;
            case 4: return DayOfWeek.FRIDAY;
            case 5: return DayOfWeek.SATURDAY;
            case 6: return DayOfWeek.SUNDAY;
            default: return DayOfWeek.MONDAY;
        }
    }

    // Helper method to convert DayOfWeek to integer
    public Integer getDayAsInteger() {
        if (dayOfWeek == null) return day;
        switch (dayOfWeek) {
            case MONDAY: return 0;
            case TUESDAY: return 1;
            case WEDNESDAY: return 2;
            case THURSDAY: return 3;
            case FRIDAY: return 4;
            case SATURDAY: return 5;
            case SUNDAY: return 6;
            default: return 0;
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/ScheduleItemDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalTime;

import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ScheduleItemDto {
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("courseId")
    private Long courseId;
    
    @JsonProperty("dayOfWeek")
    private int dayOfWeek; // 1 = Monday, 7 = Sunday
    
    @JsonProperty("startTime")
    private LocalTime startTime;
    
    @JsonProperty("endTime")
    private LocalTime endTime;
    
    @JsonProperty("room")
    private String room;
    
    @JsonProperty("teacher")
    private String teacher;
    
    @JsonProperty("notes")
    private String notes;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/StudentDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentDto {
    
    private Long id;
    private String name;
    private String email;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/StudentMessageDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentMessageDto {
    private Long id;
    
    @NotNull(message = "Sender ID không được để trống")
    private Long senderId;
    private String senderName;
    
    @NotNull(message = "Recipient ID không được để trống")
    private Long recipientId;
    private String recipientName;
    
    @NotBlank(message = "Chủ đề không được để trống")
    private String subject;
    
    @NotBlank(message = "Nội dung tin nhắn không được để trống")
    private String content;
    
    private String messageType = "GENERAL"; // GENERAL, COMPLAINT, REQUEST, INQUIRY, URGENT
    private String priority = "MEDIUM"; // LOW, MEDIUM, HIGH, URGENT
    private String status = "SENT"; // SENT, READ, REPLIED, RESOLVED, ARCHIVED
    
    private Boolean isRead = false;
    private LocalDateTime readAt;
    
    private String reply;
    private LocalDateTime repliedAt;
    private Long repliedById;
    private String repliedByName;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Explicit getters to resolve compilation issues
    public Long getSenderId() { return senderId; }
    public Long getRecipientId() { return recipientId; }
    public String getSubject() { return subject; }
    public String getContent() { return content; }
    public String getMessageType() { return messageType; }
    public String getPriority() { return priority; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/StudentProgressDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentProgressDto {
    private Long id;
    private Long studentId;
    private String studentName;
    private Long classroomId;
    private String classroomName;
    private Long assignmentId;
    private String assignmentTitle;
    private String progressType;
    private BigDecimal progressPercentage;
    private BigDecimal pointsEarned;
    private BigDecimal maxPoints;
    private LocalDateTime completionDate;
    private LocalDateTime lastAccessed;
    private Integer timeSpentMinutes;
    private String notes;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/StudentQuestionDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentQuestionDto {
    private Long id;
    
    @NotNull(message = "Student ID không được để trống")
    private Long studentId;
    private String studentName;
    
    @NotNull(message = "Teacher ID không được để trống")
    private Long teacherId;
    private String teacherName;
    
    @NotBlank(message = "Chủ đề không được để trống")
    private String subject;
    
    @NotBlank(message = "Nội dung câu hỏi không được để trống")
    private String content;
    
    private String priority = "MEDIUM"; // LOW, MEDIUM, HIGH, URGENT
    private String status = "PENDING"; // PENDING, ANSWERED, CLOSED
    
    private String answer;
    private LocalDateTime answeredAt;
    private Long answeredById;
    private String answeredByName;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/StudentRequestFormDTO.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class StudentRequestFormDTO {
    @NotEmpty(message = "Email không được để trống")
    @Email(message = "Email không hợp lệ")
    private String email;
    
    @NotEmpty(message = "Họ tên không được để trống")
    private String fullName;
    
    @NotEmpty(message = "Số điện thoại không được để trống")
    private String phoneNumber;
    
    @NotEmpty(message = "Lớp không được để trống")
    private String grade;
    
    @NotEmpty(message = "Thông tin phụ huynh không được để trống")
    private String parentContact;
    
    private String additionalInfo;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/SubmissionDto.java">
package com.classroomapp.classroombackend.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SubmissionDto {
    
    private Long id;
    
    private Long assignmentId;
    
    private String assignmentTitle;
    
    private Long studentId;
    
    private String studentName;
    
    private String comment;
    
    private String fileSubmissionUrl;
    
    private LocalDateTime submittedAt;
    
    private Integer score;
    
    private String feedback;
    
    private LocalDateTime gradedAt;
    
    private Long gradedById;
    
    private String gradedByName;
    
    // Calculated fields
    private Boolean isLate;
    
    private Boolean isGraded;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/TeacherRequestFormDTO.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class TeacherRequestFormDTO {
    @NotEmpty(message = "Email không được để trống")
    @Email(message = "Email không hợp lệ")
    private String email;
    
    @NotEmpty(message = "Họ tên không được để trống")
    private String fullName;
    
    @NotEmpty(message = "Số điện thoại không được để trống")
    private String phoneNumber;
    
    // Bỏ ràng buộc @NotEmpty vì trường này được tạo sau khi upload file
    private String cvFileUrl;
    
    // Các trường cho upload file base64
    @NotEmpty(message = "File CV không được để trống")
    private String cvFileData;
    private String cvFileName;
    private String cvFileType;
    
    private String additionalInfo;
    
    // Explicit getters and setters to resolve compilation issues
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getFullName() { return fullName; }
    public void setFullName(String fullName) { this.fullName = fullName; }
    
    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    
    public String getCvFileUrl() { return cvFileUrl; }
    public void setCvFileUrl(String cvFileUrl) { this.cvFileUrl = cvFileUrl; }
    
    public String getCvFileData() { return cvFileData; }
    public void setCvFileData(String cvFileData) { this.cvFileData = cvFileData; }
    
    public String getCvFileName() { return cvFileName; }
    public void setCvFileName(String cvFileName) { this.cvFileName = cvFileName; }
    
    public String getCvFileType() { return cvFileType; }
    public void setCvFileType(String cvFileType) { this.cvFileType = cvFileType; }
    
    public String getAdditionalInfo() { return additionalInfo; }
    public void setAdditionalInfo(String additionalInfo) { this.additionalInfo = additionalInfo; }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/TimetableEventDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonFormat;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TimetableEventDto {
    private Long id;
    private String title;
    private String description;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime startDatetime;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime endDatetime;
    private String eventType;
    private Long classroomId;
    private String classroomName;
    private Long lectureId; // Add lectureId field for attendance navigation
    private Long createdBy;
    private String location;
    private Boolean isAllDay;
    private Integer reminderMinutes;
    private String color;
    private String recurringRule;
    private Long parentEventId;
    private Boolean isCancelled;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime createdAt;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime updatedAt;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/UpdateLectureDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonProperty;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UpdateLectureDto {
    
    @NotNull(message = "Lecture ID is required")
    @JsonProperty("id")
    private Long id;
    
    @NotBlank(message = "Title is required")
    @JsonProperty("title")
    private String title;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("startTime")
    private LocalDateTime startTime;
    
    @JsonProperty("endTime")
    private LocalDateTime endTime;
    
    @JsonProperty("type")
    private String type;
    
    @JsonProperty("roomLocation")
    private String roomLocation;
    
    @JsonProperty("maxAttendees")
    private Integer maxAttendees;
    
    @JsonProperty("isRecordingEnabled")
    private Boolean isRecordingEnabled;
    
    @JsonProperty("meetingUrl")
    private String meetingUrl;
    
    @JsonProperty("materials")
    private String materials;
    
    @JsonProperty("status")
    private String status; // SCHEDULED, ONGOING, COMPLETED, CANCELLED
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/UploadMaterialDto.java">
package com.classroomapp.classroombackend.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UploadMaterialDto {
    @NotBlank(message = "Title is required")
    private String title;
    
    private String description;
    
    @NotNull(message = "Classroom ID is required")
    private Long classroomId;
    
    private Boolean isPublic = true;
    
    // Explicit getters and setters to resolve compilation issues
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public Long getClassroomId() { return classroomId; }
    public void setClassroomId(Long classroomId) { this.classroomId = classroomId; }
    
    public Boolean getIsPublic() { return isPublic; }
    public void setIsPublic(Boolean isPublic) { this.isPublic = isPublic; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/dto/UserDto.java">
package com.classroomapp.classroombackend.dto;

import java.time.LocalDateTime;
import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Consolidated UserDto that combines features from both previous versions
 * Supports both detailed user information and simple role-based representation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private Long id;

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;

    @NotBlank(message = "Full name is required")
    private String fullName;

    // Alternative name field for compatibility with usermanagement version
    private String name;

    private Integer roleId;

    // Role names as Set<String> for compatibility with usermanagement version
    private Set<String> roles;

    private LocalDateTime createdAt;

    private String status;

    // Enabled flag for compatibility with usermanagement version
    private boolean enabled;

    // Password is not included in response DTO for security
    // When needed, a separate DTO should be used for password changes

    // Additional constructor for backwards compatibility
    public UserDto(Long id, String username, String email, String fullName, Integer roleId) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.fullName = fullName;
        this.name = fullName; // Map fullName to name for compatibility
        this.roleId = roleId;
    }

    // Constructor for usermanagement version compatibility
    public UserDto(Long id, String name, String email, boolean enabled, Set<String> roles) {
        this.id = id;
        this.name = name;
        this.fullName = name; // Map name to fullName for compatibility
        this.email = email;
        this.enabled = enabled;
        this.roles = roles;
    }

    // Helper method to get name (prioritizes fullName, falls back to name)
    public String getDisplayName() {
        return fullName != null ? fullName : name;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/BusinessLogicException.java">
package com.classroomapp.classroombackend.exception;

/**
 * Exception for business logic errors that should not trigger transaction rollback.
 * This exception is used for validation errors, duplicate data, etc.
 */
public class BusinessLogicException extends RuntimeException {
    
    public BusinessLogicException(String message) {
        super(message);
    }
    
    public BusinessLogicException(String message, Throwable cause) {
        super(message, cause);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/ErrorResponse.java">
package com.classroomapp.classroombackend.exception;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Standard error response structure for API errors
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/FileStorageException.java">
package com.classroomapp.classroombackend.exception;

public class FileStorageException extends RuntimeException {
    public FileStorageException(String message) {
        super(message);
    }

    public FileStorageException(String message, Throwable cause) {
        super(message, cause);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/GlobalExceptionHandler.java">
package com.classroomapp.classroombackend.exception;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import lombok.extern.slf4j.Slf4j;

/**
 * Handles exceptions globally for the application
 */
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * Handle specific ResourceNotFoundException
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        log.error("Resource not found: {}", ex.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Not Found");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }
    
    /**
     * Handle validation errors from @Valid annotation
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        log.error("Validation error: {}", ex.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        body.put("message", "Validation failed");
        body.put("errors", errors);
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    
    /**
     * Handle authentication exceptions
     */
    @ExceptionHandler({AuthenticationException.class, BadCredentialsException.class, UsernameNotFoundException.class})
    public ResponseEntity<?> handleAuthenticationException(Exception ex, WebRequest request) {
        log.error("Authentication error: {}", ex.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.UNAUTHORIZED.value());
        body.put("error", "Unauthorized");
        body.put("message", "Authentication failed: " + ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.UNAUTHORIZED);
    }
    
    /**
     * Handle access denied exceptions
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex, WebRequest request) {
        log.error("Access denied: {}", ex.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.FORBIDDEN.value());
        body.put("error", "Forbidden");
        body.put("message", "Access denied: You do not have permission to access this resource");
        body.put("path", request.getDescription(false).replace("uri=", ""));
        body.put("security_message", ex.getMessage());
        
        return new ResponseEntity<>(body, HttpStatus.FORBIDDEN);
    }
    
    /**
     * Handle 404 Not Found errors
     */
    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<?> handleNoResourceFoundException(NoResourceFoundException ex, WebRequest request) {
        log.error("Resource not found: {}", ex.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Not Found");
        body.put("message", "The requested resource was not found");
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }
    
    /**
     * Handle general exceptions
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {
        log.error("Global exception: {}", ex.getMessage(), ex);
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", "An unexpected error occurred");
        body.put("path", request.getDescription(false).replace("uri=", ""));
        body.put("exception_type", ex.getClass().getName());
        
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    /**
     * Handle IllegalArgumentException
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<?> handleIllegalArgumentException(
            IllegalArgumentException exception, WebRequest request) {
        
        log.error("Validation error: {}", exception.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", exception.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    
    /**
     * Handle business logic exceptions with 400 Bad Request
     */
    @ExceptionHandler(BusinessLogicException.class)
    public ResponseEntity<?> handleBusinessLogicException(
            BusinessLogicException exception, WebRequest request) {
        
        log.warn("Business logic error: {}", exception.getMessage());
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", new Date());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", exception.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/ResourceNotFoundException.java">
package com.classroomapp.classroombackend.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested resource cannot be found
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    
    private static final long serialVersionUID = 1L;

    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     * Constructor with resourceName, fieldName, and fieldValue
     * 
     * @param resourceName the name of the resource being requested
     * @param fieldName the field name used for the lookup
     * @param fieldValue the value of the field for the lookup
     */
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s: %s", resourceName, fieldName, fieldValue));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/UnauthorizedException.java">
package com.classroomapp.classroombackend.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.FORBIDDEN)
public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/exception/ValidationErrorResponse.java">
package com.classroomapp.classroombackend.exception;

import java.time.LocalDateTime;
import java.util.Map;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Validation error response with field errors
 */
@Getter
@Setter
@NoArgsConstructor
public class ValidationErrorResponse extends ErrorResponse {
    private Map<String, String> errors;
    
    public ValidationErrorResponse(LocalDateTime timestamp, int status, String error, String message, String path, Map<String, String> errors) {
        super(timestamp, status, error, message, path);
        this.errors = errors;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/filter/JwtAuthenticationFilter.java">
package com.classroomapp.classroombackend.filter;

import java.io.IOException;
import java.util.Enumeration;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import com.classroomapp.classroombackend.security.JwtUtil;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;

/**
 * JWT authentication filter for validating tokens in request header
 * This filter is executed for every request to validate JWT tokens
 * and set up security context if the token is valid.
 */
@Component
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final Logger log = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
    
    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
        try {
            String requestURI = request.getRequestURI();
            log.info("JWT Filter - Processing request: {} {}", request.getMethod(), requestURI);
            
            String token = getTokenFromRequest(request);
            log.info("JWT Filter - Token present: {}", token != null && !token.isEmpty());

            // Print headers for debugging in development
            if (requestURI.contains("/approve") || requestURI.contains("/test")) {
                log.info("===== REQUEST HEADERS FOR {} =====", requestURI);
                Enumeration<String> headerNames = request.getHeaderNames();
                while (headerNames.hasMoreElements()) {
                    String headerName = headerNames.nextElement();
                    // Skip logging cookies and other sensitive headers
                    if (!headerName.toLowerCase().contains("cookie")) {
                        log.info("Header: {} = {}", headerName, request.getHeader(headerName));
                    }
                }
            }
            
            if (token != null && !token.isEmpty()) {
                log.info("JWT Filter - Token (first 20 chars): {}", token.substring(0, Math.min(token.length(), 20)) + "...");
            }

            // Kiểm tra và xác thực token
            if (StringUtils.hasText(token) && jwtUtil.validateToken(token)) {
                // Lấy subject từ token (đã được cấu hình là email)
                String subject = jwtUtil.getSubjectFromToken(token);
                if (subject == null) {
                    log.warn("JWT Filter - Subject from token is null");
                    filterChain.doFilter(request, response);
                    return;
                }

                log.info("JWT Filter - Subject from token: {}", subject);
                log.info("JWT Filter - Token validation successful, loading user details...");

                // Tải thông tin người dùng đầy đủ từ database
                // CustomUserDetailsService sẽ xử lý việc tìm user bằng email hoặc username
                org.springframework.security.core.userdetails.UserDetails userDetails =
                        userDetailsService.loadUserByUsername(subject);

                // Kiểm tra nếu người dùng hợp lệ và có thể xác thực
                if (userDetails != null) {
                    // Tạo đối tượng xác thực với UserDetails làm principal
                    UsernamePasswordAuthenticationToken authentication = 
                            new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    
                    // Set request details in authentication object
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    
                    // Set the authentication in the Security context
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    
                    log.info("JWT Filter - Authentication set for user: {} with roles: {}", 
                        subject, userDetails.getAuthorities().stream().map(auth -> auth.getAuthority()).collect(Collectors.joining(", ")));
                } else {
                    log.warn("JWT Filter - Could not find user with subject (email): {}", subject);
                }
            } else if (StringUtils.hasText(token)) {
                log.warn("JWT Filter - Invalid token");
            } else if (requestURI.contains("/approve") || requestURI.contains("/reject")) {
                log.warn("JWT Filter - No token for approve/reject endpoint! This will cause a 403 error.");
            }
        } catch (Exception e) {
            log.error("JWT Filter - Exception: {}", e.getMessage(), e);
            // Không throw exception để đảm bảo request tiếp tục xử lý
        }

        filterChain.doFilter(request, response);
    }

    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/client/MCPClient.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/tools/DatabaseQueryTool.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/tools/DatabaseSchemaTool.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/tools/TableInspectionTool.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/MCPRequest.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/MCPResponse.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/MCPServer.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/mcp/MCPTool.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/assignmentmanagement/Assignment.java">
package com.classroomapp.classroombackend.model.assignmentmanagement;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "assignments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Assignment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(columnDefinition = "NVARCHAR(255)")
    private String title;

    @Lob
    @Column(length = 2000, columnDefinition = "NTEXT")
    private String description;

    @NotNull
    @Future // Must be a future date
    @Column(name = "due_date")
    private LocalDateTime dueDate;

    @Min(0) // Points must be positive
    private Integer points;

    @OneToMany(
            mappedBy = "assignment",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<AssignmentAttachment> attachments = new ArrayList<>();

    // The classroom this assignment belongs to
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id")
    private Classroom classroom;

    public void addAttachment(AssignmentAttachment attachment) {
        attachments.add(attachment);
        attachment.setAssignment(this);
    }

    public void removeAttachment(AssignmentAttachment attachment) {
        attachments.remove(attachment);
        attachment.setAssignment(null);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/assignmentmanagement/AssignmentAttachment.java">
package com.classroomapp.classroombackend.model.assignmentmanagement;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "assignment_attachments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AssignmentAttachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String fileName;

    @Column(nullable = false)
    private String fileUrl;

    private String fileType;

    private long fileSize;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignment_id", nullable = false)
    private Assignment assignment;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/assignmentmanagement/Submission.java">
package com.classroomapp.classroombackend.model.assignmentmanagement;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "submissions", 
       uniqueConstraints = @UniqueConstraint(
           columnNames = {"assignment_id", "student_id"},
           name = "uk_submission_assignment_student"
       ))
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Submission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // The assignment this submission is for
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignment_id")
    private Assignment assignment;

    // The student who submitted
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id")
    private User student;

    @Column(length = 2000, columnDefinition = "NVARCHAR(2000)")
    private String comment;
    
    private LocalDateTime submittedAt;

    @OneToMany(
            mappedBy = "submission",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<SubmissionAttachment> attachments = new ArrayList<>();
    
    // Grading information
    @Min(0) // Score must be non-negative
    private Integer score;
    
    @Column(columnDefinition = "NVARCHAR(MAX)")
    private String feedback;
    
    private LocalDateTime gradedAt;
    
    // The teacher who graded the submission
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "graded_by_id")
    private User gradedBy;

    public Submission(Assignment assignment, User student) {
        this.assignment = assignment;
        this.student = student;
    }

    public void addAttachment(SubmissionAttachment attachment) {
        attachments.add(attachment);
        attachment.setSubmission(this);
    }

    public void removeAttachment(SubmissionAttachment attachment) {
        attachments.remove(attachment);
        attachment.setSubmission(null);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/assignmentmanagement/SubmissionAttachment.java">
package com.classroomapp.classroombackend.model.assignmentmanagement;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.dto.FileUploadResponse;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "submission_attachments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SubmissionAttachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    private String fileName;

    @Column(nullable = true)  // Made nullable to avoid DDL error with existing data
    private String fileUrl;

    private String fileType;

    @Column(nullable = true)  // Made nullable to avoid DDL error with existing data
    private Long fileSize;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "submission_id", nullable = false)
    private Submission submission;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    public SubmissionAttachment(FileUploadResponse fileInfo, Submission submission) {
        this.fileName = fileInfo.getFileName();
        this.fileUrl = fileInfo.getFileUrl();
        this.fileType = fileInfo.getFileType();
        this.fileSize = fileInfo.getSize();
        this.submission = submission;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/attendancemanagement/Attendance.java">
package com.classroomapp.classroombackend.model.attendancemanagement;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "attendance_records", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"session_id", "student_id"})
})
@Data

@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Attendance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "session_id", nullable = false)
    private AttendanceSession session;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", nullable = false)
    private User student;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AttendanceStatus status;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/attendancemanagement/AttendanceSession.java">
package com.classroomapp.classroombackend.model.attendancemanagement;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "attendance_sessions")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AttendanceSession {
    public enum SessionStatus {
        OPEN,
        CLOSED
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = jakarta.persistence.FetchType.LAZY)
    @JoinColumn(name = "lecture_id", nullable = false)
    private Lecture lecture;

    @ManyToOne(fetch = jakarta.persistence.FetchType.LAZY)
    @JoinColumn(name = "classroom_id", nullable = false)
    private Classroom classroom;

    @Column(name = "created_at", nullable = true)
    private LocalDateTime createdAt;

    @Column(name = "expires_at", nullable = true)
    private LocalDateTime expiresAt;

    @Column(nullable = true)
    @Builder.Default
    private Boolean isOpen = true;

    private String qrCodeData; // Can store a unique identifier for the QR code

    @OneToMany(mappedBy = "session", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Attendance> records;

    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private SessionStatus status;

    @Column(name = "start_time")
    private Instant startTime;

    @Column(name = "end_time")
    private Instant endTime;

    @Column(nullable = false)
    private LocalDate sessionDate;

    @Column(name = "auto_mark_teacher_attendance", nullable = false)
    @Builder.Default
    private boolean autoMarkTeacherAttendance = false;

    @Column(name = "is_active", nullable = false)
    @Builder.Default
    private boolean isActive = true;
    
    @Column(name = "teacher_clock_in_time", nullable = true)
    private LocalDateTime teacherClockInTime;

    public void setTeacherClockInTime(LocalDateTime teacherClockInTime) {
        this.teacherClockInTime = teacherClockInTime;
    }

    public SessionStatus getStatus() {
        return status;
    }

    public void setStatus(SessionStatus status) {
        this.status = status;
    }

    public Instant getStartTime() {
        return startTime;
    }

    public void setStartTime(Instant startTime) {
        this.startTime = startTime;
    }

    public Instant getEndTime() {
        return endTime;
    }

    public void setEndTime(Instant endTime) {
        this.endTime = endTime;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/attendancemanagement/AttendanceStatus.java">
package com.classroomapp.classroombackend.model.attendancemanagement;

public enum AttendanceStatus {
    PRESENT, // Có mặt
    ABSENT,  // Vắng
    LATE,    // Muộn
    EXCUSED  // Có phép
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/Classroom.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "classrooms")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Classroom {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(columnDefinition = "NVARCHAR(255)")
    private String name;

    @Column(columnDefinition = "NVARCHAR(1000)")
    private String description;

    @Column(columnDefinition = "NVARCHAR(50)")
    private String section;

    @Column(columnDefinition = "NVARCHAR(100)")
    private String subject;    // The teacher who created/owns this classroom
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "teacher_id")
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "password"})
    private User teacher;

    @Column(name = "course_id")
    private Long courseId;

    @OneToMany(mappedBy = "classroom", fetch = FetchType.LAZY)
    private Set<ClassroomEnrollment> enrollments = new HashSet<>();

    public Set<User> getStudents() {
        Set<User> students = new HashSet<>();
        for (ClassroomEnrollment enrollment : this.enrollments) {
            students.add(enrollment.getUser());
        }
        return students;
    }
    
    // Syllabus for this classroom - one classroom has one syllabus
    @OneToOne(mappedBy = "classroom", fetch = FetchType.LAZY)
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "classroom"})
    private Syllabus syllabus;
    
    // Schedules for this classroom - one classroom has many schedule entries
    @OneToMany(mappedBy = "classroom", fetch = FetchType.LAZY)
    private List<Schedule> schedules = new ArrayList<>();

    @OneToMany(mappedBy = "classroom", fetch = FetchType.LAZY)
    private List<Lecture> lectures = new ArrayList<>();
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/ClassroomEnrollment.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.MapsId;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Entity
@Table(name = "classroom_enrollments")
public class ClassroomEnrollment {

    @EmbeddedId
    private ClassroomEnrollmentId id;

    @ManyToOne
    @MapsId("classroomId")
    @JoinColumn(name = "classroom_id")
    private Classroom classroom;

    @ManyToOne
    @MapsId("userId")
    @JoinColumn(name = "user_id")
    private User user;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/ClassroomEnrollmentId.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import java.io.Serializable;
import java.util.Objects;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;

@Embeddable
public class ClassroomEnrollmentId implements Serializable {

    @Column(name = "classroom_id")
    private Long classroomId;

    @Column(name = "user_id")
    private Long userId;

    public ClassroomEnrollmentId() {
    }

    public ClassroomEnrollmentId(Long classroomId, Long userId) {
        this.classroomId = classroomId;
        this.userId = userId;
    }

    public Long getClassroomId() {
        return classroomId;
    }

    public void setClassroomId(Long classroomId) {
        this.classroomId = classroomId;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ClassroomEnrollmentId that = (ClassroomEnrollmentId) o;
        return Objects.equals(classroomId, that.classroomId) &&
               Objects.equals(userId, that.userId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(classroomId, userId);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/ClassroomSchedule.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import java.time.DayOfWeek;
import java.time.LocalTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "classroom_schedules")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ClassroomSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "day_of_week")
    private DayOfWeek dayOfWeek;
    
    @NotNull
    @Column(name = "start_time")
    private LocalTime startTime;
    
    @NotNull
    @Column(name = "end_time")
    private LocalTime endTime;
    
    @NotBlank
    private String location;
    
    @Column(length = 500)
    private String notes;
    
    @Column(name = "is_recurring")
    private boolean isRecurring = true;
    
    // Many-to-One relationship with Classroom
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id")
    private Classroom classroom;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/Course.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name = "courses")
@Data
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, columnDefinition = "NVARCHAR(255)")
    private String name;

    @Column(name = "description", columnDefinition = "NVARCHAR(MAX)")
    private String description;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/classroommanagement/Syllabus.java">
package com.classroomapp.classroombackend.model.classroommanagement;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "syllabuses")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Syllabus {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank
    private String title;
    
    @Column(length = 5000)
    private String content;
    
    @Column(name = "learning_objectives", length = 2000)
    private String learningObjectives;
    
    @Column(name = "required_materials", length = 1000)
    private String requiredMaterials;
    
    @Column(name = "grading_criteria", length = 1000)
    private String gradingCriteria;
    
    // One-to-One relationship with Classroom
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", unique = true)
    private Classroom classroom;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/exammangement/Exam.java">
package com.classroomapp.classroombackend.model.exammangement;

import java.time.Instant;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.Data;

@Entity(name = "Exam")
@Table(name = "exams")
@Data
public class Exam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(columnDefinition = "NVARCHAR(255)", nullable = false)
    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", nullable = false)
    private Classroom classroom;

    @Column(nullable = false)
    private Instant startTime; // The time when the exam becomes available

    @Column(nullable = false)
    private Instant endTime;   // The time when the exam is no longer available

    @Column(nullable = false)
    private Integer durationInMinutes; // The duration students have to complete the exam
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/exammangement/ExamSubmission.java">
package com.classroomapp.classroombackend.model.exammangement;

import java.time.Instant;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "exam_submissions")
@Data
@NoArgsConstructor
public class ExamSubmission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "exam_id", nullable = false)
    private Exam exam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", nullable = false)
    private User student;

    @Column(nullable = false)
    private Instant startedAt; // Time when the student started the exam

    private Instant submittedAt; // Time when the student submitted the exam

    @Column(length = 2000)
    private String content; // Could be answers, comments, etc.

    // Similar to SubmissionAttachment, you might want a separate entity for attachments
    // @OneToMany(mappedBy = "examSubmission", cascade = CascadeType.ALL, orphanRemoval = true)
    // private List<ExamSubmissionAttachment> attachments = new ArrayList<>();

    // Grading information
    private Integer score;
    private String feedback;
    private Instant gradedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "graded_by_id")
    private User gradedBy;

    public ExamSubmission(Exam exam, User student, Instant startedAt) {
        this.exam = exam;
        this.student = student;
        this.startedAt = startedAt;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/usermanagement/Role.java">
package com.classroomapp.classroombackend.model.usermanagement;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(length = 20, unique = true)
    private String name;

    public Role(String name) {
        this.name = name;
    }
    
    // Explicit setters to resolve compilation issues
    public void setId(int id) { this.id = id; }
    public void setId(Integer id) { this.id = id; }
    public void setName(String name) { this.name = name; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/usermanagement/User.java">
package com.classroomapp.classroombackend.model.usermanagement;

import java.time.LocalDate;
import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(nullable = false, unique = true)
    private String username;

    @NotBlank
    @Column(nullable = false, columnDefinition = "NVARCHAR(255)")
    private String password;

    @NotBlank
    @Email
    @Column(nullable = false, columnDefinition = "NVARCHAR(255)", unique = true)
    private String email;

    @Column(name = "full_name", columnDefinition = "NVARCHAR(255)")
    private String fullName;

    @Column(name = "phone_number", length = 20)
    private String phoneNumber;

    @Column(name = "role_id")
    private Integer roleId;

    @Column(name = "enrollment_date")
    private LocalDate enrollmentDate;

    @Column(name = "hire_date")
    private LocalDate hireDate;

    @Column(columnDefinition = "NVARCHAR(100)")
    private String department;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(columnDefinition = "NVARCHAR(10) default 'active'")
    private String status = "active";
    
    /**
     * Get the role name as String based on the roleId
     * 
     * @return String representation of the user's role
     */
    public String getRole() {
        if (roleId == null) return "USER";
        
        switch (roleId) {
            case 1: return "STUDENT";
            case 2: return "TEACHER";
            case 3: return "MANAGER";
            case 4: return "ADMIN";
            default: return "USER";
        }
    }
    
    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Explicit getters to resolve compilation issues
    public Long getId() { return id; }
    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getEmail() { return email; }
    public String getFullName() { return fullName; }
    public String getPhoneNumber() { return phoneNumber; }
    public Integer getRoleId() { return roleId; }
    public LocalDate getEnrollmentDate() { return enrollmentDate; }
    public LocalDate getHireDate() { return hireDate; }
    public String getDepartment() { return department; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public String getStatus() { return status; }
    
    // Explicit setters to resolve compilation issues
    public void setId(Long id) { this.id = id; }
    public void setUsername(String username) { this.username = username; }
    public void setPassword(String password) { this.password = password; }
    public void setEmail(String email) { this.email = email; }
    public void setFullName(String fullName) { this.fullName = fullName; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    public void setRoleId(Integer roleId) { this.roleId = roleId; }
    public void setRoleId(int roleId) { this.roleId = roleId; }
    public void setEnrollmentDate(LocalDate enrollmentDate) { this.enrollmentDate = enrollmentDate; }
    public void setHireDate(LocalDate hireDate) { this.hireDate = hireDate; }
    public void setDepartment(String department) { this.department = department; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    public void setStatus(String status) { this.status = status; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Accomplishment.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDate;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "accomplishments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Accomplishment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(length = 255)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "issue_date")
    private LocalDate issueDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User student;
    
    // Legacy fields - can be deprecated later
    @Column(name = "course_title")
    private String courseTitle;
    
    private String subject;
    
    @Column(name = "teacher_name")
    private String teacherName;
    
    private Double grade;
    
    @Column(name = "completion_date")
    private LocalDate completionDate;
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/AllowedIp.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "allowed_ips")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AllowedIp {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(name = "ip_address", nullable = false, unique = true)
    private String ipAddress;

    @Column(name = "description")
    private String description;

    @Column(name = "is_active")
    private Boolean isActive = true;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Announcement.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "announcements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Announcement {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(nullable = false, columnDefinition = "NVARCHAR(255)")
    private String title;

    @NotBlank
    @Column(nullable = false, columnDefinition = "NTEXT")
    private String content;

    @Column(name = "classroom_id")
    private Long classroomId;

    @NotNull
    @Column(name = "created_by", nullable = false)
    private Long createdBy;

    @Enumerated(EnumType.STRING)
    @Column(name = "target_audience")
    private TargetAudience targetAudience = TargetAudience.ALL;

    @Enumerated(EnumType.STRING)
    private Priority priority = Priority.NORMAL;

    @Column(name = "scheduled_date")
    private LocalDateTime scheduledDate;

    @Column(name = "expiry_date")
    private LocalDateTime expiryDate;

    @Column(name = "is_pinned")
    private Boolean isPinned = false;

    @Column(name = "attachments_count")
    private Integer attachmentsCount = 0;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt = LocalDateTime.now();

    @Enumerated(EnumType.STRING)
    private AnnouncementStatus status = AnnouncementStatus.ACTIVE;    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "teacher", "students", "syllabus"})
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", insertable = false, updatable = false)
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "password"})
    private User creator;

    public enum TargetAudience {
        ALL, STUDENTS, TEACHERS
    }

    public enum Priority {
        LOW, NORMAL, HIGH, URGENT
    }

    public enum AnnouncementStatus {
        ACTIVE, ARCHIVED, DELETED
    }

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/AnnouncementAttachment.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "announcement_attachments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementAttachment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "announcement_id", nullable = false)
    private Long announcementId;

    @NotBlank
    @Column(name = "file_name", nullable = false)
    private String fileName;

    @NotBlank
    @Column(name = "file_path", nullable = false, length = 500)
    private String filePath;

    @Column(name = "file_size")
    private Long fileSize;

    @Column(name = "file_type", length = 100)
    private String fileType;

    @Column(name = "uploaded_at")
    private LocalDateTime uploadedAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "announcement_id", insertable = false, updatable = false)
    private Announcement announcement;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/AnnouncementRead.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "announcement_reads")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementRead {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "announcement_id", nullable = false)
    private Long announcementId;

    @NotNull
    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "read_at")
    private LocalDateTime readAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "announcement_id", insertable = false, updatable = false)
    private Announcement announcement;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Assessment.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "assessments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Assessment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lecture_id", nullable = false)
    private Lecture lecture;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false)
    private String assessmentType; // e.g., "QUIZ", "POLL"

    private Integer timeLimit; // in minutes

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Blog.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "blogs")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Blog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String slug;
    
    @NotBlank
    @Column(nullable = false, columnDefinition = "NVARCHAR(200)")
    private String title;

    @Column(columnDefinition = "NTEXT")
    private String description;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "video_url", length = 500)
    private String videoUrl;

    @Column(name = "published_date")
    private LocalDateTime publishedDate;

    @Column(name = "last_edited_date")
    private LocalDateTime lastEditedDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = true)
    private User author;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "last_edited_by", nullable = true)
    private User lastEditedBy;

    @Column(name = "is_published", columnDefinition = "bit default 0")
    private Boolean isPublished = false;
      @Column(columnDefinition = "NVARCHAR(50) default 'draft'")
    private String status;
    
    @Column(name = "tags", columnDefinition = "NVARCHAR(255)")
    private String tags;
    
    @Column(name = "thumbnail_url", length = 500)
    private String thumbnailUrl;
    
    @Column(name = "view_count")
    private Integer viewCount = 0;    @Lob
    @Column(columnDefinition = "NTEXT")
    private String content;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getSlug() {
        return slug;
    }

    public void setSlug(String slug) {
        this.slug = slug;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public String getVideoUrl() {
        return videoUrl;
    }

    public void setVideoUrl(String videoUrl) {
        this.videoUrl = videoUrl;
    }

    public LocalDateTime getPublishedDate() {
        return publishedDate;
    }

    public void setPublishedDate(LocalDateTime publishedDate) {
        this.publishedDate = publishedDate;
    }

    public LocalDateTime getLastEditedDate() {
        return lastEditedDate;
    }

    public void setLastEditedDate(LocalDateTime lastEditedDate) {
        this.lastEditedDate = lastEditedDate;
    }

    public User getAuthor() {
        return author;
    }

    public void setAuthor(User author) {
        this.author = author;
    }

    public User getLastEditedBy() {
        return lastEditedBy;
    }

    public void setLastEditedBy(User lastEditedBy) {
        this.lastEditedBy = lastEditedBy;
    }

    public Boolean getIsPublished() {
        return isPublished;
    }

    public void setIsPublished(Boolean isPublished) {
        this.isPublished = isPublished;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getTags() {
        return tags;
    }

    public void setTags(String tags) {
        this.tags = tags;
    }

    public String getThumbnailUrl() {
        return thumbnailUrl;
    }

    public void setThumbnailUrl(String thumbnailUrl) {
        this.thumbnailUrl = thumbnailUrl;
    }

    public Integer getViewCount() {
        return viewCount;
    }

    public void setViewCount(Integer viewCount) {
        this.viewCount = viewCount;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/ClassSession.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "class_sessions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ClassSession {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "classroom_id", nullable = false)
    private Long classroomId;

    @NotNull
    @Column(name = "session_date", nullable = false)
    private LocalDate sessionDate;

    @NotNull
    @Column(name = "start_time", nullable = false)
    private LocalTime startTime;

    @NotNull
    @Column(name = "end_time", nullable = false)
    private LocalTime endTime;

    private String topic;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(name = "session_type")
    private SessionType sessionType = SessionType.REGULAR;

    @NotNull
    @Column(name = "created_by", nullable = false)
    private Long createdBy;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", insertable = false, updatable = false)
    private User creator;

    public enum SessionType {
        REGULAR, MAKEUP, REVIEW, EXAM
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/CourseFeedback.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "course_feedback")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CourseFeedback {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", nullable = false)
    private User student;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", nullable = false)
    private Classroom classroom;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "teacher_id", nullable = false)
    private User teacher;
    
    @Column(nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;
    
    @Column(nullable = false)
    private Integer overallRating; // 1-5 stars
    
    @Column
    private Integer teachingQualityRating; // 1-5 stars
    
    @Column
    private Integer courseMaterialRating; // 1-5 stars
    
    @Column
    private Integer supportRating; // 1-5 stars
    
    @Column(length = 50)
    private String category = "GENERAL"; // GENERAL, TEACHING, CONTENT, SUPPORT
    
    @Column(length = 50)
    private String status = "SUBMITTED"; // SUBMITTED, REVIEWED, ACKNOWLEDGED
    
    @Column
    private Boolean isAnonymous = false;
    
    @Column
    private LocalDateTime reviewedAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reviewed_by")
    private User reviewedBy;
    
    @Column(columnDefinition = "TEXT")
    private String response;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    public void markAsReviewed(User reviewer, String response) {
        this.reviewedBy = reviewer;
        this.response = response;
        this.reviewedAt = LocalDateTime.now();
        this.status = "REVIEWED";
        this.updatedAt = LocalDateTime.now();
    }
    
    public void acknowledge() {
        this.status = "ACKNOWLEDGED";
        this.updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/CourseMaterial.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "course_materials")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseMaterial {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(nullable = false, columnDefinition = "NVARCHAR(255)")
    private String title;

    @Column(columnDefinition = "NTEXT")
    private String description;

    @Column(name = "file_path", length = 500)
    private String filePath;

    @Column(name = "file_name")
    private String fileName;

    @Column(name = "file_size")
    private Long fileSize;

    @Column(name = "file_type", length = 100)
    private String fileType;

    @Column(name = "upload_date", nullable = false)
    private LocalDateTime uploadDate = LocalDateTime.now();

    @NotNull
    @Column(name = "classroom_id", nullable = false)
    private Long classroomId;

    @NotNull
    @Column(name = "uploaded_by", nullable = false)
    private Long uploadedBy;

    @Column(name = "is_public")
    private Boolean isPublic = true;

    @Column(name = "download_count")
    private Integer downloadCount = 0;

    @Column(name = "version_number")
    private Integer versionNumber = 1;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "uploaded_by", insertable = false, updatable = false)
    private User uploader;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/CourseSchedule.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDate;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Entity
@Table(name = "course_schedule")
@Data
public class CourseSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "classroom_id", nullable = false)
    private Long classroomId;

    @NotBlank
    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull
    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;

    @NotNull
    @Column(name = "end_time", nullable = false)
    private LocalDateTime endTime;

    private String location;

    @Enumerated(EnumType.STRING)
    @Column(name = "schedule_type")
    private ScheduleType scheduleType = ScheduleType.LECTURE;

    @Enumerated(EnumType.STRING)
    @Column(name = "recurring_type")
    private RecurringType recurringType;

    @Column(name = "recurring_end_date")
    private LocalDate recurringEndDate;

    @Column(name = "is_online")
    private Boolean isOnline = false;

    @Column(name = "meeting_link", length = 500)
    private String meetingLink;

    @NotNull
    @Column(name = "created_by", nullable = false)
    private Long createdBy;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", insertable = false, updatable = false)
    private User creator;

    public enum ScheduleType {
        LECTURE, LAB, EXAM, MEETING
    }

    public enum RecurringType {
        NONE, DAILY, WEEKLY, MONTHLY
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/EducationalRole.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/EventAttendee.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "event_attendees")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EventAttendee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "event_id", nullable = false)
    private Long eventId;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "attendance_status")
    private AttendanceStatus attendanceStatus = AttendanceStatus.INVITED;

    @Column(name = "response_date")
    private LocalDateTime responseDate;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "event_id", insertable = false, updatable = false)
    private TimetableEvent event;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;

    public enum AttendanceStatus {
        INVITED, ACCEPTED, DECLINED, TENTATIVE
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Exam.java">
package com.classroomapp.classroombackend.model;

import java.time.OffsetDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.Data;

@Entity(name = "LegacyExam")
@Table(name = "exams")
@Data
public class Exam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private Integer durationInMinutes;

    @Column(nullable = false)
    private OffsetDateTime startTime;

    @Column(nullable = false)
    private OffsetDateTime endTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", nullable = false)
    private Classroom classroom;
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/GradingDetail.java">
package com.classroomapp.classroombackend.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "grading_details")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GradingDetail {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "submission_id", nullable = false)
    private Long submissionId;

    @NotNull
    @Column(name = "rubric_id", nullable = false)
    private Long rubricId;

    @NotNull
    @Column(name = "points_awarded", nullable = false, precision = 10, scale = 2)
    private BigDecimal pointsAwarded;

    @Column(columnDefinition = "TEXT")
    private String comments;

    @NotNull
    @Column(name = "graded_by", nullable = false)
    private Long gradedBy;

    @Column(name = "graded_at")
    private LocalDateTime gradedAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "submission_id", insertable = false, updatable = false)
    private Submission submission;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "rubric_id", insertable = false, updatable = false)
    private GradingRubric rubric;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "graded_by", insertable = false, updatable = false)
    private User grader;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/GradingRubric.java">
package com.classroomapp.classroombackend.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "grading_rubrics")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class GradingRubric {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "assignment_id", nullable = false)
    private Long assignmentId;

    @NotBlank
    @Column(name = "criteria_name", nullable = false)
    private String criteriaName;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull
    @Column(name = "max_points", nullable = false, precision = 10, scale = 2)
    private BigDecimal maxPoints;

    @Column(name = "weight_percentage", precision = 5, scale = 2)
    private BigDecimal weightPercentage = BigDecimal.valueOf(100.00);

    @Column(name = "display_order")
    private Integer displayOrder = 0;

    @NotNull
    @Column(name = "created_by", nullable = false)
    private Long createdBy;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignment_id", insertable = false, updatable = false)
    private Assignment assignment;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", insertable = false, updatable = false)
    private User creator;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Lecture.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Table(name = "lectures")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Lecture {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "schedule_id")
    @ToString.Exclude
    private Schedule schedule;
    
    @Column
    private LocalDate lectureDate;
    
    @Column(nullable = false, columnDefinition = "NVARCHAR(255)")
    private String title;
    
    @Lob
    @Column(columnDefinition = "NTEXT")
    private String content;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", nullable = false)
    @ToString.Exclude
    private Classroom classroom;
    
    @OneToMany(mappedBy = "lecture", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnoreProperties("lecture")
    private List<LectureMaterial> lectureMaterials = new ArrayList<>();
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/LectureMaterial.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "lecture_materials")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LectureMaterial {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String fileName;
    
    @Column
    private String contentType;
    
    @Column
    private String downloadUrl;
    
    @Column
    private String filePath;
    
    @Column
    private Long fileSize;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lecture_id", nullable = false)
    private Lecture lecture;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/LectureRecording.java">
package com.classroomapp.classroombackend.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "lecture_recordings")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LectureRecording {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "lecture_id", nullable = false)
    private Long lectureId;

    @NotBlank
    @Column(nullable = false)
    private String title;

    @Column(name = "file_path", length = 500)
    private String filePath;

    @Column(name = "file_name")
    private String fileName;

    @Column(name = "file_size")
    private Long fileSize;

    @Column(name = "duration_minutes")
    private Integer durationMinutes;

    @Column(name = "recording_date")
    private LocalDateTime recordingDate = LocalDateTime.now();

    @Column(name = "is_public")
    private Boolean isPublic = true;

    @Column(name = "view_count")
    private Integer viewCount = 0;

    @Column(name = "thumbnail_path", length = 500)
    private String thumbnailPath;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lecture_id", insertable = false, updatable = false)
    private Lecture lecture;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/LiveStream.java">
package com.classroomapp.classroombackend.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "live_streams")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LiveStream {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "lecture_id", nullable = false)
    private Long lectureId;

    @NotBlank
    @Column(name = "stream_key", unique = true, nullable = false)
    private String streamKey;

    @Column(name = "stream_url", length = 500)
    private String streamUrl;

    @Column(name = "chat_enabled")
    private Boolean chatEnabled = true;

    @Column(name = "max_viewers")
    private Integer maxViewers = 100;

    @Column(name = "current_viewers")
    private Integer currentViewers = 0;

    @Column(name = "start_time")
    private LocalDateTime startTime;

    @Column(name = "end_time")
    private LocalDateTime endTime;

    @Enumerated(EnumType.STRING)
    private StreamStatus status = StreamStatus.SCHEDULED;

    @Column(name = "recording_enabled")
    private Boolean recordingEnabled = true;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lecture_id", insertable = false, updatable = false)
    private Lecture lecture;

    public enum StreamStatus {
        SCHEDULED, LIVE, ENDED, CANCELLED
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Notification.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "notifications")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, columnDefinition = "TEXT")
    private String message;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column
    private Boolean isRead = false;
    
    @Column
    private String sender;
    
    @Column
    private Long recipientId;
    
    @Column
    private String type = "GENERAL"; // GENERAL, URGENT, SYSTEM, ANNOUNCEMENT
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    public void markAsRead() {
        this.isRead = true;
    }
    
    // Explicit getters and setters to resolve compilation issues
    public Long getId() { return id; }
    public String getMessage() { return message; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public Boolean getIsRead() { return isRead; }
    public String getSender() { return sender; }
    
    public void setIsRead(Boolean isRead) { this.isRead = isRead; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/QuizQuestion.java">
package com.classroomapp.classroombackend.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "quiz_questions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class QuizQuestion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "assignment_id", nullable = false)
    private Long assignmentId;

    @NotBlank
    @Column(name = "question_text", nullable = false, columnDefinition = "TEXT")
    private String questionText;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "question_type", nullable = false)
    private QuestionType questionType;

    @Column(name = "correct_answer", columnDefinition = "TEXT")
    private String correctAnswer;

    @Column(precision = 10, scale = 2)
    private BigDecimal points = BigDecimal.ONE;

    @Column(name = "display_order")
    private Integer displayOrder = 0;

    @Column(columnDefinition = "TEXT")
    private String explanation;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignment_id", insertable = false, updatable = false)
    private Assignment assignment;

    public enum QuestionType {
        MULTIPLE_CHOICE, TRUE_FALSE, SHORT_ANSWER, ESSAY
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/QuizQuestionOption.java">
package com.classroomapp.classroombackend.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "quiz_question_options")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class QuizQuestionOption {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "question_id", nullable = false)
    private Long questionId;

    @NotBlank
    @Column(name = "option_text", nullable = false, columnDefinition = "TEXT")
    private String optionText;

    @Column(name = "is_correct")
    private Boolean isCorrect = false;

    @Column(name = "display_order")
    private Integer displayOrder = 0;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "question_id", insertable = false, updatable = false)
    private QuizQuestion question;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Request.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "requests")
@Data
public class Request {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = true, length = 255)
    private String email;

    @Column(name = "full_name", nullable = true, length = 255)
    private String fullName;

    @Column(name = "phone_number", nullable = true, length = 20)
    private String phoneNumber;

    @Column(name = "requested_role", nullable = true, length = 50)
    private String requestedRole = "STUDENT"; // "TEACHER" or "STUDENT" - default to STUDENT
    
    @Column(columnDefinition = "TEXT", length = 4000, nullable = true)
    private String formResponses; // JSON string containing form responses

    @Column(name = "status", nullable = true, length = 50)
    private String status = "PENDING"; // PENDING, APPROVED, REJECTED, COMPLETED

    @Column(name = "result_status", length = 50)
    private String resultStatus; // APPROVED, REJECTED, null

    @Column(columnDefinition = "TEXT", length = 4000, nullable = true)
    private String rejectReason;

    @Column(name = "created_at", nullable = true)
    private LocalDateTime createdAt;

    @Column(nullable = true)
    private LocalDateTime processedAt;

    public Request() {
        this.createdAt = LocalDateTime.now();
        this.requestedRole = "STUDENT";
        this.status = "PENDING";
        this.phoneNumber = "";
        this.email = "";
        this.fullName = "";
    }

    public Request(Long id, String email, String fullName, String phoneNumber, String requestedRole, String formResponses, String status, String rejectReason, LocalDateTime createdAt, LocalDateTime processedAt) {
        this.id = id;
        this.email = (email != null) ? email : "";
        this.fullName = (fullName != null) ? fullName : "";
        this.phoneNumber = (phoneNumber != null) ? phoneNumber : "";
        this.requestedRole = (requestedRole != null) ? requestedRole : "STUDENT";
        this.formResponses = formResponses;
        this.status = (status != null) ? status : "PENDING";
        this.rejectReason = rejectReason;
        this.createdAt = (createdAt != null) ? createdAt : LocalDateTime.now();
        this.processedAt = processedAt;
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = (createdAt != null) ? createdAt : LocalDateTime.now();
    }

    public String getResultStatus() { return resultStatus; }
    public void setResultStatus(String resultStatus) { this.resultStatus = resultStatus; }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/Schedule.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity(name = "Schedule")
@Table(name = "schedules")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Schedule {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "teacher_id", nullable = false)
    private User teacher;
    
    @ManyToOne
    @JoinColumn(name = "classroom_id", nullable = false)
    private Classroom classroom;
    
    @Column(name = "day_of_week", nullable = false, columnDefinition = "SMALLINT")
    private Integer dayOfWeek; // 0=Monday, 1=Tuesday, 2=Wednesday, 3=Thursday, 4=Friday, 5=Saturday, 6=Sunday
    
    @Column(name = "start_time", nullable = false)
    private LocalTime startTime;
    
    @Column(name = "end_time", nullable = false)
    private LocalTime endTime;
    
    @Column(name = "room", length = 50)
    private String room;
    
    @Column(name = "subject", length = 100, nullable = false)
    private String subject;
    
    @Column(name = "materials_url")
    private String materialsUrl;
    
    @Column(name = "meet_url")
    private String meetUrl;
    
    // For calculating shift or period of day
    public String getPeriod() {
        if (startTime.isBefore(LocalTime.of(12, 0))) {
            return "Morning";
        } else if (startTime.isBefore(LocalTime.of(17, 0))) {
            return "Afternoon";
        } else {
            return "Evening";
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/StudentMessage.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "student_messages")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;
    
    @ManyToOne
    @JoinColumn(name = "recipient_id", nullable = false)
    private User recipient;
      @Column(nullable = false, columnDefinition = "NVARCHAR(255)")
    private String subject;
    
    @Column(columnDefinition = "NTEXT", nullable = false)
    private String content;
    
    @Column(length = 50)
    private String messageType = "GENERAL"; // GENERAL, COMPLAINT, REQUEST, INQUIRY, URGENT
    
    @Column(length = 50)
    private String priority = "MEDIUM"; // LOW, MEDIUM, HIGH, URGENT
    
    @Column(length = 50)
    private String status = "SENT"; // SENT, READ, REPLIED, RESOLVED, ARCHIVED
    
    @Column
    private Boolean isRead = false;
    
    @Column
    private LocalDateTime readAt;
      @Column(columnDefinition = "NTEXT")
    private String reply;
    
    @Column
    private LocalDateTime repliedAt;
    
    @ManyToOne
    @JoinColumn(name = "replied_by")
    private User repliedBy;
    
    @Column
    private LocalDateTime createdAt;
    
    @Column
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    public void markAsRead() {
        this.isRead = true;
        this.readAt = LocalDateTime.now();
        this.status = "READ";
        this.updatedAt = LocalDateTime.now();
    }
    
    public void reply(String replyContent, User replier) {
        this.reply = replyContent;
        this.repliedBy = replier;
        this.repliedAt = LocalDateTime.now();
        this.status = "REPLIED";
        this.updatedAt = LocalDateTime.now();
        if (!this.isRead) {
            markAsRead();
        }
    }
    
    public void resolve() {
        this.status = "RESOLVED";
        this.updatedAt = LocalDateTime.now();
    }
    
    public void archive() {
        this.status = "ARCHIVED";
        this.updatedAt = LocalDateTime.now();
    }
    
    // Explicit getters to resolve compilation issues
    public Long getId() { return id; }
    public User getSender() { return sender; }
    public User getRecipient() { return recipient; }
    public String getSubject() { return subject; }
    public String getContent() { return content; }
    public String getMessageType() { return messageType; }
    public String getPriority() { return priority; }
    public String getStatus() { return status; }
    public Boolean getIsRead() { return isRead; }
    public LocalDateTime getReadAt() { return readAt; }
    public String getReply() { return reply; }
    public LocalDateTime getRepliedAt() { return repliedAt; }
    public User getRepliedBy() { return repliedBy; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    
    // Explicit setters for compilation issues  
    public void setSender(User sender) { this.sender = sender; }
    public void setRecipient(User recipient) { this.recipient = recipient; }
    public void setSubject(String subject) { this.subject = subject; }
    public void setContent(String content) { this.content = content; }
    public void setMessageType(String messageType) { this.messageType = messageType; }
    public void setPriority(String priority) { this.priority = priority; }
    public void setStatus(String status) { this.status = status; }
    public void setIsRead(Boolean isRead) { this.isRead = isRead; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/StudentProgress.java">
package com.classroomapp.classroombackend.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Entity
@Table(name = "student_progress")
@Data
public class StudentProgress {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "student_id", nullable = false)
    private Long studentId;

    @NotNull
    @Column(name = "classroom_id", nullable = false)
    private Long classroomId;

    @Column(name = "assignment_id")
    private Long assignmentId;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "progress_type", nullable = false)
    private ProgressType progressType;

    @DecimalMin("0.00")
    @DecimalMax("100.00")
    @Column(name = "progress_percentage", precision = 5, scale = 2)
    private BigDecimal progressPercentage = BigDecimal.ZERO;

    @Column(name = "points_earned", precision = 10, scale = 2)
    private BigDecimal pointsEarned = BigDecimal.ZERO;

    @Column(name = "max_points", precision = 10, scale = 2)
    private BigDecimal maxPoints = BigDecimal.ZERO;

    @Column(name = "completion_date")
    private LocalDateTime completionDate;

    @Column(name = "last_accessed")
    private LocalDateTime lastAccessed = LocalDateTime.now();

    @Column(name = "time_spent_minutes")
    private Integer timeSpentMinutes = 0;

    @Column(columnDefinition = "TEXT")
    private String notes;

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", insertable = false, updatable = false)
    private User student;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignment_id", insertable = false, updatable = false)
    private Assignment assignment;

    public enum ProgressType {
        ASSIGNMENT, LECTURE, QUIZ, OVERALL
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/StudentQuestion.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "student_questions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentQuestion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "student_id", nullable = false)
    private User student;
    
    @ManyToOne
    @JoinColumn(name = "teacher_id", nullable = false)
    private User teacher;
    
    @Column(nullable = false, length = 255)
    private String subject;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;
    
    @Column(length = 50)
    private String priority = "MEDIUM"; // LOW, MEDIUM, HIGH, URGENT
    
    @Column(length = 50)
    private String status = "PENDING"; // PENDING, ANSWERED, CLOSED
    
    @Column(columnDefinition = "TEXT")
    private String answer;
    
    @Column
    private LocalDateTime answeredAt;
    
    @ManyToOne
    @JoinColumn(name = "answered_by")
    private User answeredBy;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    @Column
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    public void markAsAnswered(String answer, User answeredBy) {
        this.answer = answer;
        this.answeredBy = answeredBy;
        this.answeredAt = LocalDateTime.now();
        this.status = "ANSWERED";
        this.updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/StudentQuizAnswer.java">
package com.classroomapp.classroombackend.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "student_quiz_answers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StudentQuizAnswer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(name = "submission_id", nullable = false)
    private Long submissionId;    @NotNull
    @Column(name = "question_id", nullable = false)
    private Long questionId;

    @Column(name = "selected_options", columnDefinition = "NVARCHAR(MAX)")
    private String selectedOptions; // JSON array for multiple choice

    @Column(name = "text_answer", columnDefinition = "NVARCHAR(MAX)")
    private String textAnswer;

    @Column(name = "points_earned", precision = 10, scale = 2)
    private BigDecimal pointsEarned = BigDecimal.ZERO;

    @Column(name = "is_correct")
    private Boolean isCorrect;

    @Column(name = "answered_at")
    private LocalDateTime answeredAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "submission_id", insertable = false, updatable = false)
    private Submission submission;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "question_id", insertable = false, updatable = false)
    private QuizQuestion question;
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/model/TimetableEvent.java">
package com.classroomapp.classroombackend.model;

import java.time.LocalDateTime;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "timetable_events")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TimetableEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull
    @Column(name = "start_datetime", nullable = false)
    private LocalDateTime startDatetime;

    @NotNull
    @Column(name = "end_datetime", nullable = false)
    private LocalDateTime endDatetime;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "event_type", nullable = false)
    private EventType eventType;

    @Column(name = "classroom_id")
    private Long classroomId;

    @Column(name = "lecture_id")
    private Long lectureId; // Add lectureId field for attendance navigation

    @NotNull
    @Column(name = "created_by", nullable = false)
    private Long createdBy;

    private String location;

    @Column(name = "is_all_day")
    private Boolean isAllDay = false;

    @Column(name = "reminder_minutes")
    private Integer reminderMinutes = 15;

    @Column(length = 7)
    private String color = "#007bff";

    @Column(name = "recurring_rule")
    private String recurringRule;

    @Column(name = "parent_event_id")
    private Long parentEventId;

    @Column(name = "is_cancelled")
    private Boolean isCancelled = false;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt = LocalDateTime.now();

    // JPA relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id", insertable = false, updatable = false)
    private Classroom classroom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", insertable = false, updatable = false)
    private User creator;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_event_id", insertable = false, updatable = false)
    private TimetableEvent parentEvent;

    public enum EventType {
        CLASS, EXAM, MEETING, ASSIGNMENT_DUE, HOLIDAY
    }

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/assignmentmanagement/AssignmentRepository.java">
package com.classroomapp.classroombackend.repository.assignmentmanagement;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
public interface AssignmentRepository extends JpaRepository<Assignment, Long> {
    
    // Find assignments by classroom
    List<Assignment> findByClassroom(Classroom classroom);
    
    // Find assignments by classroom ordered by due date
    List<Assignment> findByClassroomOrderByDueDateAsc(Classroom classroom);
    
    // Optimized query with JOIN FETCH to avoid N+1 problem when accessing classroom data
    @Query("SELECT a FROM Assignment a JOIN FETCH a.classroom WHERE a.classroom = :classroom ORDER BY a.dueDate ASC")
    List<Assignment> findByClassroomWithClassroomOrderByDueDateAsc(@Param("classroom") Classroom classroom);
    
    // Optimized query for GetCourseDetails method
    @Query("SELECT a FROM Assignment a JOIN FETCH a.classroom WHERE a.classroom = :classroom")
    List<Assignment> findByClassroomWithClassroom(@Param("classroom") Classroom classroom);
    
    // Find upcoming assignments (due date is after now)
    List<Assignment> findByClassroomAndDueDateAfterOrderByDueDateAsc(Classroom classroom, LocalDateTime now);
    
    // Optimized upcoming assignments query with JOIN FETCH
    @Query("SELECT a FROM Assignment a JOIN FETCH a.classroom WHERE a.classroom = :classroom AND a.dueDate > :now ORDER BY a.dueDate ASC")
    List<Assignment> findByClassroomAndDueDateAfterOrderByDueDateAscWithClassroom(@Param("classroom") Classroom classroom, @Param("now") LocalDateTime now);
    
    // Find overdue assignments (due date is before now)
    List<Assignment> findByClassroomAndDueDateBeforeOrderByDueDateAsc(Classroom classroom, LocalDateTime now);
    
    // Find overdue assignments ordered by due date descending
    List<Assignment> findByClassroomAndDueDateBeforeOrderByDueDateDesc(Classroom classroom, LocalDateTime now);
    
    // Optimized past assignments query with JOIN FETCH
    @Query("SELECT a FROM Assignment a JOIN FETCH a.classroom WHERE a.classroom = :classroom AND a.dueDate < :now ORDER BY a.dueDate DESC")
    List<Assignment> findByClassroomAndDueDateBeforeOrderByDueDateDescWithClassroom(@Param("classroom") Classroom classroom, @Param("now") LocalDateTime now);
      // Find assignments by title containing (global search)
    List<Assignment> findByTitleContainingIgnoreCase(String title);
    
    // Find assignments by title containing in specific classroom
    List<Assignment> findByClassroomAndTitleContainingIgnoreCase(Classroom classroom, String title);
    
    // Bulk query to get assignments for multiple classrooms at once to avoid N+1
    @Query("SELECT a FROM Assignment a JOIN FETCH a.classroom WHERE a.classroom IN :classrooms ORDER BY a.dueDate ASC")
    List<Assignment> findByClassroomInWithClassroomOrderByDueDateAsc(@Param("classrooms") List<Classroom> classrooms);

    @Query("SELECT a FROM Assignment a WHERE a.classroom.teacher.id = :teacherId")
    List<Assignment> findByTeacherId(@Param("teacherId") Long teacherId);

    @Query("SELECT a FROM Assignment a WHERE a.classroom.teacher.username = :username")
    List<Assignment> findByTeacherUsername(@Param("username") String username);

    List<Assignment> findByClassroomId(Long classroomId);
    
    long countByClassroomIdIn(List<Long> classroomIds);

    List<Assignment> findByClassroomIdIn(List<Long> classroomIds);

    List<Assignment> findByClassroomInOrderByDueDateAsc(List<Classroom> classrooms);

    List<Assignment> findByClassroomAndDueDateAfter(Classroom classroom, LocalDateTime dateTime);
    List<Assignment> findByClassroomAndDueDateBefore(Classroom classroom, LocalDateTime dateTime);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/assignmentmanagement/SubmissionRepository.java">
package com.classroomapp.classroombackend.repository.assignmentmanagement;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface SubmissionRepository extends JpaRepository<Submission, Long> {
    
    // Find submission by assignment and student (returns first if multiple exist due to legacy data)
    @Query("SELECT s FROM Submission s WHERE s.assignment = :assignment AND s.student = :student ORDER BY s.submittedAt DESC")
    List<Submission> findByAssignmentAndStudentList(@Param("assignment") Assignment assignment, @Param("student") User student);
    
    // Find submission by assignment and student - for backward compatibility
    // If multiple submissions exist, returns the most recent one
    default Optional<Submission> findByAssignmentAndStudent(Assignment assignment, User student) {
        List<Submission> submissions = findByAssignmentAndStudentList(assignment, student);
        return submissions.isEmpty() ? Optional.empty() : Optional.of(submissions.get(0));
    }
    
    // Find all submissions for an assignment
    List<Submission> findByAssignment(Assignment assignment);
    
    // Find all submissions by student
    List<Submission> findByStudent(User student);
    
    // Find submissions by assignment ordered by submission date
    List<Submission> findByAssignmentOrderBySubmittedAtDesc(Assignment assignment);
    
    // Find graded submissions for an assignment
    List<Submission> findByAssignmentAndScoreIsNotNull(Assignment assignment);
    
    // Find ungraded submissions for an assignment
    List<Submission> findByAssignmentAndScoreIsNull(Assignment assignment);
    
    // Find late submissions (submitted after due date)
    @Query("SELECT s FROM Submission s WHERE s.assignment = :assignment AND s.submittedAt > s.assignment.dueDate")
    List<Submission> findLateSubmissionsByAssignment(@Param("assignment") Assignment assignment);
    
    // Find submissions by student with score
    List<Submission> findByStudentAndScoreIsNotNull(User student);
    
    // Find submissions by student for specific assignment
    List<Submission> findByStudentAndAssignment(User student, Assignment assignment);
    
    // Count submissions for an assignment
    long countByAssignment(Assignment assignment);
    
    // Count graded submissions for an assignment
    long countByAssignmentAndScoreIsNotNull(Assignment assignment);
    
    // Get average score for an assignment
    @Query("SELECT AVG(s.score) FROM Submission s WHERE s.assignment = :assignment AND s.score IS NOT NULL")
    Optional<Double> getAverageScoreByAssignment(@Param("assignment") Assignment assignment);

    @Query("SELECT s FROM Submission s JOIN FETCH s.assignment JOIN FETCH s.student WHERE s.student = :student ORDER BY s.submittedAt DESC")
    List<Submission> findByStudentWithDetails(@Param("student") User student);

    List<Submission> findByAssignmentId(Long assignmentId);
    
    Optional<Submission> findByAssignmentIdAndStudentId(Long assignmentId, Long studentId);
    
    List<Submission> findByStudentId(Long studentId);

    @Query("SELECT count(s) FROM Submission s WHERE s.assignment.classroom.id IN :classroomIds AND s.score IS NOT NULL")
    long countGradedSubmissionsByClassroomIds(@Param("classroomIds") List<Long> classroomIds);

    @Query("SELECT count(s) FROM Submission s WHERE s.assignment.classroom.id IN :classroomIds AND s.score IS NULL")
    long countPendingSubmissionsByClassroomIds(@Param("classroomIds") List<Long> classroomIds);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/attendancemanagement/AttendanceRepository.java">
package com.classroomapp.classroombackend.repository.attendancemanagement;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.dto.attendancemanagement.MyAttendanceHistoryDto;
import com.classroomapp.classroombackend.model.attendancemanagement.Attendance;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceSession;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface AttendanceRepository extends JpaRepository<Attendance, Long> {
    
    // Find attendance by user and session
    Optional<Attendance> findByStudentAndSession(User user, AttendanceSession session);
    
    // Find all attendance records for a specific session
    List<Attendance> findBySession(AttendanceSession session);
    
    // Find all attendance records for a specific user
    List<Attendance> findByStudent(User user);
    
    // Find attendance by user and session ID
    Optional<Attendance> findByStudentAndSessionId(User user, Long sessionId);
    
    // Find attendance records by status
    List<Attendance> findByStatus(AttendanceStatus status);    // Find attendance records for a user within a date range
    @Query("SELECT a FROM Attendance a JOIN a.session s WHERE a.student = :user AND s.sessionDate BETWEEN :startDate AND :endDate")
    List<Attendance> findByStudentAndDateRange(@Param("user") User user,
                                          @Param("startDate") LocalDate startDate,
                                          @Param("endDate") LocalDate endDate);
    
    // Get attendance summary for a session
    @Query("SELECT a.status, COUNT(a) FROM Attendance a WHERE a.session = :session GROUP BY a.status")
    List<Object[]> getAttendanceSummaryBySession(@Param("session") AttendanceSession session);      // Find attendance records for a classroom within date range
    @Query("SELECT a FROM Attendance a JOIN a.session s WHERE s.classroom.id = :classroomId AND s.sessionDate BETWEEN :startDate AND :endDate")
    List<Attendance> findByClassroomAndDateRange(@Param("classroomId") Long classroomId,
                                               @Param("startDate") LocalDate startDate,
                                               @Param("endDate") LocalDate endDate);
    
    // Get student attendance percentage for a classroom
    @Query("SELECT a.student, " +
           "CAST(SUM(CASE WHEN a.status = 'PRESENT' THEN 1 ELSE 0 END) AS double) / COUNT(a) * 100 " +
           "FROM Attendance a " +
           "JOIN a.session s " +
           "WHERE s.classroom.id = :classroomId " +
           "GROUP BY a.student")
    List<Object[]> getStudentAttendancePercentageByClassroom(@Param("classroomId") Long classroomId);
    
    // Check if student has already marked attendance for a session
    boolean existsByStudentAndSession(User student, AttendanceSession session);
    
    // Find attendance records by session and status
    List<Attendance> findBySessionAndStatus(AttendanceSession session, AttendanceStatus status);    // Find attendance records by user, classroom and date range for teacher records
    @Query("SELECT a FROM Attendance a JOIN a.session s WHERE a.student = :user AND s.classroom.id = :#{#classroom.id} " +
           "AND s.sessionDate BETWEEN :startDate AND :endDate")
    List<Attendance> findByUserAndClassroomAndSessionDateBetweenAndIsTeacherRecordTrue(
        @Param("user") User user, 
        @Param("classroom") Classroom classroom, 
        @Param("startDate") LocalDate startDate, 
        @Param("endDate") LocalDate endDate);

    Optional<Attendance> findBySession_IdAndStudent_Id(Long sessionId, Long studentId);

    // Alternative simpler query for debugging
    @Query("SELECT a FROM Attendance a " +
           "JOIN a.session s " +
           "WHERE a.student.id = :studentId AND s.classroom.id = :classroomId " +
           "ORDER BY s.sessionDate DESC")
    List<Attendance> findAttendanceRecordsForDebugging(@Param("studentId") Long studentId, @Param("classroomId") Long classroomId);

    @Query("SELECT new com.classroomapp.classroombackend.dto.attendancemanagement.MyAttendanceHistoryDto(l.id, l.title, s.sessionDate, a.status) " +
           "FROM Attendance a " +
           "JOIN a.session s " +
           "JOIN s.lecture l " +
           "WHERE a.student.id = :studentId AND s.classroom.id = :classroomId " +
           "ORDER BY s.sessionDate DESC")
    List<MyAttendanceHistoryDto> findStudentAttendanceHistoryByCourse(@Param("studentId") Long studentId, @Param("classroomId") Long classroomId);

    @Query("SELECT a FROM Attendance a JOIN a.session s WHERE s.classroom.id = :classroomId AND a.student.id = :studentId")
    List<Attendance> findByStudentIdAndSessionClassroomId(@Param("studentId") Long studentId, @Param("classroomId") Long classroomId);

    @Query("SELECT " +
            "SUM(CASE WHEN a.status IN (com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus.PRESENT, com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus.LATE) THEN 1 ELSE 0 END) * 100.0 / COUNT(a.id) " +
            "FROM Attendance a WHERE a.session.classroom.id IN :classroomIds")
    Double getAverageAttendanceByClassroomIds(@Param("classroomIds") List<Long> classroomIds);

    @Query("SELECT a FROM Attendance a JOIN a.session s WHERE s.lecture.id = :lectureId AND a.student.id = :studentId")
    Optional<Attendance> findByLectureIdAndStudentId(@Param("lectureId") Long lectureId, @Param("studentId") Long studentId);

    @Query("SELECT a FROM Attendance a " +
           "JOIN a.session s " +
           "WHERE a.student.id = :studentId AND s.classroom.id = :classroomId " +
           "ORDER BY s.sessionDate DESC")
    List<Attendance> findByStudentIdAndSession_ClassroomIdOrderBySession_SessionDateDesc(@Param("studentId") Long studentId, @Param("classroomId") Long classroomId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/attendancemanagement/AttendanceSessionRepository.java">
package com.classroomapp.classroombackend.repository.attendancemanagement;
import java.util.Optional;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceSession;

@Repository
public interface AttendanceSessionRepository extends JpaRepository<AttendanceSession, Long> {
    List<AttendanceSession> findByClassroomId(Long classroomId);
    Optional<AttendanceSession> findByLectureId(Long lectureId);
    
    boolean existsByClassroomIdAndStatus(Long classroomId, AttendanceSession.SessionStatus status);

    /**
     * Tìm các phiên điểm danh mà giáo viên đã clock-in
     * @param teacherId ID của giáo viên
     * @return Danh sách các phiên điểm danh
     */
    @Query("SELECT s FROM AttendanceSession s " +
           "JOIN s.lecture l " +
           "JOIN l.schedule sch " +
           "WHERE sch.teacher.id = :teacherId " +
           "AND s.teacherClockInTime IS NOT NULL " +
           "ORDER BY s.teacherClockInTime DESC")
    List<AttendanceSession> findTeachingHistoryByTeacherId(@Param("teacherId") Long teacherId);

    long countByClassroomIdIn(List<Long> classroomIds);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/classroommanagement/ClassroomEnrollmentRepository.java">
package com.classroomapp.classroombackend.repository.classroommanagement;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface ClassroomEnrollmentRepository extends JpaRepository<ClassroomEnrollment, ClassroomEnrollmentId> {
    
    // Find an enrollment by the combination of classroom and user objects
    Optional<ClassroomEnrollment> findByClassroomAndUser(Classroom classroom, User user);
    
    // Find all enrollments for a specific user by their ID
    List<ClassroomEnrollment> findById_UserId(Long userId);
    
    // Find all enrollments for a specific classroom by its ID
    List<ClassroomEnrollment> findById_ClassroomId(Long classroomId);
    
    List<ClassroomEnrollment> findByUser_Id(Long studentId);

    Optional<ClassroomEnrollment> findByClassroomIdAndUserId(Long classroomId, Long studentId);

    List<ClassroomEnrollment> findByClassroomId(Long classroomId);

    List<ClassroomEnrollment> findByUserId(Long studentId);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/classroommanagement/ClassroomRepository.java">
package com.classroomapp.classroombackend.repository.classroommanagement;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface ClassroomRepository extends JpaRepository<Classroom, Long> {
    List<Classroom> findByTeacher(User teacher);

    @Query("SELECT c FROM Classroom c JOIN c.enrollments e WHERE e.user = :student")
    List<Classroom> findByStudentsContaining(@Param("student") User student);
    
    // Find classrooms by subject
    List<Classroom> findBySubject(String subject);
    
    // Find classrooms by name containing search term (case-insensitive)
    List<Classroom> findByNameContainingIgnoreCase(String name);

    // Find classrooms by student ID using the enrollments relationship
    @Query("SELECT c FROM Classroom c JOIN c.enrollments e WHERE e.user.id = :studentId")
    List<Classroom> findClassroomsByStudentId(@Param("studentId") Long studentId);
    
    // Optimized query to fetch classrooms with enrollments and students in one query to avoid N+1 problem
    @Query("SELECT DISTINCT c FROM Classroom c LEFT JOIN FETCH c.enrollments e LEFT JOIN FETCH e.user WHERE c.teacher = :teacher")
    List<Classroom> findByTeacherWithStudents(@Param("teacher") User teacher);
    
    // Alternative query using teacher ID directly
    @Query("SELECT DISTINCT c FROM Classroom c LEFT JOIN FETCH c.enrollments e LEFT JOIN FETCH e.user WHERE c.teacher.id = :teacherId")
    List<Classroom> findByTeacherIdWithStudents(@Param("teacherId") Long teacherId);
    
    // Alternative query using teacher ID directly
    @Query("SELECT DISTINCT c FROM Classroom c WHERE c.teacher.id = :teacherId")
    List<Classroom> findByTeacherId(@Param("teacherId") Long teacherId);

    @Query("SELECT c FROM Classroom c LEFT JOIN FETCH c.teacher LEFT JOIN FETCH c.lectures WHERE c.id = :classroomId")
    Optional<Classroom> findDetailsById(@Param("classroomId") Long classroomId);

    // Find classroom IDs by student ID (for schedule service)
    @Query("SELECT c.id FROM Classroom c JOIN c.enrollments e WHERE e.user.id = :studentId")
    List<Long> findClassroomsIdsByStudentId(@Param("studentId") Long studentId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/classroommanagement/ClassroomScheduleRepository.java">
package com.classroomapp.classroombackend.repository.classroommanagement;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomSchedule;

@Repository
public interface ClassroomScheduleRepository extends JpaRepository<ClassroomSchedule, Long> {
    List<ClassroomSchedule> findByClassroomId(Long classroomId);
    List<ClassroomSchedule> findByClassroom(Classroom classroom);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/classroommanagement/CourseRepository.java">
package com.classroomapp.classroombackend.repository.classroommanagement;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.classroommanagement.Course;

@Repository
public interface CourseRepository extends JpaRepository<Course, Long> {
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/classroommanagement/SyllabusRepository.java">
package com.classroomapp.classroombackend.repository.classroommanagement;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.Syllabus;

@Repository
public interface SyllabusRepository extends JpaRepository<Syllabus, Long> {
    Optional<Syllabus> findByClassroomId(Long classroomId);
    Optional<Syllabus> findByClassroom(Classroom classroom);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/exammangement/ExamRepository.java">
package com.classroomapp.classroombackend.repository.exammangement;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.exammangement.Exam;

@Repository
public interface ExamRepository extends JpaRepository<Exam, Long> {

    List<Exam> findByClassroomId(Long classroomId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/exammangement/ExamSubmissionRepository.java">
package com.classroomapp.classroombackend.repository.exammangement;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.exammangement.ExamSubmission;

@Repository
public interface ExamSubmissionRepository extends JpaRepository<ExamSubmission, Long> {

    List<ExamSubmission> findByExamId(Long examId);

    Optional<ExamSubmission> findByExamIdAndStudentId(Long examId, Long studentId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/requestmanagement/RequestRepository.java">
package com.classroomapp.classroombackend.repository.requestmanagement;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Request;

@Repository
public interface RequestRepository extends JpaRepository<Request, Long> {
    List<Request> findByEmail(String email);
    List<Request> findByStatus(String status);
    List<Request> findByRequestedRole(String role);
    boolean existsByEmailAndStatusAndRequestedRole(String email, String status, String role);
    boolean existsByEmailAndStatusIn(String email, List<String> statuses);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/usermanagement/RoleRepository.java">
package com.classroomapp.classroombackend.repository.usermanagement;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.usermanagement.Role;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    Optional<Role> findByName(String name);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/usermanagement/UserRepository.java">
package com.classroomapp.classroombackend.repository.usermanagement;

import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    /**
     * Find a user by username
     * @param username the username to search for
     * @return Optional containing user if found
     */
    Optional<User> findByUsername(String username);
    
    /**
     * Find a user by email
     * @param email the email to search for
     * @return Optional containing user if found
     */
    Optional<User> findByEmail(String email);
    
    /**
     * Check if username exists
     * @param username the username to check
     * @return true if username exists, false otherwise
     */
    boolean existsByUsername(String username);
    
    /**
     * Check if email exists
     * @param email the email to check
     * @return true if email exists, false otherwise
     */
    boolean existsByEmail(String email);
    
    /**
     * Find users by role ID
     * @param roleId the role ID to search for
     * @return List of users with the specified role
     */
    List<User> findByRoleId(Integer roleId);
    
    /**
     * Find users by status
     * @param status the status to search for
     * @return List of users with the specified status
     */
    List<User> findByStatus(String status);
    
    /**
     * Find users by department
     * @param department the department to search for
     * @return List of users in the specified department
     */
    List<User> findByDepartment(String department);
    
    /**
     * Find users by role and status
     * @param roleId the role ID
     * @param status the status
     * @return List of users matching both role and status
     */
    List<User> findByRoleIdAndStatus(Integer roleId, String status);
    
    /**
     * Find active teachers
     * @return List of active teachers
     */
    @Query("SELECT u FROM User u WHERE u.roleId = 2 AND u.status = 'active'")
    List<User> findActiveTeachers();
    
    /**
     * Find active students
     * @return List of active students
     */
    @Query("SELECT u FROM User u WHERE u.roleId = 1 AND u.status = 'active'")
    List<User> findActiveStudents();
    
    /**
     * Search users by name containing keyword
     * @param keyword the search keyword
     * @return List of users whose full name contains the keyword
     */
    @Query("SELECT u FROM User u WHERE u.fullName LIKE %:keyword% OR u.username LIKE %:keyword%")
    List<User> searchUsersByName(@Param("keyword") String keyword);

    Page<User> findByFullNameContainingIgnoreCaseOrEmailContainingIgnoreCase(String fullName, String email, Pageable pageable);

    List<User> findAllByRoleId(Long roleId);

    @Query("SELECT COUNT(DISTINCT e.user.id) FROM ClassroomEnrollment e WHERE e.classroom.id IN :classroomIds")
    long countStudentsByClassroomIds(@Param("classroomIds") List<Long> classroomIds);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AccomplishmentRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Accomplishment;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface AccomplishmentRepository extends JpaRepository<Accomplishment, Long> {

    List<Accomplishment> findByStudentOrderByCompletionDateDesc(User student);

}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AllowedIpRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.AllowedIp;

@Repository
public interface AllowedIpRepository extends JpaRepository<AllowedIp, Long> {

    /**
     * Tìm IP address cụ thể
     */
    Optional<AllowedIp> findByIpAddress(String ipAddress);

    /**
     * Kiểm tra IP có được phép không
     */
    @Query("SELECT COUNT(a) > 0 FROM AllowedIp a WHERE a.ipAddress = :ipAddress AND a.isActive = true")
    boolean isIpAllowed(@Param("ipAddress") String ipAddress);

    /**
     * Lấy danh sách IP đang active
     */
    List<AllowedIp> findByIsActiveTrue();

    /**
     * Tìm theo description
     */
    List<AllowedIp> findByDescriptionContainingIgnoreCase(String description);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AnnouncementAttachmentRepository.java">
package com.classroomapp.classroombackend.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.AnnouncementAttachment;

@Repository
public interface AnnouncementAttachmentRepository extends JpaRepository<AnnouncementAttachment, Long> {
    // Add custom query methods here if needed
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AnnouncementReadRepository.java">
package com.classroomapp.classroombackend.repository;

import com.classroomapp.classroombackend.model.AnnouncementRead;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface AnnouncementReadRepository extends JpaRepository<AnnouncementRead, Long> {
    
    /**
     * Check if a user has read an announcement
     */
    boolean existsByAnnouncementIdAndUserId(Long announcementId, Long userId);
    
    /**
     * Find read record for user and announcement
     */
    Optional<AnnouncementRead> findByAnnouncementIdAndUserId(Long announcementId, Long userId);
    
    /**
     * Find all read announcements for a user
     */
    List<AnnouncementRead> findByUserIdOrderByReadAtDesc(Long userId);
    
    /**
     * Find who read a specific announcement
     */
    List<AnnouncementRead> findByAnnouncementIdOrderByReadAtDesc(Long announcementId);
    
    /**
     * Count how many users read an announcement
     */
    long countByAnnouncementId(Long announcementId);
    
    /**
     * Get unread announcements for a user in a classroom
     */
    @Query("SELECT a.id FROM Announcement a " +
           "WHERE a.classroomId = :classroomId " +
           "AND a.status = 'ACTIVE' " +
           "AND a.id NOT IN (SELECT ar.announcementId FROM AnnouncementRead ar WHERE ar.userId = :userId)")
    List<Long> findUnreadAnnouncementIds(@Param("classroomId") Long classroomId,
                                       @Param("userId") Long userId);
    
    /**
     * Count unread announcements for a user in a classroom
     */
    @Query("SELECT COUNT(a) FROM Announcement a " +
           "WHERE a.classroomId = :classroomId " +
           "AND a.status = 'ACTIVE' " +
           "AND a.id NOT IN (SELECT ar.announcementId FROM AnnouncementRead ar WHERE ar.userId = :userId)")
    long countUnreadAnnouncements(@Param("classroomId") Long classroomId,
                                 @Param("userId") Long userId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AnnouncementRepository.java">
package com.classroomapp.classroombackend.repository;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Announcement;

@Repository
public interface AnnouncementRepository extends JpaRepository<Announcement, Long> {
    
    /**
     * Find active announcements for a classroom
     */
    @Query("SELECT a FROM Announcement a WHERE a.classroomId = :classroomId " +
           "AND a.status = 'ACTIVE' " +
           "AND (a.scheduledDate IS NULL OR a.scheduledDate <= :now) " +
           "AND (a.expiryDate IS NULL OR a.expiryDate > :now) " +
           "ORDER BY a.isPinned DESC, a.createdAt DESC")
    List<Announcement> findActiveByClassroom(@Param("classroomId") Long classroomId,
                                           @Param("now") LocalDateTime now);
    
    /**
     * Find global announcements (not classroom-specific)
     */
    @Query("SELECT a FROM Announcement a WHERE a.classroomId IS NULL " +
           "AND a.status = 'ACTIVE' " +
           "AND (a.scheduledDate IS NULL OR a.scheduledDate <= :now) " +
           "AND (a.expiryDate IS NULL OR a.expiryDate > :now) " +
           "ORDER BY a.isPinned DESC, a.createdAt DESC")
    List<Announcement> findGlobalAnnouncements(@Param("now") LocalDateTime now);
    
    /**
     * Find pinned announcements
     */
    List<Announcement> findByClassroomIdAndIsPinnedTrueAndStatusOrderByCreatedAtDesc(
            Long classroomId, Announcement.AnnouncementStatus status);
    
    /**
     * Find announcements by priority
     */
    List<Announcement> findByClassroomIdAndPriorityAndStatusOrderByCreatedAtDesc(
            Long classroomId, Announcement.Priority priority, Announcement.AnnouncementStatus status);
    
    /**
     * Find announcements by target audience
     */
    List<Announcement> findByClassroomIdAndTargetAudienceAndStatusOrderByCreatedAtDesc(
            Long classroomId, Announcement.TargetAudience targetAudience, 
            Announcement.AnnouncementStatus status);
    
    /**
     * Find announcements created by a user
     */
    List<Announcement> findByCreatedByOrderByCreatedAtDesc(Long createdBy);
    
    /**
     * Find scheduled announcements
     */
    @Query("SELECT a FROM Announcement a WHERE a.scheduledDate > :now " +
           "AND a.status = 'ACTIVE' ORDER BY a.scheduledDate ASC")
    List<Announcement> findScheduledAnnouncements(@Param("now") LocalDateTime now);
    
    /**
     * Find expired announcements
     */
    @Query("SELECT a FROM Announcement a WHERE a.expiryDate < :now " +
           "AND a.status = 'ACTIVE'")
    List<Announcement> findExpiredAnnouncements(@Param("now") LocalDateTime now);
    
    /**
     * Search announcements by title or content
     */
    @Query("SELECT a FROM Announcement a WHERE a.classroomId = :classroomId " +
           "AND a.status = 'ACTIVE' " +
           "AND (LOWER(a.title) LIKE LOWER(CONCAT('%', :searchTerm, '%')) " +
           "OR LOWER(a.content) LIKE LOWER(CONCAT('%', :searchTerm, '%'))) " +
           "ORDER BY a.isPinned DESC, a.createdAt DESC")
    List<Announcement> searchAnnouncements(@Param("classroomId") Long classroomId,
                                         @Param("searchTerm") String searchTerm);

    /**
     * Find all announcements ordered by creation date
     */
    List<Announcement> findAllByOrderByCreatedAtDesc();

    /**
     * Find announcements by target audience list and status
     */
    List<Announcement> findByTargetAudienceInAndStatusOrderByCreatedAtDesc(
            List<Announcement.TargetAudience> targetAudiences, 
            Announcement.AnnouncementStatus status);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/AssessmentRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Assessment;

@Repository
public interface AssessmentRepository extends JpaRepository<Assessment, Long> {
    List<Assessment> findByLectureId(Long lectureId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/BlogRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Blog;

@Repository
public interface BlogRepository extends JpaRepository<Blog, Long> {
    
    Optional<Blog> findBySlug(String slug);

    List<Blog> findByAuthorId(Long authorId);
    
    List<Blog> findByIsPublishedTrue();
    
    @Query("SELECT b FROM Blog b WHERE b.isPublished = true ORDER BY b.publishedDate DESC")
    List<Blog> findRecentPublishedBlogs();
    
    @Query(value = "SELECT * FROM blogs b WHERE " +
           "LOWER(CAST(b.title AS nvarchar(max))) LIKE LOWER(N'%' + :keyword + '%') OR " + 
           "LOWER(CAST(b.description AS nvarchar(max))) LIKE LOWER(N'%' + :keyword + '%')", 
           nativeQuery = true)
    List<Blog> searchBlogs(@Param("keyword") String keyword);
    
    @Query("SELECT b FROM Blog b WHERE b.tags LIKE CONCAT('%', :tag, '%')")
    List<Blog> findByTag(String tag);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/CourseFeedbackRepository.java">
package com.classroomapp.classroombackend.repository;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.CourseFeedback;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface CourseFeedbackRepository extends JpaRepository<CourseFeedback, Long> {
    
    boolean existsByStudentAndClassroom(User student, Classroom classroom);
    
    List<CourseFeedback> findByStudentOrderByCreatedAtDesc(User student);
    
    List<CourseFeedback> findByClassroomOrderByCreatedAtDesc(Classroom classroom);
    
    List<CourseFeedback> findByTeacherOrderByCreatedAtDesc(User teacher);
    
    List<CourseFeedback> findByStatusOrderByCreatedAtDesc(String status);
    
    List<CourseFeedback> findByCategoryOrderByCreatedAtDesc(String category);
    
    List<CourseFeedback> findByOverallRatingBetweenOrderByCreatedAtDesc(Integer minRating, Integer maxRating);
    
    List<CourseFeedback> findByIsAnonymousTrueOrderByCreatedAtDesc();
    
    @Query("SELECT cf FROM CourseFeedback cf WHERE cf.title LIKE %:keyword% OR cf.content LIKE %:keyword% ORDER BY cf.createdAt DESC")
    List<CourseFeedback> searchFeedback(@Param("keyword") String keyword);
    
    @Query("SELECT cf FROM CourseFeedback cf WHERE cf.createdAt >= :fromDate ORDER BY cf.createdAt DESC")
    List<CourseFeedback> findRecentFeedback(@Param("fromDate") LocalDateTime fromDate);
    
    @Query("SELECT AVG(cf.overallRating) FROM CourseFeedback cf WHERE cf.classroom = :classroom")
    Double getAverageRatingByClassroom(@Param("classroom") Classroom classroom);
    
    @Query("SELECT AVG(cf.teachingQualityRating) FROM CourseFeedback cf WHERE cf.teacher = :teacher")
    Double getAverageTeachingQualityByTeacher(@Param("teacher") User teacher);
    
    @Query("SELECT COUNT(cf) FROM CourseFeedback cf WHERE cf.teacher = :teacher AND cf.status = :status")
    Long countFeedbackByTeacherAndStatus(@Param("teacher") User teacher, @Param("status") String status);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/CourseMaterialRepository.java">
package com.classroomapp.classroombackend.repository;

import com.classroomapp.classroombackend.model.CourseMaterial;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CourseMaterialRepository extends JpaRepository<CourseMaterial, Long> {
    
    /**
     * Find all materials for a specific classroom
     */
    List<CourseMaterial> findByClassroomIdOrderByUploadDateDesc(Long classroomId);
    
    /**
     * Find public materials for a classroom
     */
    List<CourseMaterial> findByClassroomIdAndIsPublicTrueOrderByUploadDateDesc(Long classroomId);
    
    /**
     * Find materials uploaded by a specific user
     */
    List<CourseMaterial> findByUploadedByOrderByUploadDateDesc(Long uploadedBy);
    
    /**
     * Find materials by file type
     */
    List<CourseMaterial> findByClassroomIdAndFileTypeContainingIgnoreCaseOrderByUploadDateDesc(
            Long classroomId, String fileType);
    
    /**
     * Search materials by title or description
     */
    @Query("SELECT cm FROM CourseMaterial cm WHERE cm.classroomId = :classroomId " +
           "AND (LOWER(cm.title) LIKE LOWER(CONCAT('%', :searchTerm, '%')) " +
           "OR LOWER(cm.description) LIKE LOWER(CONCAT('%', :searchTerm, '%'))) " +
           "ORDER BY cm.uploadDate DESC")
    List<CourseMaterial> searchMaterials(@Param("classroomId") Long classroomId, 
                                       @Param("searchTerm") String searchTerm);
    
    /**
     * Get total download count for a classroom
     */
    @Query("SELECT SUM(cm.downloadCount) FROM CourseMaterial cm WHERE cm.classroomId = :classroomId")
    Long getTotalDownloadsByClassroom(@Param("classroomId") Long classroomId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/CourseScheduleRepository.java">
package com.classroomapp.classroombackend.repository;

import com.classroomapp.classroombackend.model.CourseSchedule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface CourseScheduleRepository extends JpaRepository<CourseSchedule, Long> {
    
    /**
     * Find all schedule entries for a classroom
     */
    List<CourseSchedule> findByClassroomIdOrderByStartTime(Long classroomId);
    
    /**
     * Find schedule entries between dates
     */
    @Query("SELECT cs FROM CourseSchedule cs WHERE cs.classroomId = :classroomId " +
           "AND cs.startTime >= :startDate AND cs.endTime <= :endDate " +
           "ORDER BY cs.startTime")
    List<CourseSchedule> findByClassroomIdAndDateRange(@Param("classroomId") Long classroomId,
                                                      @Param("startDate") LocalDateTime startDate,
                                                      @Param("endDate") LocalDateTime endDate);
    
    /**
     * Find upcoming schedule entries
     */
    @Query("SELECT cs FROM CourseSchedule cs WHERE cs.classroomId = :classroomId " +
           "AND cs.startTime > :currentTime ORDER BY cs.startTime")
    List<CourseSchedule> findUpcomingByClassroom(@Param("classroomId") Long classroomId,
                                               @Param("currentTime") LocalDateTime currentTime);
    
    /**
     * Find schedule by type
     */
    List<CourseSchedule> findByClassroomIdAndScheduleTypeOrderByStartTime(
            Long classroomId, CourseSchedule.ScheduleType scheduleType);
    
    /**
     * Find recurring schedules
     */
    List<CourseSchedule> findByClassroomIdAndRecurringTypeIsNotNullOrderByStartTime(Long classroomId);
    
    /**
     * Find online classes
     */
    List<CourseSchedule> findByClassroomIdAndIsOnlineTrueOrderByStartTime(Long classroomId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/GradingDetailRepository.java">
package com.classroomapp.classroombackend.repository;

import com.classroomapp.classroombackend.model.GradingDetail;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;

@Repository
public interface GradingDetailRepository extends JpaRepository<GradingDetail, Long> {
    
    /**
     * Find all grading details for a submission
     */
    List<GradingDetail> findBySubmissionIdOrderByRubricId(Long submissionId);
    
    /**
     * Find grading details by grader
     */
    List<GradingDetail> findByGradedByOrderByGradedAtDesc(Long gradedBy);
    
    /**
     * Find grading details for a specific rubric
     */
    List<GradingDetail> findByRubricIdOrderByGradedAtDesc(Long rubricId);
    
    /**
     * Get total points for a submission
     */
    @Query("SELECT SUM(gd.pointsAwarded) FROM GradingDetail gd WHERE gd.submissionId = :submissionId")
    BigDecimal getTotalPointsBySubmission(@Param("submissionId") Long submissionId);
    
    /**
     * Check if submission is fully graded
     */
    @Query("SELECT COUNT(gd) = (SELECT COUNT(gr) FROM GradingRubric gr WHERE gr.assignmentId = " +
           "(SELECT s.assignment.id FROM Submission s WHERE s.id = :submissionId)) " +
           "FROM GradingDetail gd WHERE gd.submissionId = :submissionId")
    boolean isSubmissionFullyGraded(@Param("submissionId") Long submissionId);
    
    /**
     * Get average points for a rubric across all submissions
     */
    @Query("SELECT AVG(gd.pointsAwarded) FROM GradingDetail gd WHERE gd.rubricId = :rubricId")
    BigDecimal getAveragePointsByRubric(@Param("rubricId") Long rubricId);
    
    /**
     * Find submissions graded by a teacher for a specific assignment
     */
    @Query("SELECT gd FROM GradingDetail gd " +
           "JOIN Submission s ON gd.submissionId = s.id " +
           "WHERE s.assignment.id = :assignmentId AND gd.gradedBy = :gradedBy")
    List<GradingDetail> findByAssignmentAndGrader(@Param("assignmentId") Long assignmentId,
                                                 @Param("gradedBy") Long gradedBy);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/GradingRubricRepository.java">
package com.classroomapp.classroombackend.repository;

import com.classroomapp.classroombackend.model.GradingRubric;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;

@Repository
public interface GradingRubricRepository extends JpaRepository<GradingRubric, Long> {
    
    /**
     * Find all rubrics for an assignment
     */
    List<GradingRubric> findByAssignmentIdOrderByDisplayOrder(Long assignmentId);
    
    /**
     * Find rubrics created by a specific user
     */
    List<GradingRubric> findByCreatedByOrderByCreatedAtDesc(Long createdBy);
    
    /**
     * Get total maximum points for an assignment
     */
    @Query("SELECT SUM(gr.maxPoints) FROM GradingRubric gr WHERE gr.assignmentId = :assignmentId")
    BigDecimal getTotalMaxPointsByAssignment(@Param("assignmentId") Long assignmentId);
    
    /**
     * Find rubrics with highest weights
     */
    @Query("SELECT gr FROM GradingRubric gr WHERE gr.assignmentId = :assignmentId " +
           "ORDER BY gr.weightPercentage DESC")
    List<GradingRubric> findByAssignmentIdOrderByWeightDesc(@Param("assignmentId") Long assignmentId);
    
    /**
     * Check if assignment has rubrics
     */
    boolean existsByAssignmentId(Long assignmentId);
    
    /**
     * Count rubrics for assignment
     */
    long countByAssignmentId(Long assignmentId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/LectureMaterialRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.LectureMaterial;

@Repository
public interface LectureMaterialRepository extends JpaRepository<LectureMaterial, Long> {
    
    List<LectureMaterial> findByLecture(Lecture lecture);
    
    List<LectureMaterial> findByLectureIdOrderByCreatedAtDesc(Long lectureId);
    
    List<LectureMaterial> findByFileNameContainingIgnoreCase(String fileName);

    List<LectureMaterial> findByLectureId(Long lectureId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/LectureRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

@Repository
public interface LectureRepository extends JpaRepository<Lecture, Long> {
    
    List<Lecture> findByClassroomOrderByCreatedAtDesc(Classroom classroom);
    
    List<Lecture> findByClassroomIdOrderByCreatedAtDesc(Long classroomId);
    
    List<Lecture> findByTitleContainingIgnoreCase(String title);

    List<Lecture> findByClassroomId(Long classroomId);
    boolean existsByClassroomId(Long classroomId);
    Optional<Lecture> findById(Long id);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/NotificationRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Notification;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    
    List<Notification> findByRecipientIdOrderByCreatedAtDesc(Long recipientId);
    
    List<Notification> findByRecipientIdAndIsReadFalseOrderByCreatedAtDesc(Long recipientId);
    
    List<Notification> findByTypeOrderByCreatedAtDesc(String type);
    
    List<Notification> findAllByOrderByCreatedAtDesc();
    
    // Fallback methods for simpler queries
    List<Notification> findByRecipientId(Long recipientId);
    List<Notification> findByTypeAndRecipientId(String type, Long recipientId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/ScheduleRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.Schedule;

@Repository
public interface ScheduleRepository extends JpaRepository<Schedule, Long> {
    
    // Find schedules by teacher ID
    List<Schedule> findByTeacherId(Long teacherId);
    
    // Find schedules by classroom ID
    List<Schedule> findByClassroomId(Long classroomId);
    
    // Find schedules by day of week
    List<Schedule> findByDayOfWeek(Integer dayOfWeek);
    
    // Find schedules by teacher ID and day of week
    List<Schedule> findByTeacherIdAndDayOfWeek(Long teacherId, Integer dayOfWeek);
    
    // Find schedules by teacher ID with sorted days and times
    @Query("SELECT s FROM Schedule s WHERE s.teacher.id = :teacherId ORDER BY s.dayOfWeek, s.startTime")
    List<Schedule> findByTeacherIdOrderByDayAndTime(@Param("teacherId") Long teacherId);

    List<Schedule> findByClassroomIdIn(List<Long> classroomIds);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/StudentMessageRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.StudentMessage;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface StudentMessageRepository extends JpaRepository<StudentMessage, Long> {
    
    List<StudentMessage> findBySenderOrderByCreatedAtDesc(User sender);
    
    List<StudentMessage> findByRecipientOrderByCreatedAtDesc(User recipient);
    
    List<StudentMessage> findBySenderAndRecipientOrderByCreatedAtDesc(User sender, User recipient);
    
    @Query("SELECT sm FROM StudentMessage sm WHERE (sm.sender = :user1 AND sm.recipient = :user2) OR (sm.sender = :user2 AND sm.recipient = :user1) ORDER BY sm.createdAt ASC")
    List<StudentMessage> findConversation(@Param("user1") User user1, @Param("user2") User user2);
    
    List<StudentMessage> findByRecipientAndIsReadFalseOrderByCreatedAtDesc(User recipient);
    
    List<StudentMessage> findByStatusOrderByCreatedAtDesc(String status);
    
    List<StudentMessage> findByMessageTypeOrderByCreatedAtDesc(String messageType);
    
    List<StudentMessage> findByPriorityOrderByCreatedAtDesc(String priority);
    
    List<StudentMessage> findByRecipientAndPriorityOrderByCreatedAtDesc(User recipient, String priority);
    
    @Query("SELECT sm FROM StudentMessage sm WHERE sm.subject LIKE %:keyword% OR sm.content LIKE %:keyword% ORDER BY sm.createdAt DESC")
    List<StudentMessage> findByKeyword(@Param("keyword") String keyword);
    
    @Query("SELECT sm FROM StudentMessage sm WHERE sm.subject LIKE %:keyword% OR sm.content LIKE %:keyword% ORDER BY sm.createdAt DESC")
    List<StudentMessage> searchMessages(@Param("keyword") String keyword);
    
    @Query("SELECT sm FROM StudentMessage sm ORDER BY sm.createdAt DESC")
    List<StudentMessage> findRecentMessages();
    
    List<StudentMessage> findByRecipientAndStatusOrderByCreatedAtDesc(User recipient, String status);
    
    @Query("SELECT sm FROM StudentMessage sm WHERE sm.recipient = :recipient AND sm.priority = 'URGENT' ORDER BY sm.createdAt DESC")
    List<StudentMessage> findUrgentMessages(@Param("recipient") User recipient);
    
    @Query("SELECT sm FROM StudentMessage sm WHERE sm.recipient = :recipient AND sm.status = 'SENT' ORDER BY sm.createdAt DESC")
    List<StudentMessage> findPendingReplies(@Param("recipient") User recipient);
    
    @Query("SELECT COUNT(sm) FROM StudentMessage sm WHERE sm.recipient = :recipient AND sm.isRead = false")
    Long countUnreadMessagesByRecipient(@Param("recipient") User recipient);

    Long countByIsReadFalse();
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/StudentProgressRepository.java">
package com.classroomapp.classroombackend.repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.StudentProgress;

@Repository
public interface StudentProgressRepository extends JpaRepository<StudentProgress, Long> {
    
    /**
     * Find progress for a specific student in a classroom
     */
    List<StudentProgress> findByStudentIdAndClassroomIdOrderByLastAccessedDesc(
            Long studentId, Long classroomId);
    
    /**
     * Find progress for a specific assignment
     */
    Optional<StudentProgress> findByStudentIdAndAssignmentId(Long studentId, Long assignmentId);
    
    /**
     * Find all students' progress for a classroom
     */
    List<StudentProgress> findByClassroomIdOrderByStudentIdAscLastAccessedDesc(Long classroomId);
    
    /**
     * Find progress by type
     */
    List<StudentProgress> findByStudentIdAndClassroomIdAndProgressType(
            Long studentId, Long classroomId, StudentProgress.ProgressType progressType);
    
    /**
     * Get overall progress for a student in a classroom
     */
    @Query("SELECT sp FROM StudentProgress sp WHERE sp.studentId = :studentId " +
           "AND sp.classroomId = :classroomId AND sp.progressType = 'OVERALL'")
    Optional<StudentProgress> findOverallProgress(@Param("studentId") Long studentId,
                                                @Param("classroomId") Long classroomId);
    
    /**
     * Calculate average progress for a classroom
     */
    @Query("SELECT AVG(sp.progressPercentage) FROM StudentProgress sp " +
           "WHERE sp.classroomId = :classroomId AND sp.progressType = 'OVERALL'")
    BigDecimal getAverageProgressByClassroom(@Param("classroomId") Long classroomId);
    
    /**
     * Find students with low progress (below threshold)
     */
    @Query("SELECT sp FROM StudentProgress sp WHERE sp.classroomId = :classroomId " +
           "AND sp.progressType = 'OVERALL' AND sp.progressPercentage < :threshold " +
           "ORDER BY sp.progressPercentage ASC")
    List<StudentProgress> findStudentsWithLowProgress(@Param("classroomId") Long classroomId,
                                                    @Param("threshold") BigDecimal threshold);
    
    /**
     * Get total time spent by student in classroom
     */
    @Query("SELECT SUM(sp.timeSpentMinutes) FROM StudentProgress sp " +
           "WHERE sp.studentId = :studentId AND sp.classroomId = :classroomId")
    Integer getTotalTimeSpent(@Param("studentId") Long studentId, 
                            @Param("classroomId") Long classroomId);
    
    /**
     * Find all progress for a specific student across all classrooms
     */
    List<StudentProgress> findByStudentIdOrderByLastAccessedDesc(Long studentId);
    
    /**
     * Find overall progress for all classrooms of a student
     */
    @Query("SELECT sp FROM StudentProgress sp WHERE sp.studentId = :studentId " +
           "AND sp.progressType = 'OVERALL' ORDER BY sp.lastAccessed DESC")
    List<StudentProgress> findOverallProgressByStudent(@Param("studentId") Long studentId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/StudentQuestionRepository.java">
package com.classroomapp.classroombackend.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.StudentQuestion;
import com.classroomapp.classroombackend.model.usermanagement.User;

@Repository
public interface StudentQuestionRepository extends JpaRepository<StudentQuestion, Long> {
    
    List<StudentQuestion> findByStudentOrderByCreatedAtDesc(User student);
    
    List<StudentQuestion> findByTeacherOrderByCreatedAtDesc(User teacher);
    
    List<StudentQuestion> findByStatusOrderByCreatedAtDesc(String status);
    
    List<StudentQuestion> findByPriorityOrderByCreatedAtDesc(String priority);
    
    List<StudentQuestion> findByStudentAndStatusOrderByCreatedAtDesc(User student, String status);
    
    List<StudentQuestion> findByTeacherAndStatusOrderByCreatedAtDesc(User teacher, String status);
    
    @Query("SELECT sq FROM StudentQuestion sq WHERE sq.subject LIKE %:keyword% OR sq.content LIKE %:keyword% ORDER BY sq.createdAt DESC")
    List<StudentQuestion> findByKeyword(@Param("keyword") String keyword);
    
    @Query("SELECT sq FROM StudentQuestion sq WHERE sq.subject LIKE %:keyword% OR sq.content LIKE %:keyword% ORDER BY sq.createdAt DESC")
    List<StudentQuestion> searchQuestions(@Param("keyword") String keyword);
    
    @Query("SELECT sq FROM StudentQuestion sq ORDER BY sq.createdAt DESC")
    List<StudentQuestion> findRecentQuestions();
    
    List<StudentQuestion> findByStudentAndPriorityOrderByCreatedAtDesc(User student, String priority);
    
    List<StudentQuestion> findByStudentAndTeacherOrderByCreatedAtDesc(User student, User teacher);
    
    @Query("SELECT COUNT(sq) FROM StudentQuestion sq WHERE sq.teacher = :teacher AND sq.status = 'PENDING'")
    Long countPendingQuestionsByTeacher(@Param("teacher") User teacher);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/repository/TimetableEventRepository.java">
package com.classroomapp.classroombackend.repository;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.classroomapp.classroombackend.model.TimetableEvent;

@Repository
public interface TimetableEventRepository extends JpaRepository<TimetableEvent, Long> {
    
    /**
     * Find events for a classroom within a date range
     */
    @Query("SELECT te FROM TimetableEvent te WHERE te.classroomId = :classroomId " +
           "AND te.startDatetime >= :startDate AND te.endDatetime <= :endDate " +
           "AND te.isCancelled = false ORDER BY te.startDatetime")
    List<TimetableEvent> findByClassroomAndDateRange(@Param("classroomId") Long classroomId,
                                                    @Param("startDate") LocalDateTime startDate,
                                                    @Param("endDate") LocalDateTime endDate);
    
    /**
     * Find upcoming events for a classroom
     */
    @Query("SELECT te FROM TimetableEvent te WHERE te.classroomId = :classroomId " +
           "AND te.startDatetime > :currentTime AND te.isCancelled = false " +
           "ORDER BY te.startDatetime")
    List<TimetableEvent> findUpcomingByClassroom(@Param("classroomId") Long classroomId,
                                               @Param("currentTime") LocalDateTime currentTime);
    
    /**
     * Find events by type
     */
    List<TimetableEvent> findByClassroomIdAndEventTypeAndIsCancelledFalseOrderByStartDatetime(
            Long classroomId, TimetableEvent.EventType eventType);
    
    /**
     * Find all-day events
     */
    List<TimetableEvent> findByClassroomIdAndIsAllDayTrueAndIsCancelledFalseOrderByStartDatetime(
            Long classroomId);
    
    /**
     * Find recurring events
     */
    List<TimetableEvent> findByClassroomIdAndRecurringRuleIsNotNullAndIsCancelledFalseOrderByStartDatetime(
            Long classroomId);
    
    /**
     * Find events created by a user
     */
    List<TimetableEvent> findByCreatedByOrderByStartDatetimeDesc(Long createdBy);
    
    /**
     * Find conflicting events (overlapping times)
     */
    @Query("SELECT te FROM TimetableEvent te WHERE te.classroomId = :classroomId " +
           "AND te.isCancelled = false " +
           "AND ((te.startDatetime <= :endTime AND te.endDatetime >= :startTime)) " +
           "AND (:eventId IS NULL OR te.id != :eventId)")
    List<TimetableEvent> findConflictingEvents(@Param("classroomId") Long classroomId,
                                             @Param("startTime") LocalDateTime startTime,
                                             @Param("endTime") LocalDateTime endTime,
                                             @Param("eventId") Long eventId);
    
    /**
     * Find events for multiple classrooms (for teachers with multiple classes)
     */
    @Query("SELECT te FROM TimetableEvent te WHERE te.classroomId IN :classroomIds " +
           "AND te.startDatetime >= :startDate AND te.endDatetime <= :endDate " +
           "AND te.isCancelled = false ORDER BY te.startDatetime")
    List<TimetableEvent> findByClassroomsAndDateRange(@Param("classroomIds") List<Long> classroomIds,
                                                     @Param("startDate") LocalDateTime startDate,
                                                     @Param("endDate") LocalDateTime endDate);

    // Find events within a date range
    @Query("SELECT e FROM TimetableEvent e WHERE " +
           "(e.startDatetime BETWEEN :startDate AND :endDate) OR " +
           "(e.endDatetime BETWEEN :startDate AND :endDate) OR " +
           "(e.startDatetime <= :startDate AND e.endDatetime >= :endDate)")
    List<TimetableEvent> findEventsByDateRange(
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);
    
    // Find events for a specific classroom within a date range
    @Query("SELECT e FROM TimetableEvent e WHERE e.classroomId = :classroomId AND " +
           "((e.startDatetime BETWEEN :startDate AND :endDate) OR " +
           "(e.endDatetime BETWEEN :startDate AND :endDate) OR " +
           "(e.startDatetime <= :startDate AND e.endDatetime >= :endDate))")
    List<TimetableEvent> findEventsByClassroomAndDateRange(
            @Param("classroomId") Long classroomId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);
    
    // Find upcoming events (events starting from now)
    @Query("SELECT e FROM TimetableEvent e WHERE e.startDatetime >= :now " +
           "ORDER BY e.startDatetime ASC")
    List<TimetableEvent> findUpcomingEvents(@Param("now") LocalDateTime now);
    
    // Find events created by a specific user
    List<TimetableEvent> findByCreatedBy(Long createdBy);
    
    // Find events by event type
    List<TimetableEvent> findByEventType(TimetableEvent.EventType eventType);
    
    // Find all-day events within a date range
    @Query("SELECT e FROM TimetableEvent e WHERE e.isAllDay = true AND " +
           "((e.startDatetime BETWEEN :startDate AND :endDate) OR " +
           "(e.endDatetime BETWEEN :startDate AND :endDate))")
    List<TimetableEvent> findAllDayEventsByDateRange(
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/jwt/JwtAuthTokenFilter.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/jwt/JwtUtils.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/BlogPermissionEvaluator.java">
package com.classroomapp.classroombackend.security;

import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.model.Blog;
import com.classroomapp.classroombackend.repository.BlogRepository;

@Component
public class BlogPermissionEvaluator {

    private final BlogRepository blogRepository;

    public BlogPermissionEvaluator(BlogRepository blogRepository) {
        this.blogRepository = blogRepository;
    }

    public boolean isAuthor(Authentication authentication, Long blogId) {
        String userEmail = authentication.getName();
        Blog blog = blogRepository.findById(blogId).orElse(null);
        return blog != null && blog.getAuthor().getEmail().equals(userEmail);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/CustomUserDetails.java">
package com.classroomapp.classroombackend.security;

import java.util.Collection;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.classroomapp.classroombackend.model.usermanagement.User;

public class CustomUserDetails implements UserDetails {

    private final User user;
    private final Collection<? extends GrantedAuthority> authorities;

    public CustomUserDetails(User user, Collection<? extends GrantedAuthority> authorities) {
        this.user = user;
        this.authorities = authorities;
    }

    public User getUser() {
        return user;
    }
    
    public Long getId() {
        return user.getId();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        // Return email as the unique identifier for Spring Security context
        return user.getEmail();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return !"locked".equalsIgnoreCase(user.getStatus());
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return "active".equalsIgnoreCase(user.getStatus());
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/CustomUserDetailsService.java">
package com.classroomapp.classroombackend.security;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;

import lombok.extern.slf4j.Slf4j;

/**
 * UserDetailsService implementation for Spring Security
 */
@Service
@Slf4j
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;
    private final JwtUtil jwtUtil;

    @Autowired
    public CustomUserDetailsService(UserRepository userRepository, JwtUtil jwtUtil) {
        this.userRepository = userRepository;
        this.jwtUtil = jwtUtil;
    }

    @Override
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        log.info("CustomUserDetailsService - Attempting to load user by: {}", usernameOrEmail);

        // Regex to check if the input is an email address
        final Pattern emailPattern = Pattern.compile("^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,6}$", Pattern.CASE_INSENSITIVE);

        Optional<User> userOptional;

        if (emailPattern.matcher(usernameOrEmail).matches()) {
            log.info("CustomUserDetailsService - Input is an email. Searching by email: {}", usernameOrEmail);
            userOptional = userRepository.findByEmail(usernameOrEmail);
        } else {
            log.info("CustomUserDetailsService - Input is a username. Searching by username: {}", usernameOrEmail);
            userOptional = userRepository.findByUsername(usernameOrEmail);
        }

        User user = userOptional.orElseThrow(() -> {
            log.error("CustomUserDetailsService - User not found with identifier: {}", usernameOrEmail);
            return new UsernameNotFoundException("User not found with identifier: " + usernameOrEmail);
        });

        log.info("CustomUserDetailsService - Found user: ID={}, Username={}, Email={}, RoleId={}",
                user.getId(), user.getUsername(), user.getEmail(), user.getRoleId());

        Collection<? extends GrantedAuthority> authorities = getAuthorities(user);

        log.info("CustomUserDetailsService - Successfully loaded user '{}' with authorities: {}",
                user.getUsername(), authorities);

        // Return our custom UserDetails object that holds the full User entity
        return new CustomUserDetails(user, authorities);
    }
    
    /**
     * Get user authorities based on role
     *
     * @param user user entity
     * @return collection of authorities
     */
    private Collection<? extends GrantedAuthority> getAuthorities(User user) {
        String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
        List<SimpleGrantedAuthority> authorities = new ArrayList<>();

        // Add ROLE_X authority
        String authority = "ROLE_" + roleName;
        authorities.add(new SimpleGrantedAuthority(authority));

        log.info("CustomUserDetailsService - Generated authorities for user {}: [{}]",
                user.getUsername(), authority);

        // Add permissions based on role if needed
        // This can be extended to include specific permissions

        return authorities;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/security/JwtUtil.java">
package com.classroomapp.classroombackend.security;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SecurityException;

@Component
public class JwtUtil {

    private static final Logger log = LoggerFactory.getLogger(JwtUtil.class);

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration.ms}")
    private long jwtExpirationMs;

    private static final long JWT_TOKEN_VALIDITY = 24 * 60 * 60; // 24 hours

    public SecretKey getSecretKeyFromString() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }

    public String generateToken(String username, Integer roleId) {
        log.info("Generating token for user: {} with role ID: {}", username, roleId);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("username", username);
        claims.put("role", roleId);
    
        String token = Jwts.builder()
            .setClaims(claims)
            .setSubject(username)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * 1000))
            .signWith(getSecretKeyFromString(), SignatureAlgorithm.HS512)
            .compact();
            
        log.info("Token generated successfully for user: {} (first 20 chars): {}", 
            username, token.substring(0, Math.min(20, token.length())));
        
        return token;
    }

    public boolean validateToken(String token) {
        if (token == null) {
            log.error("JWT validation failed: token is null");
            return false;
        }
        
        try {
            log.debug("Validating JWT token");
            Jwts.parserBuilder()
                .setSigningKey(getSecretKeyFromString())
                .build()
                .parseClaimsJws(token);
            log.debug("JWT token validated successfully");
            return true;
        } catch (SecurityException e) {
            log.error("JWT validation failed: Invalid signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("JWT validation failed: Malformed token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT validation failed: Token expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT validation failed: Unsupported token: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT validation failed: Empty claims: {}", e.getMessage());
        } catch (Exception e) {
            log.error("JWT validation failed: Unknown error: {}", e.getMessage());
        }
        return false;
    }

    public String getSubjectFromToken(String token) {
        try {
            String subject = Jwts.parserBuilder()
                    .setSigningKey(getSecretKeyFromString())
                    .build()
                    .parseClaimsJws(token)
                    .getBody()
                    .getSubject();
            log.debug("Extracted subject from token: {}", subject);
            return subject;
        } catch (Exception e) {
            log.error("Error getting subject from token: {}", e.getMessage());
            return null;
        }
    }
    
    public Integer getRoleFromToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(getSecretKeyFromString())
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            
            Integer roleId = claims.get("role", Integer.class);
            log.debug("Extracted role ID from token: {}", roleId);
            return roleId;
        } catch (Exception e) {
            log.error("Error getting role from token: {}", e.getMessage());
            return null;
        }
    }
    
    // Convert roleId to roleName for easier reference
    public String convertRoleIdToName(Integer roleId) {
        if (roleId == null) return "USER";
        
        switch (roleId) {
            case 1: return "STUDENT";
            case 2: return "TEACHER";
            case 3: return "MANAGER";
            case 4: return "ADMIN";
            default: return "USER";
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AccomplishmentServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.AccomplishmentDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.Accomplishment;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.AccomplishmentRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AccomplishmentService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccomplishmentServiceImpl implements AccomplishmentService {

    private final AccomplishmentRepository accomplishmentRepository;
    private final UserRepository userRepository;

    @Override
    public List<AccomplishmentDto> getAccomplishmentsByOwner(UserDetails userDetails) {
        User user = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", userDetails.getUsername()));
        return accomplishmentRepository.findByStudentOrderByCompletionDateDesc(user).stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public AccomplishmentDto createAccomplishment(AccomplishmentDto accomplishmentDto, UserDetails userDetails) {
        User user = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", userDetails.getUsername()));

        Accomplishment accomplishment = new Accomplishment();
        accomplishment.setTitle(accomplishmentDto.getTitle());
        accomplishment.setDescription(accomplishmentDto.getDescription());
        accomplishment.setIssueDate(accomplishmentDto.getIssueDate());
        accomplishment.setStudent(user);

        Accomplishment saved = accomplishmentRepository.save(accomplishment);
        return convertToDto(saved);
    }

    @Override
    @Transactional
    public AccomplishmentDto updateAccomplishment(Long id, AccomplishmentDto accomplishmentDto) {
        Accomplishment accomplishment = accomplishmentRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Accomplishment", "id", id));
        
        // Update fields
        accomplishment.setTitle(accomplishmentDto.getTitle());
        accomplishment.setDescription(accomplishmentDto.getDescription());
        accomplishment.setIssueDate(accomplishmentDto.getIssueDate());

        Accomplishment updated = accomplishmentRepository.save(accomplishment);
        return convertToDto(updated);
    }

    @Override
    @Transactional
    public void deleteAccomplishment(Long id) {
        accomplishmentRepository.deleteById(id);
    }

    @Override
    public List<AccomplishmentDto> getStudentAccomplishments(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        return accomplishmentRepository.findByStudentOrderByCompletionDateDesc(user).stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    private AccomplishmentDto convertToDto(Accomplishment accomplishment) {
        AccomplishmentDto dto = new AccomplishmentDto();
        dto.setId(accomplishment.getId());
        dto.setTitle(accomplishment.getTitle());
        dto.setDescription(accomplishment.getDescription());
        dto.setIssueDate(accomplishment.getIssueDate());
        if(accomplishment.getStudent() != null) {
            dto.setUserId(accomplishment.getStudent().getId());
            dto.setUserName(accomplishment.getStudent().getFullName());
        }
        // Also map legacy fields
        dto.setCourseTitle(accomplishment.getCourseTitle());
        dto.setSubject(accomplishment.getSubject());
        dto.setTeacherName(accomplishment.getTeacherName());
        dto.setGrade(accomplishment.getGrade());
        dto.setCompletionDate(accomplishment.getCompletionDate());
        return dto;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AdminRequestServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.requestmanagement.RequestDTO;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.Request;
import com.classroomapp.classroombackend.repository.requestmanagement.RequestRepository;
import com.classroomapp.classroombackend.service.AdminRequestService;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.constants.RoleConstants;
import com.classroomapp.classroombackend.service.EmailService;
import org.springframework.security.crypto.password.PasswordEncoder;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AdminRequestServiceImpl implements AdminRequestService {

    private final RequestRepository requestRepository;
    private final ModelMapper modelMapper;
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final PasswordEncoder passwordEncoder;

    @Override
    public List<RequestDTO> getAllRequests() {
        return requestRepository.findAll().stream()
                .map(request -> modelMapper.map(request, RequestDTO.class))
                .collect(Collectors.toList());
    }

    @Override
    public RequestDTO approveRequest(Long id) {
        Request request = requestRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Request not found with id: " + id));
        // Logic to approve request and create user
        request.setStatus("COMPLETED");
        request.setResultStatus("APPROVED");
        request.setProcessedAt(java.time.LocalDateTime.now());
        Request savedRequest = requestRepository.save(request);

        // Xác định roleId từ requestedRole
        int roleId = RoleConstants.STUDENT;
        String requestedRole = request.getRequestedRole();
        if ("TEACHER".equalsIgnoreCase(requestedRole)) roleId = RoleConstants.TEACHER;
        else if ("MANAGER".equalsIgnoreCase(requestedRole)) roleId = RoleConstants.MANAGER;
        else if ("ADMIN".equalsIgnoreCase(requestedRole)) roleId = RoleConstants.ADMIN;

        // Kiểm tra user đã tồn tại chưa
        User user = userRepository.findByEmail(request.getEmail()).orElse(null);
        String tempPassword = null;
        if (user == null) {
            // Tạo user mới
            tempPassword = generateRandomPassword();
            user = new User();
            user.setEmail(request.getEmail());
            user.setFullName(request.getFullName());
            user.setUsername(request.getEmail());
            user.setPassword(passwordEncoder.encode(tempPassword));
            user.setRoleId(roleId);
            user.setPhoneNumber(request.getPhoneNumber());
            user.setStatus("active");
            userRepository.save(user);
        } else {
            // Nếu user đã có, cập nhật role nếu khác
            if (user.getRoleId() == null || user.getRoleId() != roleId) {
                user.setRoleId(roleId);
                userRepository.save(user);
            }
        }
        // Gửi email thông báo phê duyệt
        if (tempPassword != null) {
            emailService.sendApprovalEmail(user.getEmail(), user.getFullName(), user.getRole(), tempPassword);
        } else {
            emailService.sendRequestStatusNotification(user.getEmail(), user.getFullName(), user.getRole(), "APPROVED", null);
        }
        return modelMapper.map(savedRequest, RequestDTO.class);
    }

    @Override
    public RequestDTO rejectRequest(Long id, String reason) {
        Request request = requestRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Request not found with id: " + id));
        request.setStatus("COMPLETED");
        request.setResultStatus("REJECTED");
        request.setRejectReason(reason);
        request.setProcessedAt(java.time.LocalDateTime.now());
        Request savedRequest = requestRepository.save(request);
        // Gửi email từ chối
        emailService.sendRequestStatusNotification(request.getEmail(), request.getFullName(), request.getRequestedRole(), "REJECTED", reason);
        return modelMapper.map(savedRequest, RequestDTO.class);
    }

    @Override
    public List<RequestDTO> getPendingRequests() {
        return requestRepository.findByStatus("PENDING").stream()
                .map(request -> modelMapper.map(request, RequestDTO.class))
                .collect(Collectors.toList());
    }

    private String generateRandomPassword() {
        // Sinh mật khẩu ngẫu nhiên 8 ký tự
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        java.util.Random random = new java.util.Random();
        for (int i = 0; i < 8; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        return sb.toString();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AnnouncementServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.AnnouncementDto;
import com.classroomapp.classroombackend.dto.CreateAnnouncementDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.Announcement;
import com.classroomapp.classroombackend.model.Notification;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.AnnouncementRepository;
import com.classroomapp.classroombackend.repository.NotificationRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AnnouncementService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AnnouncementServiceImpl implements AnnouncementService {

    private final AnnouncementRepository announcementRepository;
    private final UserRepository userRepository;
    private final NotificationRepository notificationRepository;
    private final ModelMapper modelMapper;

    @Override
    @Transactional
    public AnnouncementDto createAnnouncement(CreateAnnouncementDto createDto, Long createdBy) {
        Announcement announcement = modelMapper.map(createDto, Announcement.class);
        announcement.setCreatedBy(createdBy);

        if (announcement.getStatus() == null) {
            announcement.setStatus(Announcement.AnnouncementStatus.ACTIVE);
        }
        if (announcement.getIsPinned() == null) {
            announcement.setIsPinned(false);
        }
        if (announcement.getPriority() == null) {
            announcement.setPriority(Announcement.Priority.NORMAL);
        }
        if (announcement.getTargetAudience() == null) {
            announcement.setTargetAudience(Announcement.TargetAudience.ALL);
        }

        Announcement savedAnnouncement = announcementRepository.save(announcement);
        
        // Create notifications for the target audience
        createNotificationsForAnnouncement(savedAnnouncement);

        return convertToDto(savedAnnouncement);
    }

    private void createNotificationsForAnnouncement(Announcement announcement) {
        List<User> targetUsers = new ArrayList<>();
        switch (announcement.getTargetAudience()) {
            case ALL:
                targetUsers.addAll(userRepository.findActiveStudents());
                targetUsers.addAll(userRepository.findActiveTeachers());
                break;
            case STUDENTS:
                targetUsers.addAll(userRepository.findActiveStudents());
                break;
            case TEACHERS:
                targetUsers.addAll(userRepository.findActiveTeachers());
                break;
        }

        User sender = userRepository.findById(announcement.getCreatedBy()).orElse(null);

        for (User user : targetUsers) {
            Notification notification = new Notification();
            notification.setRecipientId(user.getId());
            notification.setSender(sender != null ? sender.getFullName() : "System");
            notification.setMessage(announcement.getTitle());
            notification.setType("ANNOUNCEMENT");
            notification.setIsRead(false);
            notificationRepository.save(notification);
        }
    }

    @Override
    @Transactional
    public AnnouncementDto updateAnnouncement(Long announcementId, CreateAnnouncementDto updateDto) {
        Announcement existingAnnouncement = announcementRepository.findById(announcementId)
                .orElseThrow(() -> new ResourceNotFoundException("Announcement not found with id: " + announcementId));

        // Update fields
        existingAnnouncement.setTitle(updateDto.getTitle());
        existingAnnouncement.setContent(updateDto.getContent());
        // For simplicity, we are not updating all fields like in the old controller yet.
        // This can be expanded later.

        Announcement savedAnnouncement = announcementRepository.save(existingAnnouncement);
        return convertToDto(savedAnnouncement);
    }

    @Override
    @Transactional
    public void deleteAnnouncement(Long announcementId) {
        if (!announcementRepository.existsById(announcementId)) {
            throw new ResourceNotFoundException("Announcement not found with id: " + announcementId);
        }
        announcementRepository.deleteById(announcementId);
    }
    
    @Override
    public AnnouncementDto getAnnouncementById(Long announcementId) {
        Announcement announcement = announcementRepository.findById(announcementId)
                .orElseThrow(() -> new ResourceNotFoundException("Announcement not found with id: " + announcementId));
        return convertToDto(announcement);
    }
    
    public List<AnnouncementDto> getAllAnnouncements() {
        return announcementRepository.findAllByOrderByCreatedAtDesc().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public List<AnnouncementDto> getAnnouncementsForStudent() {
        List<Announcement> announcements = announcementRepository.findByTargetAudienceInAndStatusOrderByCreatedAtDesc(
                List.of(Announcement.TargetAudience.STUDENTS, Announcement.TargetAudience.ALL),
                Announcement.AnnouncementStatus.ACTIVE
        );
        return announcements.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }


    // --- Empty methods to be implemented later ---

    @Override
    public AnnouncementDto createAnnouncementWithAttachments(CreateAnnouncementDto createDto, List<MultipartFile> attachments, Long createdBy) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getActiveAnnouncementsByClassroom(Long classroomId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getGlobalAnnouncements() {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getPinnedAnnouncements(Long classroomId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getAnnouncementsByPriority(Long classroomId, String priority) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public AnnouncementDto archiveAnnouncement(Long announcementId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public AnnouncementDto togglePinAnnouncement(Long announcementId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public void markAsRead(Long announcementId, Long userId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getUnreadAnnouncements(Long classroomId, Long userId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public long countUnreadAnnouncements(Long classroomId, Long userId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> searchAnnouncements(Long classroomId, String searchTerm) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AnnouncementDto> getAnnouncementsByCreator(Long createdBy) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public void processScheduledAnnouncements() {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public void archiveExpiredAnnouncements() {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    private AnnouncementDto convertToDto(Announcement announcement) {
        AnnouncementDto dto = new AnnouncementDto();
        dto.setId(announcement.getId());
        dto.setTitle(announcement.getTitle());
        dto.setContent(announcement.getContent());
        dto.setClassroomId(announcement.getClassroomId());
        dto.setCreatedBy(announcement.getCreatedBy());
        dto.setTargetAudience(announcement.getTargetAudience() != null ? announcement.getTargetAudience().name() : null);
        dto.setPriority(announcement.getPriority() != null ? announcement.getPriority().name() : null);
        dto.setScheduledDate(announcement.getScheduledDate());
        dto.setExpiryDate(announcement.getExpiryDate());
        dto.setIsPinned(announcement.getIsPinned());
        dto.setAttachmentsCount(announcement.getAttachmentsCount());
        dto.setCreatedAt(announcement.getCreatedAt());
        dto.setUpdatedAt(announcement.getUpdatedAt());
        dto.setStatus(announcement.getStatus() != null ? announcement.getStatus().name() : null);

        // Set related entity names if available
        if (announcement.getClassroom() != null) {
            dto.setClassroomName(announcement.getClassroom().getName());
        }
        if (announcement.getCreator() != null) {
            dto.setCreatorName(announcement.getCreator().getFullName());
        }

        return dto;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AssessmentServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.AssessmentDto;
import com.classroomapp.classroombackend.dto.CreateAssessmentDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.exception.UnauthorizedException;
import com.classroomapp.classroombackend.model.Assessment;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.repository.AssessmentRepository;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.service.AssessmentService;

@Service
public class AssessmentServiceImpl implements AssessmentService {

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private LectureRepository lectureRepository;

    @Autowired
    private ModelMapper modelMapper;

    @Override
    public AssessmentDto createAssessment(Long lectureId, CreateAssessmentDto createAssessmentDto, String userEmail) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        if (!lecture.getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to create assessments for this lecture.");
        }

        Assessment assessment = modelMapper.map(createAssessmentDto, Assessment.class);
        assessment.setLecture(lecture);

        Assessment savedAssessment = assessmentRepository.save(assessment);
        return modelMapper.map(savedAssessment, AssessmentDto.class);
    }

    @Override
    public List<AssessmentDto> getAssessmentsByLectureId(Long lectureId) {
        if (!lectureRepository.existsById(lectureId)) {
            throw new ResourceNotFoundException("Lecture not found with id: " + lectureId);
        }
        List<Assessment> assessments = assessmentRepository.findByLectureId(lectureId);
        return assessments.stream()
                .map(assessment -> modelMapper.map(assessment, AssessmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public AssessmentDto getAssessmentById(Long assessmentId) {
        Assessment assessment = assessmentRepository.findById(assessmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assessment not found with id: " + assessmentId));
        return modelMapper.map(assessment, AssessmentDto.class);
    }

    @Override
    public void deleteAssessment(Long assessmentId, String userEmail) {
        Assessment assessment = assessmentRepository.findById(assessmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assessment not found with id: " + assessmentId));

        if (!assessment.getLecture().getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to delete this assessment.");
        }

        assessmentRepository.delete(assessment);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AssignmentServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.AssignmentRubricDto;
import com.classroomapp.classroombackend.dto.AssignmentSubmissionDto;
import com.classroomapp.classroombackend.dto.BulkGradingDto;
import com.classroomapp.classroombackend.dto.BulkGradingResultDto;
import com.classroomapp.classroombackend.dto.CreateFeedbackDto;
import com.classroomapp.classroombackend.dto.CreateRubricDto;
import com.classroomapp.classroombackend.dto.FeedbackDto;
import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.GradeDto;
import com.classroomapp.classroombackend.dto.GradingAnalyticsDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateAssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.AssignmentAttachment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.security.CustomUserDetails;
import com.classroomapp.classroombackend.service.AssignmentService;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;

@Service
@Lazy
@RequiredArgsConstructor
public class AssignmentServiceImpl implements AssignmentService {

    private final AssignmentRepository assignmentRepository;
    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final ClassroomEnrollmentRepository classroomEnrollmentRepository;
    private final SubmissionRepository submissionRepository;
    private final ModelMapper modelMapper;
    @Lazy
    private final ClassroomSecurityService classroomSecurityService;
    private static final Logger log = LoggerFactory.getLogger(AssignmentServiceImpl.class);



    /**
     * Find Assignment entity by ID
     */
    @Override
    public Assignment findEntityById(Long id) {
        return assignmentRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", id));
    }

    /**
     * Get assignment by ID
     */
    @Override
    public AssignmentDto GetAssignmentById(Long id) {
        Assignment assignment = findEntityById(id);
        return modelMapper.map(assignment, AssignmentDto.class);
    }

    @Override
    @Transactional
    public AssignmentDto CreateAssignment(CreateAssignmentDto createAssignmentDto, String teacherUsername) {
        log.info("AssignmentServiceImpl.CreateAssignment called with classroomId: {}, teacherUsername: {}",
                createAssignmentDto.getClassroomId(), teacherUsername);
        log.info("Assignment creation data: title={}, dueDate={}, points={}",
                createAssignmentDto.getTitle(), createAssignmentDto.getDueDate(), createAssignmentDto.getPoints());

        try {
            Classroom classroom = classroomRepository.findById(createAssignmentDto.getClassroomId())
                    .orElseThrow(() -> new ResourceNotFoundException("Classroom not found with id: " + createAssignmentDto.getClassroomId()));
            log.info("Found classroom: id={}, name={}", classroom.getId(), classroom.getName());

            // Handle authentication - if teacherUsername is null, get from security context
            User teacher = null;
            if (teacherUsername != null) {
                teacher = userRepository.findByEmail(teacherUsername)
                        .orElseThrow(() -> new ResourceNotFoundException("User", "email", teacherUsername));
            } else {
                // Get current authenticated user from security context
                org.springframework.security.core.Authentication authentication =
                    org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
                if (authentication != null && authentication.getName() != null) {
                    String currentUserEmail = authentication.getName();
                    teacher = userRepository.findByEmail(currentUserEmail)
                            .orElseThrow(() -> new ResourceNotFoundException("User", "email", currentUserEmail));
                } else {
                    throw new AccessDeniedException("No authenticated user found");
                }
            }
            log.info("Found teacher: id={}, username={}, email={}", teacher.getId(), teacher.getUsername(), teacher.getEmail());

            if (!classroomSecurityService.isTeacherOfClassroom(teacher, classroom.getId())) {
                log.error("Access denied: User {} is not the teacher of classroom {}", teacher.getUsername(), classroom.getId());
                throw new AccessDeniedException("User is not the teacher of this classroom.");
            }
            log.info("Security check passed: User {} is authorized to create assignments in classroom {}",
                    teacher.getUsername(), classroom.getId());

            Assignment assignment = modelMapper.map(createAssignmentDto, Assignment.class);
            assignment.setClassroom(classroom);
            log.info("Created assignment entity: title={}, dueDate={}, points={}",
                    assignment.getTitle(), assignment.getDueDate(), assignment.getPoints());

            if (createAssignmentDto.getAttachments() != null && !createAssignmentDto.getAttachments().isEmpty()) {
                log.info("Processing {} attachments for assignment", createAssignmentDto.getAttachments().size());
                for (FileUploadResponse fileInfo : createAssignmentDto.getAttachments()) {
                    AssignmentAttachment attachment = new AssignmentAttachment();
                    attachment.setFileName(fileInfo.getFileName());
                    attachment.setFileUrl(fileInfo.getFileUrl());
                    attachment.setFileType(fileInfo.getFileType());
                    attachment.setFileSize(fileInfo.getSize());
                    assignment.addAttachment(attachment);
                    log.info("Added attachment: fileName={}, fileType={}, fileSize={}",
                            fileInfo.getFileName(), fileInfo.getFileType(), fileInfo.getSize());
                }
            } else {
                log.info("No attachments provided for assignment");
            }

            Assignment savedAssignment = assignmentRepository.save(assignment);
            log.info("Successfully saved assignment with ID: {}", savedAssignment.getId());

            AssignmentDto result = modelMapper.map(savedAssignment, AssignmentDto.class);
            log.info("Assignment creation completed successfully: assignmentId={}, title={}",
                    result.getId(), result.getTitle());
            return result;

        } catch (Exception e) {
            log.error("Error creating assignment: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Override
    public AssignmentDto UpdateAssignment(Long id, CreateAssignmentDto updateAssignmentDto) {
        Assignment assignment = findEntityById(id);
        assignment.setTitle(updateAssignmentDto.getTitle());
        assignment.setDescription(updateAssignmentDto.getDescription());
        assignment.setDueDate(updateAssignmentDto.getDueDate());
        Assignment updatedAssignment = assignmentRepository.save(assignment);
        return modelMapper.map(updatedAssignment, AssignmentDto.class);
    }

    @Override
    public void DeleteAssignment(Long id) {
        assignmentRepository.deleteById(id);
    }
    
    @Override
    public List<AssignmentDto> GetAssignmentsByClassroom(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId).orElseThrow(() -> new EntityNotFoundException("Classroom with ID " + classroomId + " not found"));
        return assignmentRepository.findByClassroomOrderByDueDateAsc(classroom).stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> GetAllAssignments() {
        return assignmentRepository.findAll().stream().map(assignment -> modelMapper.map(assignment, AssignmentDto.class)).collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> getAssignmentsByCurrentTeacher() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String currentPrincipalName = authentication.getName(); // This is the email
        
        System.out.println("DEBUG: Current principal name (email): " + currentPrincipalName);
        
        // FIX: Look up user by email, which is the principal name from JWT
        User currentUser = userRepository.findByEmail(currentPrincipalName)
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", currentPrincipalName));

        System.out.println("DEBUG: Found user: " + currentUser.getUsername() + " with email: " + currentUser.getEmail());

        // Use the correct username from the fetched user entity to find assignments
        List<Assignment> assignments = assignmentRepository.findByTeacherUsername(currentUser.getUsername());

        System.out.println("DEBUG: Found " + assignments.size() + " assignments for teacher: " + currentUser.getUsername());

        return assignments.stream()
                .map(a -> modelMapper.map(a, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> GetAssignmentsByStudent(Long studentId) {
        // Find all classroom enrollments for the student
        List<ClassroomEnrollment> enrollments = classroomEnrollmentRepository.findByUserId(studentId);

        if (enrollments.isEmpty()) {
            return new ArrayList<>();
        }

        // Extract the classrooms from the enrollments
        List<Classroom> enrolledClassrooms = enrollments.stream()
                .map(ClassroomEnrollment::getClassroom)
                .collect(Collectors.toList());

        if (enrolledClassrooms.isEmpty()) {
            return new ArrayList<>();
        }

        // Fetch all assignments for those classrooms in a single query
        return assignmentRepository.findByClassroomInOrderByDueDateAsc(enrolledClassrooms)
                .stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> getAssignmentsByTeacher(Long teacherId) {
        // Kiểm tra xem giáo viên có tồn tại không
        if (!userRepository.existsById(teacherId)) {
            throw new EntityNotFoundException("Teacher not found with ID: " + teacherId);
        }
        // Gọi phương thức repository mới với truy vấn đã được định nghĩa rõ ràng
        return assignmentRepository.findByTeacherId(teacherId).stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }    @Override
    public List<AssignmentDto> GetUpcomingAssignmentsByClassroom(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId).orElseThrow(() -> new EntityNotFoundException("Classroom with ID " + classroomId + " not found"));
        return assignmentRepository.findByClassroomAndDueDateAfter(classroom, LocalDateTime.now()).stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }    @Override
    public List<AssignmentDto> GetPastAssignmentsByClassroom(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId).orElseThrow(() -> new EntityNotFoundException("Classroom with ID " + classroomId + " not found"));
        return assignmentRepository.findByClassroomAndDueDateBefore(classroom, LocalDateTime.now()).stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> SearchAssignmentsByTitle(String title) {
        return assignmentRepository.findByTitleContainingIgnoreCase(title).stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<AssignmentSubmissionDto> getAssignmentSubmissions(Long assignmentId) {
        log.info("AssignmentServiceImpl.getAssignmentSubmissions called with assignmentId: {}", assignmentId);
        
        try {
            // Find all submissions for this assignment
            List<Submission> submissions = submissionRepository.findByAssignmentId(assignmentId);
            log.info("Found {} submissions in database for assignment {}", submissions.size(), assignmentId);
            
            // Convert to DTOs
            List<AssignmentSubmissionDto> submissionDtos = new ArrayList<>();
            for (Submission submission : submissions) {
                try {
                    log.info("Processing submission ID: {}", submission.getId());
                    
                    AssignmentSubmissionDto dto = new AssignmentSubmissionDto();
                    dto.setId(submission.getId());
                    
                    // Safely access student
                    if (submission.getStudent() != null) {
                        dto.setStudentId(submission.getStudent().getId());
                        dto.setStudentName(submission.getStudent().getFullName());
                    } else {
                        log.warn("Submission {} has null student", submission.getId());
                        dto.setStudentId(0L);
                        dto.setStudentName("Unknown Student");
                    }
                    
                    dto.setSubmissionText(submission.getComment());
                    dto.setSubmissionDate(submission.getSubmittedAt());
                    
                    // Set grade field from score
                    if (submission.getScore() != null) {
                        dto.setGrade(submission.getScore().doubleValue());
                    }
                    
                    dto.setFeedback(submission.getFeedback());
                    dto.setStatus(submission.getScore() != null ? "GRADED" : "SUBMITTED");
                    
                    // Get first attachment URL if exists
                    try {
                        if (submission.getAttachments() != null && !submission.getAttachments().isEmpty()) {
                            dto.setAttachmentUrl(submission.getAttachments().get(0).getFileUrl());
                            log.info("Added attachment URL: {}", submission.getAttachments().get(0).getFileUrl());
                        }
                    } catch (Exception e) {
                        log.error("Error loading attachments for submission {}: {}", submission.getId(), e.getMessage());
                    }
                    
                    submissionDtos.add(dto);
                    log.info("Successfully processed submission {}", submission.getId());
                    
                } catch (Exception e) {
                    log.error("Error processing submission {}: {}", submission.getId(), e.getMessage(), e);
                }
            }
            
            log.info("Returning {} submission DTOs", submissionDtos.size());
            return submissionDtos;
            
        } catch (Exception e) {
            log.error("Error in getAssignmentSubmissions: {}", e.getMessage(), e);
            return new ArrayList<>();
        }
    }

    @Override
    @Transactional
    public GradeDto gradeSubmission(Long assignmentId, Long submissionId, GradeSubmissionDto gradeSubmissionDto) {
        log.info("gradeSubmission called with assignmentId: {}, submissionId: {}, score: {}, feedback: {}",
                assignmentId, submissionId, gradeSubmissionDto.getScore(), gradeSubmissionDto.getFeedback());

        // Find the submission by its ID
        Submission submission = submissionRepository.findById(submissionId)
                .orElseThrow(() -> new ResourceNotFoundException("Submission", "id", submissionId));

        // Optional: Verify the submission belongs to the assignment
        if (!submission.getAssignment().getId().equals(assignmentId)) {
            throw new IllegalArgumentException("Submission with id " + submissionId + " does not belong to assignment with id " + assignmentId);
        }

        // Get the current authenticated user (the grader)
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated() || !(authentication.getPrincipal() instanceof CustomUserDetails)) {
            throw new InsufficientAuthenticationException("User must be authenticated to grade a submission.");
        }
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        User grader = userRepository.findById(userDetails.getId())
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userDetails.getId()));

        // Update the submission with the grade and feedback
        submission.setScore(gradeSubmissionDto.getScore());
        submission.setFeedback(gradeSubmissionDto.getFeedback());
        submission.setGradedAt(LocalDateTime.now());
        submission.setGradedBy(grader); // Set the grader

        // Save the updated submission
        Submission savedSubmission = submissionRepository.save(submission);
        log.info("Successfully graded and saved submission with ID: {}", savedSubmission.getId());

        // Return a DTO representing the grade
        return new GradeDto(
                savedSubmission.getId(),
                savedSubmission.getAssignment().getId(),
                savedSubmission.getScore() != null ? savedSubmission.getScore().doubleValue() : null,
                savedSubmission.getFeedback(),
                savedSubmission.getGradedAt(),
                grader.getFullName());
    }

    @Override
    public AssignmentRubricDto getAssignmentRubric(Long assignmentId) {
        return null;
    }

    @Override
    public AssignmentRubricDto createAssignmentRubric(Long assignmentId, CreateRubricDto createRubricDto) {
        return null;
    }

    @Override
    public BulkGradingResultDto bulkGradeSubmissions(Long assignmentId, BulkGradingDto bulkGradingDto) {
        return null;
    }

    @Override
    public GradingAnalyticsDto getGradingAnalytics(Long assignmentId) {
        return null;
    }

    @Override
    public FeedbackDto provideFeedback(Long assignmentId, CreateFeedbackDto createFeedbackDto) {
        return null;
    }

    @Override
    public List<AssignmentDto> getAssignmentsByCurrentStudent() {
        log.info("getAssignmentsByCurrentStudent: Getting assignments for current student");
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !(authentication.getPrincipal() instanceof CustomUserDetails)) {
            throw new InsufficientAuthenticationException("User is not properly authenticated");
        }
        
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        Long studentId = userDetails.getId();

        log.info("getAssignmentsByCurrentStudent: authenticated user id: {}", studentId);

        List<ClassroomEnrollment> enrollments = classroomEnrollmentRepository.findByUserId(studentId);

        if (enrollments.isEmpty()) {
            return new ArrayList<>();
        }

        // Extract the classrooms from the enrollments
        List<Classroom> enrolledClassrooms = enrollments.stream()
                .map(ClassroomEnrollment::getClassroom)
                .collect(Collectors.toList());

        if (enrolledClassrooms.isEmpty()) {
            return new ArrayList<>();
        }

        // Fetch all assignments for those classrooms in a single query
        return assignmentRepository.findByClassroomInOrderByDueDateAsc(enrolledClassrooms)
                .stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> findByTeacherId(Long teacherId) {
        List<Classroom> teacherClassrooms = classroomRepository.findByTeacherId(teacherId);
        return assignmentRepository.findByClassroomInOrderByDueDateAsc(teacherClassrooms)
                .stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> findByStudentId(Long studentId) {
        List<ClassroomEnrollment> enrollments = classroomEnrollmentRepository.findByUserId(studentId);
        List<Classroom> enrolledClassrooms = enrollments.stream()
                .map(ClassroomEnrollment::getClassroom)
                .collect(Collectors.toList());
        
        return assignmentRepository.findByClassroomInOrderByDueDateAsc(enrolledClassrooms)
                .stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<AssignmentDto> getAllAssignments() {
        return assignmentRepository.findAll()
                .stream()
                .map(assignment -> modelMapper.map(assignment, AssignmentDto.class))
                .collect(Collectors.toList());
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AttendanceServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceRecordDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceResultDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSubmitDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateAttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateOrUpdateAttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.MyAttendanceHistoryDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.StudentAttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.TeachingHistoryDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.attendancemanagement.Attendance;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceSession;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceStatus;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceRepository;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceSessionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AttendanceService;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AttendanceServiceImpl implements AttendanceService {

    private final AttendanceRepository attendanceRepository;
    private final AttendanceSessionRepository attendanceSessionRepository;
    private final ClassroomEnrollmentRepository enrollmentRepository;
    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final ClassroomSecurityService classroomSecurityService;
    private final LectureRepository lectureRepository; // Inject LectureRepository

    @Override
    @Transactional
    public void createOrUpdateAttendance(CreateOrUpdateAttendanceDto dto) {
       throw new UnsupportedOperationException("This method is deprecated and part of the old attendance flow.");
    }

    @Override
    @Transactional
    public void submitAttendance(AttendanceSubmitDto submitDto) {
        // Validate lecture and classroom existence
        Lecture lecture = lectureRepository.findById(submitDto.getLectureId())
                .orElseThrow(() -> new BusinessLogicException("Lecture not found with ID: " + submitDto.getLectureId()));

        Classroom classroom = classroomRepository.findById(submitDto.getClassroomId())
                .orElseThrow(() -> new BusinessLogicException("Classroom not found with ID: " + submitDto.getClassroomId()));

        // Ensure the lecture belongs to the classroom
        if (!lecture.getClassroom().getId().equals(classroom.getId())) {
            throw new BusinessLogicException("Lecture does not belong to the specified classroom.");
        }

        // Find or create an AttendanceSession for this lecture
        // For simplicity, we'll assume one session per lecture. In a real scenario,
        // you might have multiple sessions per lecture (e.g., re-takes)
        AttendanceSession session = attendanceSessionRepository.findByLectureId(lecture.getId())
                .orElseGet(() -> {
                    AttendanceSession newSession = new AttendanceSession();
                    newSession.setClassroom(classroom);
                    newSession.setLecture(lecture);
                    newSession.setCreatedAt(LocalDateTime.now());
                    newSession.setExpiresAt(LocalDateTime.now().plusHours(1)); // Example: session expires in 1 hour
                    newSession.setIsOpen(true);
                    newSession.setSessionDate(LocalDate.now()); // Set session date to today
                    return attendanceSessionRepository.save(newSession);
                });

        // Ensure session is open and not expired if a new one wasn't created
        if (!session.getIsOpen() ||
            (session.getExpiresAt() != null && LocalDateTime.now().isAfter(session.getExpiresAt()))) {
             // Optionally reopen or create new session based on business rules
             // For this task, we will just throw an error or handle accordingly
            session.setIsOpen(true); // Reopen for submission
            session.setExpiresAt(LocalDateTime.now().plusHours(1)); // Extend expiration
            attendanceSessionRepository.save(session);
        }

        // Process each attendance record
        for (AttendanceSubmitDto.AttendanceRecordUpdateDto recordDto : submitDto.getRecords()) {
            User student = userRepository.findById(recordDto.getStudentId())
                    .orElseThrow(() -> new BusinessLogicException("Student not found with ID: " + recordDto.getStudentId()));

            // Find existing record or create new one
            Attendance attendance = attendanceRepository.findBySession_IdAndStudent_Id(session.getId(), student.getId())
                    .orElseGet(Attendance::new);

            attendance.setSession(session);
            attendance.setStudent(student);
            attendance.setStatus(AttendanceStatus.valueOf(recordDto.getStatus().toUpperCase())); // Convert string to enum

            attendanceRepository.save(attendance);
        }
    }

    @Override
    @Transactional
    public AttendanceSession createSession(CreateAttendanceSessionDto createDto) {
        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();

        if (!classroomSecurityService.isTeacherOfClassroom(user, createDto.getClassroomId())) {
            throw new BusinessLogicException("Only the teacher can create an attendance session.");
        }

        Classroom classroom = classroomRepository.findById(createDto.getClassroomId())
                .orElseThrow(() -> new BusinessLogicException("Classroom not found"));

        AttendanceSession session = new AttendanceSession();
        session.setCreatedAt(LocalDateTime.now());
        session.setExpiresAt(LocalDateTime.ofInstant(createDto.getEndTime(), ZoneId.systemDefault()));
        session.setClassroom(classroom);
        session.setIsOpen(true);

        return attendanceSessionRepository.save(session);
    }

    @Override
    public AttendanceSessionDto getActiveSession(Long classroomId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public void markAttendance(StudentAttendanceDto dto, UserDetails userDetails) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AttendanceResultDto> getSessionResults(Long sessionId) {
        throw new UnsupportedOperationException("Not implemented yet");
    }

    @Override
    public List<AttendanceRecordDto> getAttendanceForLecture(Long lectureId, Long classroomId) {
        List<User> studentsInClass = enrollmentRepository.findById_ClassroomId(classroomId)
                .stream()
                .map(enrollment -> enrollment.getUser())
                .collect(Collectors.toList());

        Optional<AttendanceSession> sessionOpt = attendanceSessionRepository.findByLectureId(lectureId);

        if (sessionOpt.isEmpty()) {
            return studentsInClass.stream()
                    .map(student -> new AttendanceRecordDto(student.getId(), student.getFullName(), student.getEmail(), null))
                    .collect(Collectors.toList());
        }

        AttendanceSession session = sessionOpt.get();
        List<Attendance> records = session.getRecords();
        Map<Long, AttendanceStatus> statusMap = records.stream()
            .collect(Collectors.toMap(record -> record.getStudent().getId(), Attendance::getStatus));

        return studentsInClass.stream()
                .map(student -> {
                    AttendanceStatus status = statusMap.get(student.getId());
                    return new AttendanceRecordDto(student.getId(), student.getFullName(), student.getEmail(), status);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<MyAttendanceHistoryDto> getMyAttendanceHistory(Long studentId, Long classroomId) {
        System.out.println("Service: Getting attendance history for student " + studentId + " in classroom " + classroomId);
        List<Attendance> rawAttendance = attendanceRepository.findByStudentIdAndSession_ClassroomIdOrderBySession_SessionDateDesc(studentId, classroomId);
        System.out.println("Service: Found " + rawAttendance.size() + " raw attendance records");

        List<MyAttendanceHistoryDto> dtos = rawAttendance.stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
        System.out.println("Service: Found " + dtos.size() + " DTO records");
        return dtos;
    }

    private MyAttendanceHistoryDto mapToDto(Attendance attendance) {
        MyAttendanceHistoryDto dto = new MyAttendanceHistoryDto();
        dto.setLectureId(attendance.getSession().getLecture().getId());
        dto.setLectureTitle(attendance.getSession().getLecture().getTitle());
        dto.setSessionDate(attendance.getSession().getSessionDate());
        dto.setStatus(attendance.getStatus());
        return dto;
    }
    
    @Override
    public List<TeachingHistoryDto> getTeachingHistory(Long teacherId) {
        List<AttendanceSession> sessions = attendanceSessionRepository.findTeachingHistoryByTeacherId(teacherId);
        
        return sessions.stream().map(session -> {
            Lecture lecture = session.getLecture();
            TeachingHistoryDto dto = new TeachingHistoryDto();
            dto.setLectureId(lecture.getId());
            dto.setLectureTitle(lecture.getTitle());
            dto.setClassroomId(session.getClassroom().getId());
            dto.setClassroomName(lecture.getClassroom() != null ? lecture.getClassroom().getName() : "Unknown");
            dto.setLectureDate(lecture.getLectureDate());
            dto.setClockInTime(session.getTeacherClockInTime());
            return dto;
        }).collect(Collectors.toList());
    }

    @Override
    @Transactional
    public Attendance recordStudentAttendance(Long sessionId, String studentCode) {
        // We get the user from the security context, assuming they are logged in.
        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();

        AttendanceSession session = attendanceSessionRepository.findById(sessionId)
                .orElseThrow(() -> new BusinessLogicException("Attendance session not found"));

        if (!session.getIsOpen()) {
            throw new BusinessLogicException("Attendance session is closed");
        }
        if (session.getExpiresAt() != null && LocalDateTime.now().isAfter(session.getExpiresAt())) {
            throw new BusinessLogicException("Attendance session has expired");
        }

        if (attendanceRepository.findBySession_IdAndStudent_Id(sessionId, user.getId()).isPresent()) {
            throw new BusinessLogicException("Attendance already recorded for this session");
        }

        Attendance record = new Attendance();
        record.setSession(session);
        record.setStudent(user);
        record.setStatus(AttendanceStatus.PRESENT);

        return attendanceRepository.save(record);
    }

    @Override
    @Transactional
    public AttendanceSession closeSession(Long sessionId) {
        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        AttendanceSession session = attendanceSessionRepository.findById(sessionId)
                .orElseThrow(() -> new BusinessLogicException("Attendance session not found"));

        if (!classroomSecurityService.isTeacherOfClassroom(user, session.getClassroom().getId())) {
            throw new BusinessLogicException("Only the teacher can close the session");
        }

        session.setIsOpen(false);
        return attendanceSessionRepository.save(session);
    }

    @Override
    public List<StudentAttendanceDto> getSessionAttendance(Long sessionId) {
        // Security check: only teacher of the class can view all records for a session
        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        AttendanceSession session = attendanceSessionRepository.findById(sessionId)
                .orElseThrow(() -> new BusinessLogicException("Attendance session not found"));

        if (!classroomSecurityService.isTeacherOfClassroom(user, session.getClassroom().getId())) {
            throw new BusinessLogicException("You are not authorized to view this attendance session.");
        }

        List<Attendance> records = attendanceRepository.findBySession(session);
        return records.stream()
                .map(this::mapToStudentAttendanceDto)
                .collect(Collectors.toList());
    }

    @Override
    public AttendanceResultDto getAttendanceResult(Long classroomId, Long studentId) {
        // Security: Teacher of the class or the student themselves can view the result.
        User currentUser = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        boolean isTeacher = classroomSecurityService.isTeacherOfClassroom(currentUser, classroomId);
        boolean isSelf = currentUser.getId().equals(studentId);

        if (!isTeacher && !isSelf) {
            throw new BusinessLogicException("Not authorized to view this attendance result.");
        }

        List<AttendanceSession> sessions = attendanceSessionRepository.findByClassroomId(classroomId);
        long totalSessions = sessions.size();
        if (totalSessions == 0) {
            return new AttendanceResultDto(0, 0, 0.0, Collections.emptyList());
        }

        List<Attendance> studentRecords = attendanceRepository.findByStudentIdAndSessionClassroomId(studentId, classroomId);
        long attendedSessions = studentRecords.size();
        double attendancePercentage = (double) attendedSessions / totalSessions * 100;

        List<StudentAttendanceDto> detailedRecords = studentRecords.stream()
                .map(this::mapToStudentAttendanceDto)
                .collect(Collectors.toList());

        return new AttendanceResultDto(totalSessions, attendedSessions, attendancePercentage, detailedRecords);
    }

    private StudentAttendanceDto mapToStudentAttendanceDto(Attendance record) {
        StudentAttendanceDto dto = new StudentAttendanceDto();
        dto.setSessionId(record.getSession().getId());
        return dto;
    }

    @Override
    public List<AttendanceDto> findByUserId(Long userId) {
        // First find the user
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found with id: " + userId));
        
        List<Attendance> attendances = attendanceRepository.findByStudent(user);
        return attendances.stream()
                .map(this::mapToAttendanceDto)
                .collect(Collectors.toList());
    }

    private AttendanceDto mapToAttendanceDto(Attendance attendance) {
        AttendanceDto dto = new AttendanceDto();
        dto.setId(attendance.getId());
        dto.setUserId(attendance.getStudent().getId());
        dto.setUserName(attendance.getStudent().getUsername());
        dto.setUserFullName(attendance.getStudent().getFullName());
        dto.setPresent(attendance.getStatus() == AttendanceStatus.PRESENT);
        dto.setAttendanceType(attendance.getStatus().name());
        LocalDate sessionDate = attendance.getSession().getSessionDate();
        dto.setSessionDate(sessionDate != null ? sessionDate.atStartOfDay() : LocalDateTime.now());
        if (attendance.getSession().getClassroom() != null) {
            dto.setClassroomId(attendance.getSession().getClassroom().getId());
            dto.setClassroomName(attendance.getSession().getClassroom().getName());
        }
        return dto;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AttendanceSessionServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.security.Principal;
import java.util.List;

import org.modelmapper.ModelMapper;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateAttendanceSessionDto;
import com.classroomapp.classroombackend.repository.attendancemanagement.AttendanceSessionRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.AttendanceSessionService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AttendanceSessionServiceImpl implements AttendanceSessionService {

    private final AttendanceSessionRepository attendanceSessionRepository;
    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;


    @Override
    public ResponseEntity<AttendanceSessionDto> createSession(CreateAttendanceSessionDto createDto, Principal principal) {
        return null;
    }

    @Override
    public ResponseEntity<List<AttendanceSessionDto>> getSessionsForClassroom(Long classroomId, Principal principal) {
        return null;
    }

    @Override
    public ResponseEntity<AttendanceSessionDto> getSessionDetails(Long sessionId, Principal principal) {
        return null;
    }

    @Override
    public ResponseEntity<?> closeSession(Long sessionId, Principal principal) {
        return null;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/AuthServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.GoogleAuthRequestDto;
import com.classroomapp.classroombackend.dto.LoginRequestDto;
import com.classroomapp.classroombackend.dto.LoginResponseDto;
import com.classroomapp.classroombackend.dto.PasswordConfirmationDto;
import com.classroomapp.classroombackend.dto.PasswordResetRequestDto;
import com.classroomapp.classroombackend.dto.RegisterDto;
import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.security.JwtUtil;
import com.classroomapp.classroombackend.service.AuthService;
import com.classroomapp.classroombackend.service.UserService;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.FirebaseToken;

import io.jsonwebtoken.Jwts;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of AuthService
 */
@Service
@Slf4j
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;
    private final ModelMapper modelMapper;

    @Autowired
    public AuthServiceImpl(
            UserRepository userRepository,
            UserService userService,
            PasswordEncoder passwordEncoder,
            JwtUtil jwtUtil,
            AuthenticationManager authenticationManager,
            ModelMapper modelMapper) {
        this.userRepository = userRepository;
        this.userService = userService;
        this.passwordEncoder = passwordEncoder;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
        this.modelMapper = modelMapper;
    }

    @Override
    public LoginResponseDto authenticateUser(LoginRequestDto loginRequest) {
        log.info("Authenticating user: {}", loginRequest.getUsername());
        
        try {
            // Authenticate with Spring Security
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()));
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            // Get user details
            User user = userRepository.findByUsername(loginRequest.getUsername())
                    .orElseThrow(() -> new ResourceNotFoundException("User not found"));
            
            // Generate token - FIX: Use email as the primary subject for the token
            String token = generateToken(user.getEmail(), user.getRoleId(), user.getEmail());
            
            // Get role name
            String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
            
            log.info("User authenticated successfully: {}", user.getUsername());
            
            // Build response
            return LoginResponseDto.builder()
                    .token(token)
                    .role(roleName)
                    .roleId(user.getRoleId())
                    .username(user.getUsername())
                    .email(user.getEmail())
                    .userId(user.getId())
                    .build();
        } catch (BadCredentialsException e) {
            log.error("Authentication failed for user {}: {}", loginRequest.getUsername(), e.getMessage());
            throw new IllegalArgumentException("Invalid username or password");
        }
    }

    @Override
    public UserDto registerUser(RegisterDto registerDto) {
        log.info("Registering new user: {}", registerDto.getUsername());
        
        // Check if username already exists
        if (userService.IsUsernameExists(registerDto.getUsername())) {
            log.warn("Registration failed: Username {} already exists", registerDto.getUsername());
            throw new IllegalArgumentException("Username already taken");
        }

        // Check if email already exists
        if (userService.IsEmailExists(registerDto.getEmail())) {
            log.warn("Registration failed: Email {} already registered", registerDto.getEmail());
            throw new IllegalArgumentException("Email already registered");
        }

        // Create new user
        User user = new User();
        user.setUsername(registerDto.getUsername());
        user.setPassword(passwordEncoder.encode(registerDto.getPassword()));
        user.setEmail(registerDto.getEmail());
        user.setFullName(registerDto.getFullName());
        
        // Set default role if not provided
        user.setRoleId(registerDto.getRoleId() != null ? registerDto.getRoleId() : 1);

        User savedUser = userRepository.save(user);
        log.info("User registered successfully: {}", savedUser.getUsername());

        return modelMapper.map(savedUser, UserDto.class);
    }

    @Override
    public LoginResponseDto authenticateWithGoogle(GoogleAuthRequestDto googleAuthRequest) {
        log.info("Authenticating with Google ID token");
        
        try {
            // Verify Google ID token
            FirebaseToken decodedToken = FirebaseAuth.getInstance().verifyIdToken(googleAuthRequest.getIdToken());
            String email = decodedToken.getEmail();
            
            log.info("Google token verified for email: {}", email);
            
            // Check if user exists
            User user = userRepository.findByEmail(email)
                .orElseGet(() -> {
                    // Create new user if not exists
                    log.info("Creating new user for Google account: {}", email);
                    User newUser = new User();
                    newUser.setEmail(email);
                    newUser.setUsername(email); // Use email as username for Google users
                    newUser.setFullName(decodedToken.getName());
                    newUser.setPassword(passwordEncoder.encode(generateRandomPassword()));
                    newUser.setRoleId(1); // Default role - STUDENT
                    return userRepository.save(newUser);
                });
            
            // Generate JWT
            String roleName = jwtUtil.convertRoleIdToName(user.getRoleId());
            String token = generateToken(user.getEmail(), user.getRoleId(), user.getEmail());
            
            log.info("User authenticated via Google successfully: {}", email);
            
            return LoginResponseDto.builder()
                    .token(token)
                    .role(roleName)
                    .roleId(user.getRoleId())
                    .username(user.getUsername())
                    .email(user.getEmail())
                    .userId(user.getId())
                    .build();
        } catch (FirebaseAuthException e) {
            log.error("Google authentication failed: {}", e.getMessage());
            throw new IllegalArgumentException("Invalid Google ID token", e);
        }
    }

    @Override
    public void requestPasswordReset(PasswordResetRequestDto passwordResetRequest) {
        log.info("Password reset requested for email: {}", passwordResetRequest.getEmail());
        
        User user = userRepository.findByEmail(passwordResetRequest.getEmail())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // Generate a password reset token
        String resetToken = generateToken(user.getUsername(), user.getRoleId(), user.getEmail());
        
        userService.sendPasswordResetEmail(user.getEmail(), resetToken);
        log.info("Password reset email sent to: {}", user.getEmail());
    }

    @Override
    public void resetPassword(PasswordConfirmationDto passwordConfirmation) {
        log.info("Processing password reset with token");
        
        // Validate token
        if (!jwtUtil.validateToken(passwordConfirmation.getToken())) {
            log.warn("Invalid or expired password reset token");
            throw new IllegalArgumentException("Invalid or expired token");
        }

        // Get username from token
        String username = jwtUtil.getSubjectFromToken(passwordConfirmation.getToken());

        // Update password
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        user.setPassword(passwordEncoder.encode(passwordConfirmation.getNewPassword()));
        userRepository.save(user);
        log.info("Password reset successful for user: {}", username);
    }

    @Override
    public String generateToken(String subject, Integer roleId, String email) {
        log.debug("Generating JWT token for user: {}", subject);
        
        String roleName = jwtUtil.convertRoleIdToName(roleId);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", subject);  // Subject can be email or username
        claims.put("email", email);
        claims.put("role", roleId); // Keep roleId for potential fine-grained checks
        claims.put("roles", new String[]{roleName}); // Keep roles for standard Spring Security
        
        // Generate JWT token with claims
        String token = Jwts.builder()
            .setClaims(claims)
            .setSubject(subject) // The principal identifier
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) // 24 hours
            .signWith(jwtUtil.getSecretKeyFromString())
            .compact();
        
        log.debug("JWT token generated successfully");
        return token;
    }
    
    /**
     * Generate random password for Google users
     * 
     * @return random password
     */
    private String generateRandomPassword() {
        return "GoogleAuth-" + System.currentTimeMillis();
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/BlogServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.text.Normalizer;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.BlogDto;
import com.classroomapp.classroombackend.dto.CreateBlogDto;
import com.classroomapp.classroombackend.model.Blog;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.BlogRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.BlogService;

@Service
public class BlogServiceImpl implements BlogService {

    private final BlogRepository blogRepository;
    private final UserRepository userRepository;

    @Autowired
    public BlogServiceImpl(BlogRepository blogRepository, UserRepository userRepository) {
        this.blogRepository = blogRepository;
        this.userRepository = userRepository;
    }

    @Override
    @Transactional
    public BlogDto createBlog(CreateBlogDto createBlogDto, Long authorId) {
        User author = userRepository.findById(authorId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Blog blog = new Blog();
        blog.setTitle(createBlogDto.getTitle());
        blog.setSlug(generateSlug(createBlogDto.getTitle()));
        blog.setDescription(createBlogDto.getDescription());
        blog.setImageUrl(createBlogDto.getImageUrl());
        blog.setVideoUrl(createBlogDto.getVideoUrl());
        blog.setTags(createBlogDto.getTags());
        blog.setThumbnailUrl(createBlogDto.getThumbnailUrl());
        blog.setAuthor(author);
        blog.setIsPublished(createBlogDto.getIsPublished());
        blog.setStatus(createBlogDto.getIsPublished() ? "published" : "draft");
        
        LocalDateTime now = LocalDateTime.now();
        blog.setLastEditedDate(now);
        blog.setLastEditedBy(author);
        
        if (createBlogDto.getIsPublished()) {
            blog.setPublishedDate(now);
        }
        
        Blog savedBlog = blogRepository.save(blog);
        return convertToDto(savedBlog);
    }

    @Override
    public BlogDto getBlogById(Long id) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Blog not found"));
        return convertToDto(blog);
    }

    @Override
    public BlogDto getBlogBySlug(String slug) {
        Blog blog = blogRepository.findBySlug(slug)
                .orElseThrow(() -> new RuntimeException("Blog not found with slug: " + slug));
        return convertToDto(blog);
    }

    @Override
    public List<BlogDto> getAllBlogs() {
        List<Blog> blogs = blogRepository.findAll();
        return blogs.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public List<BlogDto> getPublishedBlogs() {
        List<Blog> blogs = blogRepository.findByIsPublishedTrue();
        return blogs.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public List<BlogDto> getBlogsByAuthor(Long authorId) {
        List<Blog> blogs = blogRepository.findByAuthorId(authorId);
        return blogs.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public BlogDto updateBlog(Long id, CreateBlogDto updateBlogDto, Long editorId) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Blog not found"));
        
        User editor = userRepository.findById(editorId)
                .orElseThrow(() -> new RuntimeException("Editor user not found"));
        
        // Only allow managers or the original author to edit
        if (!isManager(editor) && !blog.getAuthor().getId().equals(editorId)) {
            throw new RuntimeException("Not authorized to edit this blog");
        }
        
        // Regenerate slug if title is changed
        if (!blog.getTitle().equals(updateBlogDto.getTitle())) {
            blog.setSlug(generateSlug(updateBlogDto.getTitle()));
        }
        
        blog.setTitle(updateBlogDto.getTitle());
        blog.setDescription(updateBlogDto.getDescription());
        blog.setImageUrl(updateBlogDto.getImageUrl());
        blog.setVideoUrl(updateBlogDto.getVideoUrl());
        blog.setTags(updateBlogDto.getTags());
        blog.setThumbnailUrl(updateBlogDto.getThumbnailUrl());
        
        // If publishing status is changing
        if (blog.getIsPublished() != updateBlogDto.getIsPublished()) {
            blog.setIsPublished(updateBlogDto.getIsPublished());
            blog.setStatus(updateBlogDto.getIsPublished() ? "published" : "draft");
            
            if (updateBlogDto.getIsPublished()) {
                blog.setPublishedDate(LocalDateTime.now());
            }
        }
        
        blog.setLastEditedDate(LocalDateTime.now());
        blog.setLastEditedBy(editor);
        
        Blog updatedBlog = blogRepository.save(blog);
        return convertToDto(updatedBlog);
    }

    @Override
    @Transactional
    public void deleteBlog(Long id) {
        if (!blogRepository.existsById(id)) {
            throw new RuntimeException("Blog not found");
        }
        blogRepository.deleteById(id);
    }

    @Override
    @Transactional
    public BlogDto publishBlog(Long id, Long publisherId) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Blog not found"));
        
        User publisher = userRepository.findById(publisherId)
                .orElseThrow(() -> new RuntimeException("Publisher user not found"));
        
        // Only managers or the original author can publish
        if (!isManager(publisher) && !blog.getAuthor().getId().equals(publisherId)) {
            throw new RuntimeException("Not authorized to publish this blog");
        }
        
        if (!blog.getIsPublished()) {
            blog.setIsPublished(true);
            blog.setStatus("published");
            blog.setPublishedDate(LocalDateTime.now());
            blog.setLastEditedDate(LocalDateTime.now());
            blog.setLastEditedBy(publisher);
            
            Blog updatedBlog = blogRepository.save(blog);
            return convertToDto(updatedBlog);
        }
        
        return convertToDto(blog);
    }

    @Override
    @Transactional
    public BlogDto unpublishBlog(Long id, Long unpublisherId) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Blog not found"));
        
        User unpublisher = userRepository.findById(unpublisherId)
                .orElseThrow(() -> new RuntimeException("Unpublisher user not found"));
        
        // Only managers or the original author can unpublish
        if (!isManager(unpublisher) && !blog.getAuthor().getId().equals(unpublisherId)) {
            throw new RuntimeException("Not authorized to unpublish this blog");
        }
        
        if (blog.getIsPublished()) {
            blog.setIsPublished(false);
            blog.setStatus("draft");
            blog.setLastEditedDate(LocalDateTime.now());
            blog.setLastEditedBy(unpublisher);
            
            Blog updatedBlog = blogRepository.save(blog);
            return convertToDto(updatedBlog);
        }
        
        return convertToDto(blog);
    }

    @Override
    public List<BlogDto> searchBlogs(String keyword) {
        // Safely handle null or empty keyword
        if (keyword == null || keyword.trim().isEmpty()) {
            return getPublishedBlogs(); // Return all published blogs if no search term
        }
        
        try {
            // Sanitize the keyword and perform search
            String sanitizedKeyword = keyword.trim();
            System.out.println("Searching blogs with keyword: " + sanitizedKeyword);
            
            List<Blog> blogs = blogRepository.searchBlogs(sanitizedKeyword);
            System.out.println("Found " + blogs.size() + " blogs matching the search criteria");
            
            return blogs.stream()
                   .map(this::convertToDto)
                   .collect(Collectors.toList());
        } catch (Exception e) {
            // Log the error with more details
            System.err.println("Error searching blogs with keyword '" + keyword + "': " + e.getMessage());
            e.printStackTrace();
            // Return empty list instead of throwing exception
            return new ArrayList<>();
        }
    }

    @Override
    public List<BlogDto> getBlogsByTag(String tag) {
        List<Blog> blogs = blogRepository.findByTag(tag);
        return blogs.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }
    
    private static final Pattern NONLATIN = Pattern.compile("[^\\w-]");
    private static final Pattern WHITESPACE = Pattern.compile("[\\s]");

    private String generateSlug(String input) {
        if (input == null) return "";
        String nowhitespace = WHITESPACE.matcher(input).replaceAll("-");
        String normalized = Normalizer.normalize(nowhitespace, Normalizer.Form.NFD);
        String slug = NONLATIN.matcher(normalized).replaceAll("");
        slug = slug.toLowerCase(Locale.ENGLISH);

        // Ensure slug is unique
        int counter = 1;
        String uniqueSlug = slug;
        while (blogRepository.findBySlug(uniqueSlug).isPresent()) {
            counter++;
            uniqueSlug = slug + "-" + counter;
        }
        return uniqueSlug;
    }
    
    // Helper method to check if a user is a manager
    private boolean isManager(User user) {
        // Assuming role_id = 1 is for manager role
        return user.getRoleId() != null && user.getRoleId() == 1;
    }
    
    // Helper method to convert Blog entity to BlogDto
    private BlogDto convertToDto(Blog blog) {
        BlogDto dto = new BlogDto();
        dto.setId(blog.getId());
        dto.setSlug(blog.getSlug());
        dto.setTitle(blog.getTitle());
        dto.setDescription(blog.getDescription());
        dto.setImageUrl(blog.getImageUrl());
        dto.setVideoUrl(blog.getVideoUrl());
        dto.setPublishedDate(blog.getPublishedDate());
        dto.setLastEditedDate(blog.getLastEditedDate());
        
        // Set author information
        dto.setAuthorId(blog.getAuthor().getId());
        dto.setAuthorName(blog.getAuthor().getFullName());
        
        // Set last editor information if available
        if (blog.getLastEditedBy() != null) {
            dto.setLastEditedById(blog.getLastEditedBy().getId());
            dto.setLastEditedByName(blog.getLastEditedBy().getFullName());
        }
        
        dto.setIsPublished(blog.getIsPublished());
        dto.setStatus(blog.getStatus());
        dto.setTags(blog.getTags());
        dto.setThumbnailUrl(blog.getThumbnailUrl());
        dto.setViewCount(blog.getViewCount());
        
        return dto;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/ClassroomSecurityServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;

import lombok.RequiredArgsConstructor;

@Service("classroomSecurityService")
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ClassroomSecurityServiceImpl implements ClassroomSecurityService {

    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final ClassroomEnrollmentRepository enrollmentRepository;

    @Override
    public boolean isMember(Long classroomId) {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        User user = userRepository.findByEmail(username).orElse(null);
        if (user == null) {
            return false;
        }

        Classroom classroom = classroomRepository.findById(classroomId).orElse(null);
        if (classroom == null) {
            return false;
        }

        return classroom.getStudents().contains(user) || classroom.getTeacher().equals(user);
    }

    @Override
    public boolean isTeacher(Long classroomId) {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        User user = userRepository.findByEmail(username).orElse(null);
        if (user == null) {
            return false;
        }
        Classroom classroom = classroomRepository.findById(classroomId).orElse(null);
        if (classroom == null) {
            return false;
        }
        return classroom.getTeacher().equals(user);
    }

    @Override
    public boolean isMember(Long classroomId, Object principal) {
        if (!(principal instanceof UserDetails)) {
            return false;
        }
        UserDetails userDetails = (UserDetails) principal;
        User user = userRepository.findByEmail(userDetails.getUsername()).orElse(null);
        if (user == null) {
            return false;
        }

        // Check if the user is the teacher of the class
        boolean isTeacher = classroomRepository.findById(classroomId)
                .map(c -> c.getTeacher() != null && c.getTeacher().getId().equals(user.getId()))
                .orElse(false);

        if (isTeacher) {
            return true;
        }

        // Check if the user is an enrolled student
        ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId(classroomId, user.getId());
        return enrollmentRepository.existsById(enrollmentId);
    }

    @Override
    public boolean isTeacherOfClassroom(Object principal, Long classroomId) {
        if (!(principal instanceof UserDetails)) {
            return false;
        }
        UserDetails userDetails = (UserDetails) principal;
        User user = userRepository.findByEmail(userDetails.getUsername()).orElse(null);
        if (user == null) {
            return false;
        }
        return isTeacherOfClassroom(user, classroomId);
    }

    @Override
    public boolean isTeacherOfClassroom(User user, Long classroomId) {
        if (user == null) {
            return false;
        }
        return classroomRepository.findById(classroomId)
                .map(classroom -> classroom.getTeacher() != null && classroom.getTeacher().getId().equals(user.getId()))
                .orElse(false);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/ClassroomServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CreateClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.UpdateClassroomDto;
import com.classroomapp.classroombackend.dto.usermanagement.UserDetailsDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.StudentProgress;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollment;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.StudentProgressRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.security.CustomUserDetails;
import com.classroomapp.classroombackend.service.ClassroomService;

import jakarta.persistence.EntityNotFoundException;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ClassroomServiceImpl implements ClassroomService {

    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final ClassroomEnrollmentRepository classroomEnrollmentRepository;
    private final StudentProgressRepository studentProgressRepository;
    private final ModelMapper modelMapper;

    @Override
    public List<ClassroomDto> getAllClassrooms() {
        return classroomRepository.findAll().stream()
                .map(classroom -> modelMapper.map(classroom, ClassroomDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public ClassroomDto getClassroomById(Long id) {
        Classroom classroom = classroomRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Classroom not found with id: " + id));
        return modelMapper.map(classroom, ClassroomDto.class);
    }

    @Override
    public ClassroomDto GetClassroomById(Long id) {
        return getClassroomById(id);
    }

    @Override
    public ClassroomDetailsDto createClassroom(CreateClassroomDto dto) {
        User teacher = userRepository.findById(dto.getTeacherId())
                .orElseThrow(() -> new EntityNotFoundException("Teacher not found with id: " + dto.getTeacherId()));
        Classroom classroom = new Classroom();
        classroom.setName(dto.getName());
        classroom.setDescription(dto.getDescription());
        classroom.setTeacher(teacher);
        classroom.setCourseId(dto.getCourseId());
        Classroom savedClassroom = classroomRepository.save(classroom);
        return modelMapper.map(savedClassroom, ClassroomDetailsDto.class);
    }

    @Override
    @Transactional
    public ClassroomDto UpdateClassroom(Long id, UpdateClassroomDto updateClassroomDto, UserDetails userDetails) {
        // 1. Tìm classroom
        Classroom classroom = classroomRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Classroom not found with id: " + id));

        if (!(userDetails instanceof CustomUserDetails)) {
            throw new InsufficientAuthenticationException("User details not of expected type");
        }
        CustomUserDetails customUserDetails = (CustomUserDetails) userDetails;
        User currentUser = customUserDetails.getUser();
            
        boolean isAdminOrManager = customUserDetails.getAuthorities().stream()
            .anyMatch(role -> role.getAuthority().equals("ROLE_ADMIN") || role.getAuthority().equals("ROLE_MANAGER"));
        
        // Người dùng phải là Admin, Manager, hoặc là giáo viên của chính lớp đó
        if (!isAdminOrManager && (classroom.getTeacher() == null || !classroom.getTeacher().getId().equals(currentUser.getId()))) {
            throw new BusinessLogicException("You are not authorized to update this classroom.");
        }
    
        // 3. Cập nhật các trường được phép
        classroom.setName(updateClassroomDto.getName());
        classroom.setDescription(updateClassroomDto.getDescription());
    
        Classroom savedClassroom = classroomRepository.save(classroom);
        
        return convertToDto(savedClassroom);
    }
    
    @Override
    public void DeleteClassroom(Long id) {
        classroomRepository.deleteById(id);
    }

    @Override
    public List<ClassroomDto> GetClassroomsByTeacher(Long teacherId) {
        // Try fast path: query by teacher ID directly (avoids User lookup)
        List<Classroom> classrooms = classroomRepository.findByTeacherId(teacherId);

        if (classrooms.isEmpty()) {
            // Fallback: look up User entity; might not exist if ID mismatch
            User teacher = userRepository.findById(teacherId).orElse(null);
            if (teacher != null) {
                classrooms = classroomRepository.findByTeacher(teacher);
            }
        }

        // Map to DTOs – could be empty list if still nothing found
        return classrooms.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public List<ClassroomDto> GetClassroomsByStudent(Long studentId) {
         return classroomEnrollmentRepository.findById_UserId(studentId).stream()
                .map(ClassroomEnrollment::getClassroom)
                .map(classroom -> {
                    ClassroomDto dto = modelMapper.map(classroom, ClassroomDto.class);
                    // Calculate progress percentage for this student in this classroom
                    dto.setProgressPercentage(calculateStudentProgress(studentId, classroom.getId()));
                    // Ensure teacher name is set
                    if (classroom.getTeacher() != null) {
                        dto.setTeacherName(classroom.getTeacher().getFullName());
                    }
                    return dto;
                })
                .collect(Collectors.toList());
    }

    @Override
    public void EnrollStudent(Long classroomId, Long studentId) {
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new EntityNotFoundException("Classroom not found with id: " + classroomId));
        
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new EntityNotFoundException("Student not found with id: " + studentId));
        
        // Check if student is already enrolled
        ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId(classroomId, studentId);
        boolean alreadyEnrolled = classroomEnrollmentRepository.existsById(enrollmentId);
        if (alreadyEnrolled) {
            log.info("Student {} is already enrolled in classroom {}", studentId, classroomId);
            return;
        }
        
        // Create enrollment
        ClassroomEnrollment enrollment = new ClassroomEnrollment();
        enrollment.setId(enrollmentId);
        enrollment.setClassroom(classroom);
        enrollment.setUser(student);
        classroomEnrollmentRepository.save(enrollment);
        log.info("Student {} successfully enrolled in classroom {}", studentId, classroomId);
    }

    @Override
    public void UnenrollStudent(Long classroomId, Long studentId) {
        // Create the composite ID
        ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId(classroomId, studentId);
        
        // Check if enrollment exists
        if (!classroomEnrollmentRepository.existsById(enrollmentId)) {
            log.warn("Student {} is not enrolled in classroom {}", studentId, classroomId);
            return;
        }
        
        // Delete the enrollment
        classroomEnrollmentRepository.deleteById(enrollmentId);
        log.info("Student {} successfully unenrolled from classroom {}", studentId, classroomId);
    }

    @Override
    public List<ClassroomDto> SearchClassroomsByName(String name) {
        return classroomRepository.findByNameContainingIgnoreCase(name).stream()
                .map(classroom -> modelMapper.map(classroom, ClassroomDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<ClassroomDto> GetClassroomsBySubject(String subject) {
        // Implementation needed
        return new ArrayList<>();
    }

    @Override
    public CourseDetailsDto GetCourseDetails(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new EntityNotFoundException("Classroom not found with id: " + classroomId));
        return modelMapper.map(classroom, CourseDetailsDto.class);
    }

    @Override
    public List<User> getStudentsInClassroom(Long classroomId) {
        return classroomEnrollmentRepository.findById_ClassroomId(classroomId).stream()
            .map(ClassroomEnrollment::getUser)
            .collect(Collectors.toList());
    }

    @Override
    public List<ClassroomDto> GetClassroomsByCurrentTeacher() {
        try {
            log.info("GetClassroomsByCurrentTeacher: Getting classrooms for current teacher");
            Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            String username;
            if (principal instanceof UserDetails) {
                username = ((UserDetails)principal).getUsername();
                log.info("GetClassroomsByCurrentTeacher: Found username from UserDetails: {}", username);
            } else {
                username = principal.toString();
                log.info("GetClassroomsByCurrentTeacher: Found username from toString: {}", username);
            }
            
            // Try to find user by username first, then by email
            User teacher = userRepository.findByUsername(username)
                    .orElseGet(() -> userRepository.findByEmail(username)
                    .orElse(null));
                    
            if (teacher == null) {
                log.warn("GetClassroomsByCurrentTeacher: Teacher not found with username/email: {}", username);
                return new ArrayList<>();
            }
            
            log.info("GetClassroomsByCurrentTeacher: Found teacher: {} (ID: {})", teacher.getFullName(), teacher.getId());
            
            List<ClassroomDto> classrooms = classroomRepository.findByTeacher(teacher).stream()
                .map(classroom -> modelMapper.map(classroom, ClassroomDto.class))
                .collect(Collectors.toList());
                
            log.info("GetClassroomsByCurrentTeacher: Found {} classrooms for teacher", classrooms.size());
            
            return classrooms;
        } catch (Exception e) {
            log.error("GetClassroomsByCurrentTeacher: Error getting classrooms for current teacher", e);
            return new ArrayList<>();
        }
    }

    @Override
    public List<ClassroomDto> getClassroomsByCurrentStudent() {
        log.info("getClassroomsByCurrentStudent: Getting classrooms for current student");
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !(authentication.getPrincipal() instanceof CustomUserDetails)) {
            throw new InsufficientAuthenticationException("User is not properly authenticated");
        }
        
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        Long studentId = userDetails.getId();
        log.info("getClassroomsByCurrentStudent: authenticated user id: {}", studentId);

        return GetClassroomsByStudent(studentId);
    }

    @Override
    public ClassroomDetailsDto findClassroomDetailsById(Long classroomId) {
        Classroom classroom = classroomRepository.findDetailsById(classroomId)
                .orElseThrow(() -> new ResourceNotFoundException("Classroom not found with id: " + classroomId));
        return convertToClassroomDetailsDto(classroom);
    }

    private ClassroomDetailsDto convertToClassroomDetailsDto(Classroom classroom) {
        ClassroomDetailsDto detailsDto = new ClassroomDetailsDto();
        detailsDto.setId(classroom.getId());
        detailsDto.setName(classroom.getName());
        detailsDto.setDescription(classroom.getDescription());

        if (classroom.getTeacher() != null) {
            detailsDto.setTeacher(modelMapper.map(classroom.getTeacher(), UserDetailsDto.class));
        }

        if (classroom.getLectures() != null) {
            List<LectureDto> lectureDtos = classroom.getLectures().stream()
                    .map(lecture -> modelMapper.map(lecture, LectureDto.class))
                    .collect(Collectors.toList());
            detailsDto.setLectures(lectureDtos);
        }

        // Assuming CourseDetailsDto can be mapped from Classroom
        detailsDto.setCourse(modelMapper.map(classroom, CourseDetailsDto.class));

        return detailsDto;
    }
    
    private ClassroomDto convertToDto(Classroom classroom) {
        ClassroomDto dto = new ClassroomDto();
        dto.setId(classroom.getId());
        dto.setName(classroom.getName());
        dto.setDescription(classroom.getDescription());
        dto.setSubject(classroom.getSubject());
        dto.setSection(classroom.getSection());
        if (classroom.getTeacher() != null) {
            dto.setTeacherName(classroom.getTeacher().getFullName());
        }
        // We explicitly avoid mapping the syllabus here to prevent circular dependency issues
        // If syllabus summary is needed, it should be a separate lightweight DTO.
        return dto;
    }
    
    /**
     * Calculate student progress percentage for a specific classroom
     * @param studentId The student ID
     * @param classroomId The classroom ID
     * @return Progress percentage as Double (0.0 to 100.0)
     */
    private Double calculateStudentProgress(Long studentId, Long classroomId) {
        try {
            // First, try to find overall progress record
            java.util.Optional<StudentProgress> overallProgress = studentProgressRepository
                .findOverallProgress(studentId, classroomId);
            
            if (overallProgress.isPresent()) {
                return overallProgress.get().getProgressPercentage().doubleValue();
            }
            
            // If no overall progress, calculate based on assignment completion
            List<StudentProgress> assignmentProgress = studentProgressRepository
                .findByStudentIdAndClassroomIdAndProgressType(studentId, classroomId,
                    StudentProgress.ProgressType.ASSIGNMENT);
            
            if (!assignmentProgress.isEmpty()) {
                // Calculate average progress from assignments
                double averageProgress = assignmentProgress.stream()
                    .mapToDouble(progress -> progress.getProgressPercentage().doubleValue())
                    .average()
                    .orElse(0.0);
                return averageProgress;
            }
            
            // If no progress records exist, return 0%
            return 0.0;
            
        } catch (Exception e) {
            log.warn("Error calculating progress for student {} in classroom {}: {}", 
                studentId, classroomId, e.getMessage());
            return 0.0;
        }
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/CourseFeedbackServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.CourseFeedbackDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.exception.UnauthorizedException;
import com.classroomapp.classroombackend.model.CourseFeedback;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.classroommanagement.ClassroomEnrollmentId;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.CourseFeedbackRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomEnrollmentRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.CourseFeedbackService;

@Service
@Transactional
public class CourseFeedbackServiceImpl implements CourseFeedbackService {
    
    @Autowired
    private CourseFeedbackRepository feedbackRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ClassroomRepository classroomRepository;

    @Autowired
    private ClassroomEnrollmentRepository classroomEnrollmentRepository;
    
    @Override
    public CourseFeedbackDto createFeedback(CourseFeedbackDto feedbackDto) {
        String studentEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        User student = userRepository.findByEmail(studentEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Student not found with email: " + studentEmail));

        Classroom classroom = classroomRepository.findById(feedbackDto.getClassroomId())
                .orElseThrow(() -> new ResourceNotFoundException("Classroom not found"));

        // Security Check: Ensure the logged-in student is actually enrolled in the classroom.
        ClassroomEnrollmentId enrollmentId = new ClassroomEnrollmentId(classroom.getId(), student.getId());
        if (!classroomEnrollmentRepository.existsById(enrollmentId)) {
            throw new UnauthorizedException("Student is not enrolled in this classroom.");
        }
        
        // Check if student already gave feedback for this classroom
        if (feedbackRepository.existsByStudentAndClassroom(student, classroom)) {
            throw new RuntimeException("Student has already given feedback for this classroom");
        }
        
        CourseFeedback feedback = new CourseFeedback();
        feedback.setStudent(student);
        feedback.setClassroom(classroom);
        feedback.setTeacher(classroom.getTeacher()); // Get teacher from classroom directly
        feedback.setTitle(feedbackDto.getTitle());
        feedback.setContent(feedbackDto.getContent());
        feedback.setOverallRating(feedbackDto.getOverallRating());
        feedback.setTeachingQualityRating(feedbackDto.getTeachingQualityRating());
        feedback.setCourseMaterialRating(feedbackDto.getCourseMaterialRating());
        feedback.setSupportRating(feedbackDto.getSupportRating());
        feedback.setCategory(feedbackDto.getCategory() != null ? feedbackDto.getCategory() : "GENERAL");
        feedback.setIsAnonymous(feedbackDto.getIsAnonymous() != null ? feedbackDto.getIsAnonymous() : false);
        feedback.setStatus("SUBMITTED");
        
        CourseFeedback savedFeedback = feedbackRepository.save(feedback);
        return convertToDto(savedFeedback);
    }
    
    @Override
    @Transactional(readOnly = true)
    public CourseFeedbackDto getFeedbackById(Long feedbackId) {
        CourseFeedback feedback = feedbackRepository.findById(feedbackId)
                .orElseThrow(() -> new RuntimeException("Feedback not found"));
        return convertToDto(feedback);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByStudent(Long studentId) {
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        List<CourseFeedback> feedbacks = feedbackRepository.findByStudentOrderByCreatedAtDesc(student);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByClassroom(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new RuntimeException("Classroom not found"));
        List<CourseFeedback> feedbacks = feedbackRepository.findByClassroomOrderByCreatedAtDesc(classroom);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByTeacher(Long teacherId) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        List<CourseFeedback> feedbacks = feedbackRepository.findByTeacherOrderByCreatedAtDesc(teacher);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByStatus(String status) {
        List<CourseFeedback> feedbacks = feedbackRepository.findByStatusOrderByCreatedAtDesc(status);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByCategory(String category) {
        List<CourseFeedback> feedbacks = feedbackRepository.findByCategoryOrderByCreatedAtDesc(category);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getFeedbackByRatingRange(Integer minRating, Integer maxRating) {
        List<CourseFeedback> feedbacks = feedbackRepository.findByOverallRatingBetweenOrderByCreatedAtDesc(minRating, maxRating);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> searchFeedback(String keyword) {
        List<CourseFeedback> feedbacks = feedbackRepository.searchFeedback(keyword);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getRecentFeedback(Integer days) {
        LocalDateTime fromDate = LocalDateTime.now().minusDays(days != null ? days : 30);
        List<CourseFeedback> feedbacks = feedbackRepository.findRecentFeedback(fromDate);
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getAnonymousFeedback() {
        List<CourseFeedback> feedbacks = feedbackRepository.findByIsAnonymousTrueOrderByCreatedAtDesc();
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    public CourseFeedbackDto reviewFeedback(Long feedbackId, String response, Long reviewerId) {
        CourseFeedback feedback = feedbackRepository.findById(feedbackId)
                .orElseThrow(() -> new RuntimeException("Feedback not found"));
        User reviewer = userRepository.findById(reviewerId)
                .orElseThrow(() -> new RuntimeException("Reviewer not found"));
        
        feedback.markAsReviewed(reviewer, response);
        CourseFeedback savedFeedback = feedbackRepository.save(feedback);
        return convertToDto(savedFeedback);
    }
    
    @Override
    public CourseFeedbackDto acknowledgeFeedback(Long feedbackId) {
        CourseFeedback feedback = feedbackRepository.findById(feedbackId)
                .orElseThrow(() -> new RuntimeException("Feedback not found"));
        feedback.acknowledge();
        CourseFeedback savedFeedback = feedbackRepository.save(feedback);
        return convertToDto(savedFeedback);
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean hasStudentGivenFeedback(Long studentId, Long classroomId) {
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new RuntimeException("Classroom not found"));
        return feedbackRepository.existsByStudentAndClassroom(student, classroom);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Double getAverageRatingByClassroom(Long classroomId) {
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new RuntimeException("Classroom not found"));
        return feedbackRepository.getAverageRatingByClassroom(classroom);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Double getAverageTeachingQualityByTeacher(Long teacherId) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        return feedbackRepository.getAverageTeachingQualityByTeacher(teacher);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Long countFeedbackByTeacherAndStatus(Long teacherId, String status) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        return feedbackRepository.countFeedbackByTeacherAndStatus(teacher, status);
    }
    
    @Override
    public void deleteFeedback(Long feedbackId) {
        if (!feedbackRepository.existsById(feedbackId)) {
            throw new RuntimeException("Feedback not found");
        }
        feedbackRepository.deleteById(feedbackId);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<CourseFeedbackDto> getAllFeedback() {
        List<CourseFeedback> feedbacks = feedbackRepository.findAll();
        return feedbacks.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    private CourseFeedbackDto convertToDto(CourseFeedback feedback) {
        CourseFeedbackDto dto = new CourseFeedbackDto();
        dto.setId(feedback.getId());
        dto.setStudentId(feedback.getStudent().getId());
        dto.setStudentName(feedback.getIsAnonymous() ? "Anonymous" : feedback.getStudent().getFullName());
        dto.setClassroomId(feedback.getClassroom().getId());
        dto.setClassroomName(feedback.getClassroom().getName());
        dto.setTeacherId(feedback.getTeacher().getId());
        dto.setTeacherName(feedback.getTeacher().getFullName());
        dto.setTitle(feedback.getTitle());
        dto.setContent(feedback.getContent());
        dto.setOverallRating(feedback.getOverallRating());
        dto.setTeachingQualityRating(feedback.getTeachingQualityRating());
        dto.setCourseMaterialRating(feedback.getCourseMaterialRating());
        dto.setSupportRating(feedback.getSupportRating());
        dto.setCategory(feedback.getCategory());
        dto.setStatus(feedback.getStatus());
        dto.setIsAnonymous(feedback.getIsAnonymous());
        dto.setReviewedAt(feedback.getReviewedAt());
        if (feedback.getReviewedBy() != null) {
            dto.setReviewedById(feedback.getReviewedBy().getId());
            dto.setReviewedByName(feedback.getReviewedBy().getFullName());
        }
        dto.setResponse(feedback.getResponse());
        dto.setCreatedAt(feedback.getCreatedAt());
        dto.setUpdatedAt(feedback.getUpdatedAt());
        return dto;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/CourseMaterialServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.CourseMaterialDto;
import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.UploadMaterialDto;
import com.classroomapp.classroombackend.model.CourseMaterial;
import com.classroomapp.classroombackend.repository.CourseMaterialRepository;
import com.classroomapp.classroombackend.service.CourseMaterialService;
import com.classroomapp.classroombackend.service.FileStorageService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class CourseMaterialServiceImpl implements CourseMaterialService {

    private final CourseMaterialRepository courseMaterialRepository;
    private final FileStorageService fileStorageService;

    @Override
    public CourseMaterialDto uploadMaterial(UploadMaterialDto uploadDto, MultipartFile file, Long uploadedBy) {
        try {
            // Store file using FileStorageService
            FileUploadResponse fileUploadResponse = fileStorageService.save(file);

            CourseMaterial material = new CourseMaterial();
            material.setTitle(uploadDto.getTitle());
            material.setDescription(uploadDto.getDescription());
            material.setFilePath(fileUploadResponse.getFileUrl());
            material.setFileName(fileUploadResponse.getFileName());
            material.setFileSize(file.getSize());
            material.setFileType(file.getContentType());
            material.setClassroomId(uploadDto.getClassroomId());
            material.setUploadedBy(uploadedBy);
            material.setIsPublic(uploadDto.getIsPublic() != null ? uploadDto.getIsPublic() : true);
            material.setUploadDate(LocalDateTime.now());

            CourseMaterial savedMaterial = courseMaterialRepository.save(material);
            return convertToDto(savedMaterial);
        } catch (Exception e) {
            log.error("Error uploading material: {}", e.getMessage());
            throw new RuntimeException("Failed to upload material", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<CourseMaterialDto> getMaterialsByClassroom(Long classroomId) {
        return courseMaterialRepository.findByClassroomIdOrderByUploadDateDesc(classroomId)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CourseMaterialDto> getPublicMaterialsByClassroom(Long classroomId) {
        return courseMaterialRepository.findByClassroomIdAndIsPublicTrueOrderByUploadDateDesc(classroomId)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public CourseMaterialDto getMaterialById(Long materialId) {
        CourseMaterial material = courseMaterialRepository.findById(materialId)
                .orElseThrow(() -> new RuntimeException("Material not found with id: " + materialId));
        return convertToDto(material);
    }

    @Override
    public CourseMaterialDto updateMaterial(Long materialId, UploadMaterialDto updateDto) {
        CourseMaterial material = courseMaterialRepository.findById(materialId)
                .orElseThrow(() -> new RuntimeException("Material not found with id: " + materialId));

        material.setTitle(updateDto.getTitle());
        material.setDescription(updateDto.getDescription());
        if (updateDto.getIsPublic() != null) {
            material.setIsPublic(updateDto.getIsPublic());
        }

        CourseMaterial updatedMaterial = courseMaterialRepository.save(material);
        return convertToDto(updatedMaterial);
    }

    @Override
    public void deleteMaterial(Long materialId) {
        CourseMaterial material = courseMaterialRepository.findById(materialId)
                .orElseThrow(() -> new RuntimeException("Material not found with id: " + materialId));

        try {
            // Delete physical file
            if (material.getFilePath() != null) {
                // We only have the URL, the file name is what the service uses to delete
                fileStorageService.delete(material.getFileName());
            }

            courseMaterialRepository.delete(material);
            log.info("Material deleted successfully: {}", materialId);
        } catch (Exception e) {
            log.error("Error deleting material file: {}", e.getMessage());
            throw new RuntimeException("Failed to delete material file", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public byte[] downloadMaterial(Long materialId) {
        CourseMaterial material = courseMaterialRepository.findById(materialId)
                .orElseThrow(() -> new RuntimeException("Material not found with id: " + materialId));

        try {
            // This method now returns a URL, not raw bytes.
            // A real implementation would fetch the bytes from the URL.
            // For now, we adapt to the new service structure, acknowledging this might need more work.
            log.warn("Downloading from URL is not implemented. Returning empty byte array for materialId: {}", materialId);
            // Increment download count
            material.setDownloadCount(material.getDownloadCount() + 1);
            courseMaterialRepository.save(material);

            // Read and return file content
            // Path filePath = Paths.get(material.getFilePath());
            // return Files.readAllBytes(filePath);
            return new byte[0]; // Placeholder
        } catch (Exception e) {
            log.error("Error downloading material: {}", e.getMessage());
            throw new RuntimeException("Failed to download material", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<CourseMaterialDto> searchMaterials(Long classroomId, String searchTerm) {
        return courseMaterialRepository.searchMaterials(classroomId, searchTerm)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CourseMaterialDto> getMaterialsByFileType(Long classroomId, String fileType) {
        return courseMaterialRepository.findByClassroomIdAndFileTypeContainingIgnoreCaseOrderByUploadDateDesc(classroomId, fileType)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CourseMaterialDto> getMaterialsByUploader(Long uploadedBy) {
        return courseMaterialRepository.findByUploadedByOrderByUploadDateDesc(uploadedBy)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Long getTotalDownloadsByClassroom(Long classroomId) {
        Long totalDownloads = courseMaterialRepository.getTotalDownloadsByClassroom(classroomId);
        return totalDownloads != null ? totalDownloads : 0L;
    }

    private CourseMaterialDto convertToDto(CourseMaterial material) {
        CourseMaterialDto dto = new CourseMaterialDto();
        BeanUtils.copyProperties(material, dto);
        return dto;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/CourseServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;
import com.classroomapp.classroombackend.repository.classroommanagement.CourseRepository;
import com.classroomapp.classroombackend.service.CourseService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CourseServiceImpl implements CourseService {

    private final CourseRepository courseRepository;

    @Override
    public List<CourseDetailsDto> getAllCourses() {
        ModelMapper modelMapper = new ModelMapper();
        return courseRepository.findAll().stream()
                .map(course -> modelMapper.map(course, CourseDetailsDto.class))
                .collect(Collectors.toList());
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/DummyFileStorageServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.Objects;
import java.util.UUID;

import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.exception.FileStorageException;
import com.classroomapp.classroombackend.service.FileStorageService;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@Profile("dev") // This service will only be active when the 'dev' profile is active
public class DummyFileStorageServiceImpl implements FileStorageService {

    @Override
    public FileUploadResponse save(MultipartFile file, String folder) {
        // Get original filename
        String originalFilename = StringUtils.cleanPath(Objects.requireNonNull(file.getOriginalFilename()));
        log.info("Received file to upload to folder {}: {}", folder, originalFilename);

        // Basic validation
        if (originalFilename.contains("..")) {
            throw new FileStorageException("Sorry! Filename contains invalid path sequence " + originalFilename);
        }

        // Generate a unique filename
        String uniqueFileName = UUID.randomUUID() + "_" + originalFilename;

        // Construct a dummy URL, incorporating the folder for realism
        String dummyFileUrl = "https://dummy-storage-provider.com/files/" + folder + "/" + uniqueFileName;
        log.info("Simulating file upload. Storing as {} with URL {}", uniqueFileName, dummyFileUrl);

        // Return the response object
        return new FileUploadResponse(
                uniqueFileName,
                dummyFileUrl,
                file.getContentType(),
                file.getSize()
        );
    }

    @Override
    public void delete(String fileName) {
        if (fileName == null || fileName.isBlank()) {
            log.warn("Attempted to delete a file with null or blank name.");
            return;
        }
        log.info("Simulating deletion of file from storage: {}", fileName);
        // In a real implementation, this would contain logic to delete the file from S3, Firebase, etc.
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/EmailService.java">
package com.classroomapp.classroombackend.service.impl;

public interface EmailService {
    /**
     * Send an email notification
     * @param to Recipient email address
     * @param subject Email subject
     * @param body Email body (can be HTML)
     */
    void sendEmail(String to, String subject, String body);
    
    /**
     * Send a notification for a request status change
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param requestedRole The role that was requested
     * @param status The new status (APPROVED/REJECTED)
     * @param reason The reason for rejection (if applicable)
     */
    void sendRequestStatusNotification(String to, String fullName, String requestedRole, String status, String reason);
    
    /**
     * Send account information with credentials
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param role User's role
     * @param username Username for login
     * @param password Temporary password
     */
    void sendAccountInfoEmail(String to, String fullName, String role, String username, String password);
    
    /**
     * Send a form completion confirmation
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param requestedRole The role that was requested
     */
    void sendFormCompletionConfirmation(String to, String fullName, String requestedRole);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/EmailServiceDummyImpl.java">
package com.classroomapp.classroombackend.service.impl;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.service.EmailService;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@ConditionalOnProperty(name = "email.service.enabled", havingValue = "false", matchIfMissing = true)
public class EmailServiceDummyImpl implements EmailService {
    
    @Override
    public void sendEmail(String to, String subject, String body) {
        log.info("DUMMY EMAIL SERVICE: Would send email to {} with subject: {}", to, subject);
        log.debug("Email body: {}", body);
    }
    
    @Override
    public void sendRequestStatusNotification(String to, String fullName, String requestedRole, String status, String reason) {
        log.info("DUMMY EMAIL SERVICE: Would send request status notification to {} ({}) - Role: {}, Status: {}", 
                to, fullName, requestedRole, status);
        if (reason != null) {
            log.info("Reason: {}", reason);
        }
    }
    
    @Override
    public void sendAccountInfoEmail(String to, String fullName, String role, String username, String password) {
        log.info("DUMMY EMAIL SERVICE: Would send account info email to {} ({}) - Username: {}", 
                to, fullName, username);
    }
    
    @Override
    public void sendFormCompletionConfirmation(String to, String fullName, String requestedRole) {
        log.info("DUMMY EMAIL SERVICE: Would send form completion confirmation to {} ({}) - Role: {}", 
                to, fullName, requestedRole);
    }

    @Override
    public void sendApprovalEmail(String to, String fullName, String roleName, String temporaryPassword) {
        log.info("DUMMY EMAIL SERVICE: Would send approval email to {} ({}) - Role: {}, Password: {}",
                to, fullName, roleName, temporaryPassword);
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/EmailServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import jakarta.mail.internet.MimeMessage;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import com.classroomapp.classroombackend.service.EmailService;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@ConditionalOnProperty(name = "email.service.enabled", havingValue = "true", matchIfMissing = false)
public class EmailServiceImpl implements EmailService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Autowired
    private TemplateEngine templateEngine;
    
    @Value("${spring.mail.from.email}")
    private String fromEmail;
    
    @Override
    public void sendEmail(String to, String subject, String text) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(text, true); // true = isHtml
            helper.setFrom(fromEmail);
            mailSender.send(message);
        } catch (Exception e) {
            log.error("Failed to send email to {}: {}", to, e.getMessage(), e);
        }
    }

    @Override
    public void sendRequestStatusNotification(String to, String fullName, String requestedRole, String status, String reason) {
        String subject;
        String body;        
        if ("APPROVED".equals(status)) {
            subject = "Yêu cầu " + requestedRole + " của bạn đã được chấp thuận";
            Context context = new Context();
            context.setVariable("name", fullName);
            context.setVariable("role", requestedRole);
            body = templateEngine.process("email/request-approved", context);
        } else {
            subject = "Yêu cầu " + requestedRole + " của bạn đã bị từ chối";
            Context context = new Context();
            context.setVariable("name", fullName);
            context.setVariable("role", requestedRole);
            context.setVariable("reason", reason);
            body = templateEngine.process("email/request-rejected", context);
        }
        
        sendEmail(to, subject, body);
    }    @Override
    public void sendAccountInfoEmail(String to, String fullName, String role, String username, String password) {
        String subject = "Thông tin tài khoản MVS Classroom của bạn";
        String body = generateAccountInfoEmailBody(fullName, role, username, password);
        sendEmail(to, subject, body);
    }

    @Override
    public void sendFormCompletionConfirmation(String to, String fullName, String requestedRole) {
        String subject = "Đã nhận yêu cầu: Đăng ký vai trò " + requestedRole;
        Context context = new Context();
        context.setVariable("name", fullName);
        context.setVariable("role", requestedRole);
        String body = templateEngine.process("email/request-received", context);
        sendEmail(to, subject, body);
    }

    @Override
    public void sendApprovalEmail(String to, String fullName, String roleName, String temporaryPassword) {
        String subject = "Tài khoản MVS Classroom của bạn đã được phê duyệt";
        // We can reuse the account info email body generation logic
        String body = generateAccountInfoEmailBody(fullName, roleName, to, temporaryPassword);
        sendEmail(to, subject, body);
    }

    private String generateAccountInfoEmailBody(String fullName, String role, String username, String password) {
        StringBuilder bodyBuilder = new StringBuilder();
        bodyBuilder.append("<!DOCTYPE html><html><head><style>");
        bodyBuilder.append("body {font-family: Arial, sans-serif; line-height: 1.6; color: #333;}");
        bodyBuilder.append(".header {background-color: #52c41a; color: white; padding: 20px; text-align: center;}");
        bodyBuilder.append(".credentials {background-color: #f9f9f9; border: 1px solid #ddd; padding: 15px; margin: 15px 0; border-radius: 5px;}");
        bodyBuilder.append("</style></head><body>");
        bodyBuilder.append("<div class='header'><h1>Tài khoản MVS Classroom của bạn</h1></div>");
        bodyBuilder.append("<div style='padding: 20px;'>");
        bodyBuilder.append("<p>Kính gửi ").append(fullName).append(",</p>");
        bodyBuilder.append("<p>Tài khoản của bạn đã được tạo thành công trong hệ thống với vai trò <strong>").append(role).append("</strong>.</p>");
        bodyBuilder.append("<p>Đây là thông tin đăng nhập của bạn:</p>");
        bodyBuilder.append("<div class='credentials'>");
        bodyBuilder.append("<p><strong>Tên đăng nhập:</strong> ").append(username).append("</p>");
        bodyBuilder.append("<p><strong>Mật khẩu tạm thời:</strong> ").append(password).append("</p>");
        bodyBuilder.append("</div>");
        bodyBuilder.append("<p>Vui lòng sử dụng thông tin này để đăng nhập. Vì lý do bảo mật, chúng tôi khuyên bạn nên đổi mật khẩu sau lần đăng nhập đầu tiên.</p>");
        bodyBuilder.append("<p>Nếu bạn có bất kỳ câu hỏi hoặc cần hỗ trợ, vui lòng liên hệ với đội ngũ hỗ trợ của chúng tôi.</p>");
        bodyBuilder.append("<p>Trân trọng,<br>Đội ngũ MVS Classroom</p>");
        bodyBuilder.append("</div><div style='margin-top: 20px; text-align: center; font-size: 12px; color: #666;'>");
        bodyBuilder.append("<p>&copy; MVS Classroom. Đã đăng ký bản quyền.</p></div></body></html>");
        
        return bodyBuilder.toString();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/ExamServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.exammangement.Exam;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.exammangement.ExamRepository;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;
import com.classroomapp.classroombackend.service.ExamService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ExamServiceImpl implements ExamService {

    private final ExamRepository examRepository;
    private final ClassroomRepository classroomRepository;
    private final ClassroomSecurityService classroomSecurityService;
    private final ModelMapper modelMapper;

    @Override
    @Transactional
    public ExamDto createExam(CreateExamDto createExamDto) {
        Classroom classroom = classroomRepository.findById(createExamDto.getClassroomId())
                .orElseThrow(() -> new ResourceNotFoundException("Classroom", "id", createExamDto.getClassroomId()));

        Exam exam = new Exam();
        exam.setTitle(createExamDto.getTitle());
        exam.setClassroom(classroom);
        exam.setStartTime(createExamDto.getStartTime());
        exam.setEndTime(createExamDto.getEndTime());
        exam.setDurationInMinutes(createExamDto.getDurationInMinutes());

        Exam savedExam = examRepository.save(exam);
        return convertToDto(savedExam);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ExamDto> getExamsByClassroomId(Long classroomId) {
        if (!classroomRepository.existsById(classroomId)) {
            throw new ResourceNotFoundException("Classroom", "id", classroomId);
        }
        List<Exam> exams = examRepository.findByClassroomId(classroomId);
        return exams.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public ExamDto getExamById(Long examId) {
        Exam exam = examRepository.findById(examId)
                .orElseThrow(() -> new ResourceNotFoundException("Exam", "id", examId));

        if (!classroomSecurityService.isMember(exam.getClassroom().getId())) {
            throw new AccessDeniedException("You are not a member of this classroom.");
        }

        return convertToDto(exam);
    }

    @Override
    @Transactional
    public ExamDto updateExam(Long examId, CreateExamDto createExamDto) {
        Exam exam = examRepository.findById(examId)
                .orElseThrow(() -> new ResourceNotFoundException("Exam", "id", examId));

        if (!classroomSecurityService.isTeacher(exam.getClassroom().getId())) {
            throw new AccessDeniedException("You are not the teacher of this classroom.");
        }
        
        Classroom classroom = classroomRepository.findById(createExamDto.getClassroomId())
                .orElseThrow(() -> new ResourceNotFoundException("Classroom", "id", createExamDto.getClassroomId()));

        exam.setTitle(createExamDto.getTitle());
        exam.setClassroom(classroom);
        exam.setStartTime(createExamDto.getStartTime());
        exam.setEndTime(createExamDto.getEndTime());
        exam.setDurationInMinutes(createExamDto.getDurationInMinutes());

        Exam updatedExam = examRepository.save(exam);
        return convertToDto(updatedExam);
    }

    @Override
    @Transactional
    public void deleteExam(Long examId) {
        Exam exam = examRepository.findById(examId)
                .orElseThrow(() -> new ResourceNotFoundException("Exam", "id", examId));

        if (!classroomSecurityService.isTeacher(exam.getClassroom().getId())) {
            throw new AccessDeniedException("You are not the teacher of this classroom.");
        }
        
        examRepository.deleteById(examId);
    }

    private ExamDto convertToDto(Exam exam) {
        ExamDto examDto = modelMapper.map(exam, ExamDto.class);
        if (exam.getClassroom() != null) {
            examDto.setClassroomId(exam.getClassroom().getId());
            examDto.setClassroomName(exam.getClassroom().getName());
        }
        return examDto;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/ExamSubmissionServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.GradeExamDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.model.exammangement.Exam;
import com.classroomapp.classroombackend.model.exammangement.ExamSubmission;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.exammangement.ExamRepository;
import com.classroomapp.classroombackend.repository.exammangement.ExamSubmissionRepository;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;
import com.classroomapp.classroombackend.service.ExamSubmissionService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
@Transactional
public class ExamSubmissionServiceImpl implements ExamSubmissionService {

    private final ExamSubmissionRepository examSubmissionRepository;
    private final ExamRepository examRepository;
    private final ClassroomSecurityService classroomSecurityService;
    private final ModelMapper modelMapper;

    @Override
    public ExamSubmissionDto startExam(Long examId) {
        User currentUser = getCurrentUser();
        Exam exam = examRepository.findById(examId)
                .orElseThrow(() -> new BusinessLogicException("Exam not found"));

        if (!classroomSecurityService.isMember(exam.getClassroom().getId(), currentUser)) {
            throw new BusinessLogicException("You are not enrolled in this classroom.");
        }

        if (Instant.now().isBefore(exam.getStartTime()) || Instant.now().isAfter(exam.getEndTime())) {
            throw new BusinessLogicException("Exam is not active");
        }

        examSubmissionRepository.findByExamIdAndStudentId(examId, currentUser.getId()).ifPresent(s -> {
            throw new BusinessLogicException("You have already started this exam");
        });

        ExamSubmission submission = new ExamSubmission(exam, currentUser, Instant.now());
        ExamSubmission savedSubmission = examSubmissionRepository.save(submission);
        return convertToDto(savedSubmission);
    }

    @Override
    public ExamSubmissionDto submitExam(Long submissionId, CreateExamSubmissionDto submissionDto) {
        User currentUser = getCurrentUser();
        ExamSubmission submission = examSubmissionRepository.findById(submissionId)
                .orElseThrow(() -> new BusinessLogicException("Submission not found"));

        if (!submission.getStudent().getId().equals(currentUser.getId())) {
            throw new BusinessLogicException("You are not authorized to submit this exam");
        }

        if (submission.getSubmittedAt() != null) {
            throw new BusinessLogicException("Exam has already been submitted");
        }

        Exam exam = submission.getExam();
        Instant deadline = submission.getStartedAt().plus(exam.getDurationInMinutes(), ChronoUnit.MINUTES);
        if (Instant.now().isAfter(deadline)) {
            throw new BusinessLogicException("Submission time has expired");
        }

        submission.setContent(submissionDto.getContent());
        submission.setSubmittedAt(Instant.now());
        ExamSubmission updatedSubmission = examSubmissionRepository.save(submission);
        return convertToDto(updatedSubmission);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ExamSubmissionDto> getSubmissionsForExam(Long examId) {
        Exam exam = examRepository.findById(examId)
                .orElseThrow(() -> new BusinessLogicException("Exam not found"));
        if (!classroomSecurityService.isTeacher(exam.getClassroom().getId())) {
            throw new BusinessLogicException("You are not authorized to view submissions for this exam.");
        }

        List<ExamSubmission> submissions = examSubmissionRepository.findByExamId(examId);
        return submissions.stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public ExamSubmissionDto getStudentSubmissionForExam(Long examId) {
        User currentUser = getCurrentUser();
        ExamSubmission submission = examSubmissionRepository.findByExamIdAndStudentId(examId, currentUser.getId())
                .orElseThrow(() -> new BusinessLogicException("You have not started this exam"));
        return convertToDto(submission);
    }

    @Override
    public ExamSubmissionDto gradeSubmission(Long submissionId, GradeExamDto gradeDto) {
        User currentUser = getCurrentUser();
        ExamSubmission submission = examSubmissionRepository.findById(submissionId)
                .orElseThrow(() -> new BusinessLogicException("Submission not found"));

        if(!classroomSecurityService.isTeacher(submission.getExam().getClassroom().getId())){
            throw new BusinessLogicException("You are not authorized to grade this submission.");
        }
        
        if (submission.getSubmittedAt() == null) {
            throw new BusinessLogicException("Cannot grade an exam that has not been submitted");
        }

        submission.setScore(gradeDto.getScore());
        submission.setFeedback(gradeDto.getFeedback());
        submission.setGradedAt(Instant.now());
        submission.setGradedBy(currentUser);

        ExamSubmission gradedSubmission = examSubmissionRepository.save(submission);
        return convertToDto(gradedSubmission);
    }

    private User getCurrentUser() {
        return (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    }

    private ExamSubmissionDto convertToDto(ExamSubmission submission) {
        return modelMapper.map(submission, ExamSubmissionDto.class);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/FirebaseStorageServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.io.IOException;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.service.FileStorageService;
import com.google.cloud.storage.Blob;
import com.google.cloud.storage.BlobId;
import com.google.cloud.storage.BlobInfo;
import com.google.cloud.storage.Storage;
import com.google.firebase.cloud.StorageClient;

@Service
@Primary
@Profile("firebase")
public class FirebaseStorageServiceImpl implements FileStorageService {

    private static final Logger logger = LoggerFactory.getLogger(FirebaseStorageServiceImpl.class);

    @Value("${firebase.bucket-name}")
    private String bucketName;

    @Override
    public FileUploadResponse save(MultipartFile file, String folder) {
        try {
            logger.info("Starting file upload to Firebase Storage");
            logger.info("Bucket name: {}", bucketName);
            logger.info("File name: {}, size: {}, content type: {}",
                    file.getOriginalFilename(), file.getSize(), file.getContentType());

            Storage storage = StorageClient.getInstance().bucket().getStorage();

            String fileName = generateUniqueFileName(file.getOriginalFilename());
            String fullPath = folder + "/" + fileName;
            logger.info("Generated path for upload: {}", fullPath);

            BlobId blobId = BlobId.of(bucketName, fullPath);

            BlobInfo blobInfo = BlobInfo.newBuilder(blobId)
                    .setContentType(file.getContentType())
                    .build();
            logger.info("Uploading file to Firebase Storage...");
            Blob blob = storage.create(blobInfo, file.getBytes());

            if (blob == null || !blob.exists()) {
                throw new Exception("Failed to upload file to Firebase Storage - blob creation failed");
            }

            String downloadUrl = String.format("https://storage.googleapis.com/%s/%s", bucketName, fullPath);
            logger.info("Upload successful. Download URL: {}", downloadUrl);
            return new FileUploadResponse(fileName, downloadUrl, file.getContentType(), file.getSize());
        } catch (IOException e) {
            logger.error("Error uploading file to Firebase Storage", e);
            throw new RuntimeException("Failed to upload file to Firebase Storage: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Error during file upload", e);
            throw new RuntimeException("A general error occurred during file upload.", e);
        }
    }
    
    @Override
    public void delete(String fileName) {
        // This is a simplified delete, assuming a default folder if none is provided.
        // A better implementation might require the full path or a more robust lookup.
        this.delete(fileName, "uploads");
    }

    public void delete(String fileName, String folder) {
        try {
            String fullPath = folder + "/" + fileName;
            Storage storage = StorageClient.getInstance().bucket().getStorage();
            BlobId blobId = BlobId.of(bucketName, fullPath);

            boolean deleted = storage.delete(blobId);
            if (!deleted) {
                logger.warn("File not found or already deleted: {}", fullPath);
            } else {
                logger.info("Successfully deleted file: {}", fullPath);
            }
        } catch (Exception e) {
            logger.error("Error deleting file from Firebase Storage", e);
        }
    }
    
    /**
     * Generate a unique filename to prevent duplicates
     */
    private String generateUniqueFileName(String originalFilename) {
        String extension = "";
        if (originalFilename != null && originalFilename.contains(".")) {
            extension = originalFilename.substring(originalFilename.lastIndexOf("."));
        }
        String uniqueName = UUID.randomUUID().toString() + extension;
        logger.info("Generated unique filename: {}", uniqueName);
        return uniqueName;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/LectureMaterialServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.LectureMaterialDto;
import com.classroomapp.classroombackend.exception.FileStorageException;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.exception.UnauthorizedException;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.LectureMaterial;
import com.classroomapp.classroombackend.repository.LectureMaterialRepository;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.service.LectureMaterialService;

import jakarta.annotation.PostConstruct;

@Service
public class LectureMaterialServiceImpl implements LectureMaterialService {

    private final Path fileStorageLocation;
    private final LectureRepository lectureRepository;
    private final LectureMaterialRepository lectureMaterialRepository;
    private final ModelMapper modelMapper;

    @Autowired
    public LectureMaterialServiceImpl(@Value("${file.upload-dir:uploads/materials}") String uploadDir,
                                      LectureRepository lectureRepository,
                                      LectureMaterialRepository lectureMaterialRepository,
                                      ModelMapper modelMapper) {
        this.fileStorageLocation = Paths.get(uploadDir).toAbsolutePath().normalize();
        this.lectureRepository = lectureRepository;
        this.lectureMaterialRepository = lectureMaterialRepository;
        this.modelMapper = modelMapper;
    }

    @PostConstruct
    public void init() {
        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (Exception ex) {
            throw new FileStorageException("Could not create the directory where the uploaded files will be stored.", ex);
        }
    }
    
    @Override
    public LectureMaterialDto storeFile(MultipartFile file, Long lectureId, String userEmail) {
        Lecture lecture = lectureRepository.findById(lectureId)
            .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        if (!lecture.getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to upload materials to this lecture.");
        }

        String fileName = StringUtils.cleanPath(file.getOriginalFilename());

        try {
            if (fileName.contains("..")) {
                throw new FileStorageException("Sorry! Filename contains invalid path sequence " + fileName);
            }

            Path targetLocation = this.fileStorageLocation.resolve(fileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

            LectureMaterial lectureMaterial = new LectureMaterial();
            lectureMaterial.setLecture(lecture);
            lectureMaterial.setFileName(fileName);
            lectureMaterial.setContentType(file.getContentType());
            lectureMaterial.setFileSize(file.getSize());
            lectureMaterial.setFilePath(targetLocation.toString());
            
            LectureMaterial savedMaterial = lectureMaterialRepository.save(lectureMaterial);
            return modelMapper.map(savedMaterial, LectureMaterialDto.class);

        } catch (IOException ex) {
            throw new FileStorageException("Could not store file " + fileName + ". Please try again!", ex);
        }
    }

    @Override
    public ResponseEntity<Resource> getFile(Long materialId) {
        LectureMaterial material = lectureMaterialRepository.findById(materialId)
                .orElseThrow(() -> new ResourceNotFoundException("File not found with id " + materialId));

        try {
            Path filePath = Paths.get(material.getFilePath()).normalize();
            Resource resource = new UrlResource(filePath.toUri());
            if (resource.exists()) {
                 return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(material.getContentType()))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);
            } else {
                throw new ResourceNotFoundException("File not found " + material.getFileName());
            }
        } catch (MalformedURLException ex) {
            throw new ResourceNotFoundException("File not found " + material.getFileName(), ex);
        }
    }

    @Override
    public List<LectureMaterialDto> getMaterialsByLectureId(Long lectureId) {
        List<LectureMaterial> materials = lectureMaterialRepository.findByLectureId(lectureId);
        return materials.stream()
                .map(material -> modelMapper.map(material, LectureMaterialDto.class))
                .collect(Collectors.toList());
    }
    
    @Override
    public void deleteFile(Long materialId, String userEmail) {
        LectureMaterial material = lectureMaterialRepository.findById(materialId)
            .orElseThrow(() -> new ResourceNotFoundException("Material not found with id: " + materialId));

        if (!material.getLecture().getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to delete this material.");
        }

        try {
            Path filePath = Paths.get(material.getFilePath());
            Files.deleteIfExists(filePath);
            lectureMaterialRepository.delete(material);
        } catch (IOException ex) {
            throw new FileStorageException("Could not delete file " + material.getFileName() + ". Please try again!", ex);
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/LectureServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.security.Principal;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.CreateLectureDto;
import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.LectureDetailsDto;
import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.LectureMaterialDto;
import com.classroomapp.classroombackend.dto.UpdateLectureDto;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.exception.UnauthorizedException;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.LectureMaterial;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.LectureMaterialRepository;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.ClassroomSecurityService;
import com.classroomapp.classroombackend.service.LectureService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class LectureServiceImpl implements LectureService {

    private final LectureRepository lectureRepository;
    private final ClassroomRepository classroomRepository;
    private final ModelMapper modelMapper;
    private final ClassroomSecurityService classroomSecurityService;
    private final LectureMaterialRepository lectureMaterialRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional
    public LectureDto createLecture(Long classroomId, CreateLectureDto createLectureDto, String userEmail) {
        Classroom classroom = classroomRepository.findById(classroomId)
                .orElseThrow(() -> new ResourceNotFoundException("Classroom not found with id: " + classroomId));

        // Authorization Check: Ensure the user is the teacher of the classroom
        if (!classroom.getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to add lectures to this classroom.");
        }

        Lecture lecture = new Lecture();
        lecture.setTitle(createLectureDto.getTitle());
        lecture.setContent(createLectureDto.getContent());
        lecture.setClassroom(classroom);

        Lecture savedLecture = lectureRepository.save(lecture);

        // Handle materials if provided
        if (createLectureDto.getMaterials() != null && !createLectureDto.getMaterials().isEmpty()) {
            for (var materialDto : createLectureDto.getMaterials()) {
                LectureMaterial material = new LectureMaterial();
                material.setFileName(materialDto.getFileName());
                material.setContentType(materialDto.getFileType());
                material.setDownloadUrl(materialDto.getFileUrl());
                material.setFileSize(materialDto.getFileSize());
                material.setLecture(savedLecture);
                
                // Set file path for local files
                if (materialDto.isLocalFile()) {
                    material.setFilePath(materialDto.getFileUrl()); // For local files, URL is the file path
                }
                
                lectureMaterialRepository.save(material);
            }
        }

        return modelMapper.map(savedLecture, LectureDto.class);
    }

    @Override
    public List<LectureDto> getLecturesByClassroomId(Long classroomId) {
        System.out.println("📚 LectureService: Getting lectures for classroomId: " + classroomId);

        if (!classroomRepository.existsById(classroomId)) {
            System.out.println("❌ LectureService: Classroom not found with id: " + classroomId);
            throw new ResourceNotFoundException("Classroom not found with id: " + classroomId);
        }

        System.out.println("✅ LectureService: Classroom exists, fetching lectures...");
        List<Lecture> lectures = lectureRepository.findByClassroomId(classroomId);
        System.out.println("📊 LectureService: Found " + lectures.size() + " lectures");

        List<LectureDto> lectureDtos = lectures.stream()
                .map(lecture -> {
                    LectureDto dto = modelMapper.map(lecture, LectureDto.class);
                    System.out.println("🔄 LectureService: Mapped lecture: " + dto.getTitle());
                    return dto;
                })
                .collect(Collectors.toList());

        System.out.println("✅ LectureService: Returning " + lectureDtos.size() + " lecture DTOs");
        return lectureDtos;
    }

    @Override
    public LectureDetailsDto getLectureById(Long lectureId, Principal principal) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        if (!classroomSecurityService.isMember(lecture.getClassroom().getId(), principal)) {
            throw new AccessDeniedException("User is not a member of the classroom for this lecture.");
        }

        return modelMapper.map(lecture, LectureDetailsDto.class);
    }

    @Override
    public LectureDto updateLecture(Long lectureId, UpdateLectureDto updateLectureDto, String userEmail) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        if (!lecture.getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to update this lecture.");
        }

        lecture.setTitle(updateLectureDto.getTitle());
        lecture.setContent(updateLectureDto.getDescription());

        Lecture updatedLecture = lectureRepository.save(lecture);
        return modelMapper.map(updatedLecture, LectureDto.class);
    }

    @Override
    public void deleteLecture(Long lectureId, String userEmail) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));
        
        if (!lecture.getClassroom().getTeacher().getEmail().equals(userEmail)) {
            throw new UnauthorizedException("User is not authorized to delete this lecture.");
        }

        lectureRepository.delete(lecture);
    }

    @Override
    @Transactional
    public List<LectureMaterialDto> addMaterials(Long lectureId, List<FileUploadResponse> files, String teacherUsername) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        User teacher = userRepository.findByEmail(teacherUsername)
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", teacherUsername));

        if (!classroomSecurityService.isTeacherOfClassroom(teacher, lecture.getClassroom().getId())) {
            throw new AccessDeniedException("User is not the teacher of the class for this lecture.");
        }

        List<LectureMaterial> newMaterials = new ArrayList<>();
        for (FileUploadResponse fileInfo : files) {
            LectureMaterial material = new LectureMaterial();
            material.setFileName(fileInfo.getFileName());
            material.setDownloadUrl(fileInfo.getFileUrl());
            material.setContentType(fileInfo.getFileType());
            material.setFileSize(fileInfo.getSize());
            material.setLecture(lecture);
            newMaterials.add(lectureMaterialRepository.save(material));
        }

        return newMaterials.stream()
                .map(material -> modelMapper.map(material, LectureMaterialDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public LectureDto addMaterialToLecture(Long lectureId, LectureMaterialDto materialDto) {
        Lecture lecture = lectureRepository.findById(lectureId)
                .orElseThrow(() -> new ResourceNotFoundException("Lecture not found with id: " + lectureId));

        LectureMaterial material = modelMapper.map(materialDto, LectureMaterial.class);
        lecture.getLectureMaterials().add(material);
        material.setLecture(lecture);

        Lecture updatedLecture = lectureRepository.save(lecture);
        return modelMapper.map(updatedLecture, LectureDto.class);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/LocalFileStorageServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Objects;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.exception.FileStorageException;
import com.classroomapp.classroombackend.service.FileStorageService;

@Service
@Primary
@Profile("local")
public class LocalFileStorageServiceImpl implements FileStorageService {

    private static final Logger logger = LoggerFactory.getLogger(LocalFileStorageServiceImpl.class);
    
    @Value("${file.upload.dir:uploads}")
    private String uploadDir;
    
    @Value("${server.port:8088}")
    private String serverPort;

    @Override
    public FileUploadResponse save(MultipartFile file, String folder) {
        try {
            // Get original filename
            String originalFilename = StringUtils.cleanPath(Objects.requireNonNull(file.getOriginalFilename()));
            logger.info("Received file to upload to folder {}: {}", folder, originalFilename);

            // Basic validation
            if (originalFilename.contains("..")) {
                throw new FileStorageException("Sorry! Filename contains invalid path sequence " + originalFilename);
            }

            // Generate a unique filename
            String uniqueFileName = UUID.randomUUID() + "_" + originalFilename;

            // Create directory structure
            Path folderPath = Paths.get(uploadDir).resolve(folder);
            Files.createDirectories(folderPath);

            // Save the file
            Path filePath = folderPath.resolve(uniqueFileName);
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);

            // Construct download URL
            String downloadUrl = "http://localhost:" + serverPort + "/api/files/download/" + folder + "/" + uniqueFileName;
            
            logger.info("File saved successfully: {} -> {}", originalFilename, filePath.toString());
            logger.info("Download URL: {}", downloadUrl);

            // Return the response object
            return new FileUploadResponse(
                    uniqueFileName,
                    downloadUrl,
                    file.getContentType(),
                    file.getSize()
            );
        } catch (IOException e) {
            logger.error("Error saving file to local storage", e);
            throw new FileStorageException("Could not save file " + file.getOriginalFilename() + ". Please try again!", e);
        }
    }

    @Override
    public void delete(String fileName) {
        if (fileName == null || fileName.isBlank()) {
            logger.warn("Attempted to delete a file with null or blank name.");
            return;
        }
        
        try {
            // Find and delete the file from any folder (simple implementation)
            Path uploadPath = Paths.get(uploadDir);
            if (Files.exists(uploadPath)) {
                Files.walk(uploadPath)
                    .filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().equals(fileName))
                    .forEach(path -> {
                        try {
                            Files.delete(path);
                            logger.info("Successfully deleted file: {}", path.toString());
                        } catch (IOException e) {
                            logger.error("Error deleting file: {}", path.toString(), e);
                        }
                    });
            }
        } catch (IOException e) {
            logger.error("Error deleting file from local storage: {}", fileName, e);
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/RequestServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.constants.RoleConstants;
import com.classroomapp.classroombackend.dto.RequestDTO;
import com.classroomapp.classroombackend.dto.RequestResponseDTO;
import com.classroomapp.classroombackend.dto.requestmanagement.CreateRequestDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.model.Request;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.requestmanagement.RequestRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.EmailService;
import com.classroomapp.classroombackend.service.RequestService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class RequestServiceImpl implements RequestService {
    private final RequestRepository requestRepository;
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final PasswordEncoder passwordEncoder;

    private static final DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public void createRegistrationRequest(CreateRequestDto dto) {
        if (requestRepository.existsByEmailAndStatusIn(dto.getEmail(), List.of("PENDING", "APPROVED")) || userRepository.existsByEmail(dto.getEmail())) {
            throw new BusinessLogicException("An account with this email already exists or is pending approval.");
        }

        Request newRequest = new Request();
        newRequest.setEmail(dto.getEmail());
        newRequest.setFullName(dto.getFullName());
        newRequest.setPhoneNumber(dto.getPhoneNumber());
        newRequest.setRequestedRole(dto.getRequestedRole());
        newRequest.setFormResponses(dto.getFormResponses());
        newRequest.setStatus("PENDING");
        newRequest.setCreatedAt(LocalDateTime.now());

        requestRepository.save(newRequest);
        // Gửi mail xác nhận đã nhận request
        try {
            emailService.sendFormCompletionConfirmation(
                newRequest.getEmail(),
                newRequest.getFullName(),
                newRequest.getRequestedRole()
            );
        } catch (Exception e) {
            log.error("Failed to send confirmation email", e);
        }
    }

    @Override
    @Transactional(noRollbackFor = BusinessLogicException.class)
    public RequestResponseDTO createRequest(RequestDTO requestDTO) {
        // Check if there's already an active request
        if (hasActiveRequest(requestDTO.getEmail(), requestDTO.getRequestedRole())) {
            throw new BusinessLogicException("Already has an active request for this role");
        }

        Request request = new Request();
        request.setEmail(requestDTO.getEmail());
        request.setFullName(requestDTO.getFullName());
        request.setPhoneNumber(requestDTO.getPhoneNumber());
        request.setRequestedRole(requestDTO.getRequestedRole());
        request.setFormResponses(requestDTO.getFormResponses());
        request.setStatus("PENDING");
        request.setCreatedAt(LocalDateTime.now());

        Request savedRequest = requestRepository.save(request);
        
        // Send confirmation email
        try {
            emailService.sendFormCompletionConfirmation(
                request.getEmail(), 
                request.getFullName(), 
                request.getRequestedRole()
            );
        } catch (Exception e) {
            log.error("Failed to send confirmation email", e);
            // Don't fail the request if email fails
        }

        return convertToDTO(savedRequest);
    }

    @Override
    @Transactional
    public RequestResponseDTO approveRequest(Long requestId) {
        log.info("Starting approval process for request ID: {}", requestId);
        
        Request request = requestRepository.findById(requestId)
                .orElseThrow(() -> new BusinessLogicException("Request not found with ID: " + requestId));
        log.info("Found request: {}", request);

        if (!"PENDING".equals(request.getStatus())) {
            log.warn("Request {} is not in PENDING status. Current status: {}", requestId, request.getStatus());
            throw new BusinessLogicException("Request is not in PENDING status. Current status: " + request.getStatus());
        }

        // Create User from Request info
        User newUser = new User();
        newUser.setEmail(request.getEmail());
        // Note: The User entity appears to use 'fullName' based on other files.
        // If it uses firstName/lastName, this needs adjustment. Assuming fullName for now.
        newUser.setFullName(request.getFullName());
        newUser.setPhoneNumber(request.getPhoneNumber());

        String randomPassword = generateRandomPassword();
        newUser.setPassword(passwordEncoder.encode(randomPassword));
        newUser.setStatus("active");
        
        // Determine roleId from the requested role string
        int roleId = RoleConstants.STUDENT; // Default to STUDENT
        if ("TEACHER".equalsIgnoreCase(request.getRequestedRole())) {
            roleId = RoleConstants.TEACHER;
        }
        newUser.setRoleId(roleId);

        userRepository.save(newUser);
        log.info("Successfully created user for request {}", requestId);

        // Update Request status
        log.info("Setting request {} status to APPROVED", requestId);
        request.setStatus("APPROVED");
        request.setProcessedAt(LocalDateTime.now());

        Request savedRequest = requestRepository.save(request);

        // Send approval notification with temporary password
        try {
            log.info("Sending approval notification for request {}", requestId);
            // Re-fetch role name for the email
            String roleNameForEmail = "STUDENT";
            if (roleId == RoleConstants.TEACHER) {
                roleNameForEmail = "TEACHER";
            }
            emailService.sendApprovalEmail(newUser.getEmail(), newUser.getFullName(), roleNameForEmail, randomPassword);
            log.info("Successfully sent approval notification for request {}", requestId);
        } catch (Exception e) {
            log.error("Failed to send approval email for request {}: {}", requestId, e.getMessage(), e);
        }

        RequestResponseDTO responseDTO = convertToDTO(savedRequest);
        log.info("Returning response DTO: {}", responseDTO);
        return responseDTO;
    }

    @Override
    @Transactional
    public RequestResponseDTO rejectRequest(Long requestId, String reason) {
        Request request = requestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Request not found"));

        if (!"PENDING".equals(request.getStatus())) {
            throw new RuntimeException("Request is not in PENDING status");
        }

        request.setStatus("REJECTED");
        request.setRejectReason(reason);
        request.setProcessedAt(LocalDateTime.now());
        
        // Send rejection notification
        try {
            emailService.sendRequestStatusNotification(
                request.getEmail(),
                request.getFullName(),
                request.getRequestedRole(),
                "REJECTED", 
                reason
            );
        } catch (Exception e) {
            log.error("Failed to send rejection email", e);
            // Don't fail the rejection if email fails
        }

        return convertToDTO(requestRepository.save(request));
    }

    @Override
    public List<RequestResponseDTO> getPendingRequests() {
        return requestRepository.findByStatus("PENDING").stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<RequestResponseDTO> getRequestsByEmail(String email) {
        return requestRepository.findByEmail(email).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public boolean hasActiveRequest(String email, String role) {
        return requestRepository.existsByEmailAndStatusAndRequestedRole(email, "PENDING", role);
    }

    @Override
    public RequestResponseDTO getRequestDetails(Long requestId) {
        Request request = requestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Request not found"));
        return convertToDTO(request);
    }

    @Override
    public List<RequestResponseDTO> getAllRequests() {
        return requestRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Alternative approval method that skips user creation/update
     * This helps isolate if the user service is causing issues
     */
    public RequestResponseDTO approveRequestSkipUserCreation(Long requestId) {
        log.info("Starting simplified approval process for request ID: {} (skipping user creation)", requestId);
        
        Request request = requestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Request not found with ID: " + requestId));
        log.info("Found request: {}", request);

        if (!"PENDING".equals(request.getStatus())) {
            log.warn("Request {} is not in PENDING status. Current status: {}", requestId, request.getStatus());
            throw new RuntimeException("Request is not in PENDING status. Current status: " + request.getStatus());
        }

        log.info("Setting request {} status to APPROVED", requestId);
        request.setStatus("APPROVED");
        request.setProcessedAt(LocalDateTime.now());
        
        // Skip user creation/update
        log.info("SKIPPING user creation/update for testing purposes");
        
        // Send approval notification
        try {
            log.info("Sending approval notification for request {}", requestId);
            emailService.sendRequestStatusNotification(
                request.getEmail(),
                request.getFullName(),
                request.getRequestedRole(),
                "APPROVED", 
                null
            );
            log.info("Successfully sent approval notification for request {}", requestId);
        } catch (Exception e) {
            log.error("Failed to send approval email for request {}: {}", requestId, e.getMessage(), e);
            // Don't fail the approval if email fails
        }

        log.info("Saving approved request to database: {}", request);
        Request savedRequest = requestRepository.save(request);
        log.info("Request successfully saved with ID: {}", savedRequest.getId());
        
        RequestResponseDTO responseDTO = convertToDTO(savedRequest);
        log.info("Returning response DTO: {}", responseDTO);
        return responseDTO;
    }

    private RequestResponseDTO convertToDTO(Request request) {
        RequestResponseDTO dto = new RequestResponseDTO();
        dto.setId(request.getId());
        dto.setEmail(request.getEmail());
        dto.setFullName(request.getFullName());
        dto.setPhoneNumber(request.getPhoneNumber());
        dto.setRequestedRole(request.getRequestedRole());
        dto.setStatus(request.getStatus());
        dto.setRejectReason(request.getRejectReason());
        dto.setCreatedAt(request.getCreatedAt().format(formatter));
        dto.setProcessedAt(request.getProcessedAt() != null ? 
                request.getProcessedAt().format(formatter) : null);
        dto.setFormResponses(request.getFormResponses());
        return dto;
    }

    private String generateRandomPassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        SecureRandom random = new SecureRandom();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            int randomIndex = random.nextInt(chars.length());
            sb.append(chars.charAt(randomIndex));
        }
        return sb.toString();
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/ScheduleServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.ScheduleDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;
import com.classroomapp.classroombackend.model.Lecture;
import com.classroomapp.classroombackend.model.Schedule;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.LectureRepository;
import com.classroomapp.classroombackend.repository.ScheduleRepository;
import com.classroomapp.classroombackend.repository.classroommanagement.ClassroomRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.ScheduleService;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ScheduleServiceImpl implements ScheduleService {
    
    private final ScheduleRepository scheduleRepository;
    private final ClassroomRepository classroomRepository;
    private final UserRepository userRepository;
    private final LectureRepository lectureRepository;

    @Override
    public List<ScheduleDto> getSchedulesByClassroomId(Long classroomId) {
        log.info("Fetching schedules for classroom ID: {}", classroomId);
        
        List<Schedule> schedules = scheduleRepository.findByClassroomId(classroomId);
        log.info("Found {} schedules for classroom ID: {}", schedules.size(), classroomId);
        
        // Thêm logging chi tiết
        for (Schedule schedule : schedules) {
            log.debug("Schedule: day={}, start={}, end={}, room={}, subject={}", 
                getDayOfWeekName(schedule.getDayOfWeek()),
                schedule.getStartTime(),
                schedule.getEndTime(),
                schedule.getRoom(),
                schedule.getSubject());
        }
        
        return schedules.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDto> getSchedulesByTeacherId(Long teacherId) {
        log.info("Fetching schedules for teacher ID: {}", teacherId);
        
        List<Schedule> schedules = scheduleRepository.findByTeacherId(teacherId);
        log.info("Found {} schedules for teacher ID: {}", schedules.size(), teacherId);
        
        return schedules.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDto> getSchedulesByStudentId(Long studentId) {
        log.info("Fetching schedules for student ID: {}", studentId);
        
        // Get the classrooms the student is enrolled in
        List<Long> enrolledClassroomIds = classroomRepository.findClassroomsIdsByStudentId(studentId);
        log.info("Student ID {} is enrolled in {} classrooms", studentId, enrolledClassroomIds.size());
        
        if (enrolledClassroomIds.isEmpty()) {
            log.warn("Student ID {} is not enrolled in any classrooms", studentId);
            return new ArrayList<>();
        }
        
        List<Schedule> schedules = scheduleRepository.findByClassroomIdIn(enrolledClassroomIds);
        log.info("Found {} schedules for student ID: {}", schedules.size(), studentId);
        
        return schedules.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public ScheduleDto createSchedule(ScheduleDto scheduleDto) {
        log.info("Creating new schedule: {}", scheduleDto);
        
        Schedule schedule = convertToEntity(scheduleDto);
        Schedule savedSchedule = scheduleRepository.save(schedule);
        
        log.info("Created schedule with ID: {}", savedSchedule.getId());
        return convertToDto(savedSchedule);
    }

    @Override
    public ScheduleDto updateSchedule(Long id, ScheduleDto scheduleDto) {
        log.info("Updating schedule ID: {}", id);
        
        if (!scheduleRepository.existsById(id)) {
            log.error("Schedule not found with ID: {}", id);
            throw new EntityNotFoundException("Schedule not found with ID: " + id);
        }
        
        Schedule schedule = convertToEntity(scheduleDto);
        schedule.setId(id);
        Schedule updatedSchedule = scheduleRepository.save(schedule);
        
        log.info("Updated schedule with ID: {}", updatedSchedule.getId());
        return convertToDto(updatedSchedule);
    }

    @Override
    public void deleteSchedule(Long id) {
        log.info("Deleting schedule ID: {}", id);
        
        if (!scheduleRepository.existsById(id)) {
            log.error("Schedule not found with ID: {}", id);
            throw new EntityNotFoundException("Schedule not found with ID: " + id);
        }
        
        scheduleRepository.deleteById(id);
        log.info("Deleted schedule with ID: {}", id);
    }

    @Override
    public List<ScheduleDto> getAllSchedules() {
        return scheduleRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public ScheduleDto getScheduleById(Long id) {
        Optional<Schedule> schedule = scheduleRepository.findById(id);
        return schedule.map(this::convertToDto).orElse(null);
    }

    @Override
    public List<ScheduleDto> getSchedulesByTeacherAndDay(Long teacherId, Integer dayOfWeek) {
        List<Schedule> schedules = scheduleRepository.findByTeacherIdAndDayOfWeek(teacherId, dayOfWeek);
        return schedules.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public ScheduleDto createScheduleEntry(ScheduleDto scheduleDto) {
        Schedule schedule = convertFromDto(scheduleDto);
        Schedule savedSchedule = scheduleRepository.save(schedule);
        return convertToDto(savedSchedule);
    }

    @Override
    public List<TimetableEventDto> getTimetableForUser(Long userId, LocalDate startDate, LocalDate endDate) {
        // This method converts Schedule entities to TimetableEventDto for calendar display
        // For now, return empty list - this would need proper implementation based on requirements
        log.info("Getting timetable for user {} from {} to {}", userId, startDate, endDate);
        return new ArrayList<>();
    }

    private ScheduleDto convertToDto(Schedule schedule) {
        ScheduleDto dto = new ScheduleDto();
        dto.setId(schedule.getId());
        dto.setClassroomId(schedule.getClassroom() != null ? schedule.getClassroom().getId() : null);
        dto.setTeacherId(schedule.getTeacher() != null ? schedule.getTeacher().getId() : null);

        // Convert Integer dayOfWeek to DayOfWeek enum for consolidated DTO
        Integer dayOfWeekInt = schedule.getDayOfWeek();
        if (dayOfWeekInt != null) {
            dto.setDay(dayOfWeekInt); // Set legacy integer format
            dto.setDayOfWeek(convertIntegerToDayOfWeek(dayOfWeekInt)); // Set modern enum format
        }

        dto.setDayName(getDayOfWeekName(schedule.getDayOfWeek()));
        dto.setStartTime(schedule.getStartTime());
        dto.setEndTime(schedule.getEndTime());

        // Set both legacy string format and modern LocalTime format
        if (schedule.getStartTime() != null) {
            dto.setStart(schedule.getStartTime().toString().substring(0, 5)); // "HH:MM"
        }
        if (schedule.getEndTime() != null) {
            dto.setEnd(schedule.getEndTime().toString().substring(0, 5)); // "HH:MM"
        }

        dto.setRoom(schedule.getRoom());
        dto.setLocation(schedule.getRoom()); // Map room to location for compatibility
        dto.setSubject(schedule.getSubject());
        dto.setMaterialsUrl(schedule.getMaterialsUrl());
        dto.setMeetUrl(schedule.getMeetUrl());
        
        // Add classroom and teacher details
        if (schedule.getClassroom() != null) {
            dto.setClassroomName(schedule.getClassroom().getName());
        }
        
        if (schedule.getTeacher() != null) {
            dto.setTeacherName(schedule.getTeacher().getFullName());
        }
        
        return dto;
    }

    private Schedule convertToEntity(ScheduleDto dto) {
        Schedule schedule = new Schedule();
        schedule.setId(dto.getId());
        
        // Set classroom if classroomId is provided
        if (dto.getClassroomId() != null) {
            Optional<Classroom> classroom = classroomRepository.findById(dto.getClassroomId());
            classroom.ifPresent(schedule::setClassroom);
        }
        
        // Set teacher if teacherId is provided
        if (dto.getTeacherId() != null) {
            Optional<User> teacher = userRepository.findById(dto.getTeacherId());
            teacher.ifPresent(schedule::setTeacher);
        }
        
        // Convert DayOfWeek enum to Integer for entity
        if (dto.getDayOfWeek() != null) {
            schedule.setDayOfWeek(convertDayOfWeekToInteger(dto.getDayOfWeek()));
        } else if (dto.getDay() != null) {
            schedule.setDayOfWeek(dto.getDay()); // Use legacy integer format
        }

        schedule.setStartTime(dto.getStartTime());
        schedule.setEndTime(dto.getEndTime());
        schedule.setRoom(dto.getRoom());
        schedule.setSubject(dto.getSubject());
        schedule.setMaterialsUrl(dto.getMaterialsUrl());
        schedule.setMeetUrl(dto.getMeetUrl());
        
        return schedule;
    }

    private Schedule convertFromDto(ScheduleDto dto) {
        Schedule schedule = new Schedule();

        if (dto.getId() != null) {
            // For updates, load existing schedule
            Optional<Schedule> existingSchedule = scheduleRepository.findById(dto.getId());
            if (existingSchedule.isPresent()) {
                schedule = existingSchedule.get();
            }
        }

        // Set classroom
        if (dto.getClassroomId() != null) {
            Optional<Classroom> classroom = classroomRepository.findById(dto.getClassroomId());
            classroom.ifPresent(schedule::setClassroom);
        }

        // Set teacher
        if (dto.getTeacherId() != null) {
            Optional<User> teacher = userRepository.findById(dto.getTeacherId());
            teacher.ifPresent(schedule::setTeacher);
        }

        // Convert DayOfWeek enum to Integer for entity
        if (dto.getDayOfWeek() != null) {
            schedule.setDayOfWeek(convertDayOfWeekToInteger(dto.getDayOfWeek()));
        } else if (dto.getDay() != null) {
            schedule.setDayOfWeek(dto.getDay()); // Use legacy integer format
        }

        schedule.setStartTime(dto.getStartTime());
        schedule.setEndTime(dto.getEndTime());
        schedule.setRoom(dto.getRoom() != null ? dto.getRoom() : dto.getLocation());
        schedule.setSubject(dto.getSubject());
        schedule.setMaterialsUrl(dto.getMaterialsUrl());
        schedule.setMeetUrl(dto.getMeetUrl());

        return schedule;
    }

    private String getDayOfWeekName(Integer dayOfWeek) {
        if (dayOfWeek == null) {
            return "Unknown";
        }
        
        // Dayofweek is 0-based (0 = Monday, 6 = Sunday)
        DayOfWeek day;
        if (dayOfWeek >= 0 && dayOfWeek <= 6) {
            day = DayOfWeek.of(dayOfWeek == 0 ? 1 : (dayOfWeek == 6 ? 7 : dayOfWeek + 1));
        } else {
            return "Invalid day (" + dayOfWeek + ")";
        }
        
        return day.getDisplayName(TextStyle.FULL, Locale.forLanguageTag("vi-VN"));
    }

    @Override
    public void createSampleSchedules(Long classroomId) {
        log.info("Creating sample schedules for classroom ID: {}", classroomId);
        
        Optional<Classroom> classroomOpt = classroomRepository.findById(classroomId);
        if (!classroomOpt.isPresent()) {
            log.error("Classroom not found with ID: {}", classroomId);
            throw new EntityNotFoundException("Classroom not found with ID: " + classroomId);
        }
        
        Classroom classroom = classroomOpt.get();
        User teacher = classroom.getTeacher();
        
        if (teacher == null) {
            log.error("Classroom has no assigned teacher. ID: {}", classroomId);
            throw new EntityNotFoundException("Classroom has no assigned teacher");
        }
        
        // Check if schedules already exist for this classroom
        List<Schedule> existingSchedules = scheduleRepository.findByClassroomId(classroomId);
        if (!existingSchedules.isEmpty()) {
            log.info("Schedules already exist for classroom ID: {}. Count: {}", classroomId, existingSchedules.size());
            return;
        }
        
        // Create sample schedules for Monday, Wednesday, and Friday
        createAndSaveSchedule(classroom, teacher, 0, LocalTime.of(8, 0), LocalTime.of(9, 30), 
                "Phòng 101", "Bài giảng lý thuyết");
        
        createAndSaveSchedule(classroom, teacher, 2, LocalTime.of(13, 30), LocalTime.of(15, 0), 
                "Phòng Lab 2", "Bài tập thực hành");
        
        createAndSaveSchedule(classroom, teacher, 4, LocalTime.of(10, 0), LocalTime.of(11, 30), 
                "Phòng 203", "Ôn tập + Kiểm tra");
        
        log.info("Created 3 sample schedules for classroom ID: {}", classroomId);
    }
    
    private void createAndSaveSchedule(Classroom classroom, User teacher, int dayOfWeek, 
            LocalTime startTime, LocalTime endTime, String room, String subject) {
        
        Schedule schedule = new Schedule();
        schedule.setClassroom(classroom);
        schedule.setTeacher(teacher);
        schedule.setDayOfWeek(dayOfWeek);
        schedule.setStartTime(startTime);
        schedule.setEndTime(endTime);
        schedule.setRoom(room);
        schedule.setSubject(subject);
        schedule.setMaterialsUrl("https://drive.google.com/materials");
        schedule.setMeetUrl("https://meet.google.com/class-" + classroom.getId());
        
        scheduleRepository.save(schedule);
        log.info("Created schedule: {}-{} on day {} in room {}",
                startTime, endTime, getDayOfWeekName(dayOfWeek), room);
    }

    // Helper methods for DayOfWeek conversion (for consolidated ScheduleDto compatibility)
    private DayOfWeek convertIntegerToDayOfWeek(Integer day) {
        if (day == null) return null;
        switch (day) {
            case 0: return DayOfWeek.MONDAY;
            case 1: return DayOfWeek.TUESDAY;
            case 2: return DayOfWeek.WEDNESDAY;
            case 3: return DayOfWeek.THURSDAY;
            case 4: return DayOfWeek.FRIDAY;
            case 5: return DayOfWeek.SATURDAY;
            case 6: return DayOfWeek.SUNDAY;
            default: return DayOfWeek.MONDAY;
        }
    }

    private Integer convertDayOfWeekToInteger(DayOfWeek dayOfWeek) {
        if (dayOfWeek == null) return null;
        switch (dayOfWeek) {
            case MONDAY: return 0;
            case TUESDAY: return 1;
            case WEDNESDAY: return 2;
            case THURSDAY: return 3;
            case FRIDAY: return 4;
            case SATURDAY: return 5;
            case SUNDAY: return 6;
            default: return 0;
        }
    }

    @Override
    public List<LectureDto> getLecturesByScheduleId(Long scheduleId) {
        log.info("Fetching lectures for schedule ID: {}", scheduleId);

        // Find lectures that are associated with this schedule
        List<Lecture> lectures = lectureRepository.findAll().stream()
                .filter(lecture -> lecture.getSchedule() != null && lecture.getSchedule().getId().equals(scheduleId))
                .collect(Collectors.toList());

        log.info("Found {} lectures for schedule ID: {}", lectures.size(), scheduleId);

        return lectures.stream()
                .map(this::convertLectureToDto)
                .collect(Collectors.toList());
    }

    private LectureDto convertLectureToDto(Lecture lecture) {
        LectureDto dto = new LectureDto();
        dto.setId(lecture.getId());
        dto.setTitle(lecture.getTitle());
        dto.setContent(lecture.getContent());
        dto.setLectureDate(lecture.getLectureDate());
        dto.setClassroomId(lecture.getClassroom() != null ? lecture.getClassroom().getId() : null);
        return dto;
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/StudentMessageServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.StudentMessageDto;
import com.classroomapp.classroombackend.model.StudentMessage;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.StudentMessageRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.StudentMessageService;

@Service
@Transactional
public class StudentMessageServiceImpl implements StudentMessageService {
    
    @Autowired
    private StudentMessageRepository messageRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public StudentMessageDto sendMessage(StudentMessageDto messageDto) {
        User sender = userRepository.findById(messageDto.getSenderId())
                .orElseThrow(() -> new RuntimeException("Sender not found"));
        User recipient = userRepository.findById(messageDto.getRecipientId())
                .orElseThrow(() -> new RuntimeException("Recipient not found"));
        
        StudentMessage message = new StudentMessage();
        message.setSender(sender);
        message.setRecipient(recipient);
        message.setSubject(messageDto.getSubject());
        message.setContent(messageDto.getContent());
        message.setMessageType(messageDto.getMessageType() != null ? messageDto.getMessageType() : "GENERAL");
        message.setPriority(messageDto.getPriority() != null ? messageDto.getPriority() : "MEDIUM");
        message.setStatus("SENT");
        message.setIsRead(false);
        
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    @Transactional(readOnly = true)
    public StudentMessageDto getMessageById(Long messageId) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        return convertToDto(message);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getSentMessages(Long senderId) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new RuntimeException("Sender not found"));
        List<StudentMessage> messages = messageRepository.findBySenderOrderByCreatedAtDesc(sender);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getReceivedMessages(Long recipientId) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new RuntimeException("Recipient not found with id: " + recipientId));
        List<StudentMessage> messages = messageRepository.findByRecipientOrderByCreatedAtDesc(recipient);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getConversation(Long user1Id, Long user2Id) {
        User user1 = userRepository.findById(user1Id)
                .orElseThrow(() -> new RuntimeException("User1 not found with id: " + user1Id));
        User user2 = userRepository.findById(user2Id)
                .orElseThrow(() -> new RuntimeException("User2 not found with id: " + user2Id));

        List<StudentMessage> messages = messageRepository.findConversation(user1, user2);
        
        return messages.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getUnreadMessages(Long recipientId) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new RuntimeException("Recipient not found with id: " + recipientId));
        List<StudentMessage> messages = messageRepository.findByRecipientAndIsReadFalseOrderByCreatedAtDesc(recipient);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getMessagesByStatus(String status) {
        List<StudentMessage> messages = messageRepository.findByStatusOrderByCreatedAtDesc(status);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getMessagesByType(String messageType) {
        List<StudentMessage> messages = messageRepository.findByMessageTypeOrderByCreatedAtDesc(messageType);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getMessagesByPriority(String priority) {
        List<StudentMessage> messages = messageRepository.findByPriorityOrderByCreatedAtDesc(priority);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getUrgentMessages(Long recipientId) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new RuntimeException("Recipient not found with id: " + recipientId));
        List<StudentMessage> messages = messageRepository.findUrgentMessages(recipient);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> searchMessages(String keyword) {
        List<StudentMessage> messages = messageRepository.searchMessages(keyword);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getRecentMessages() {
        List<StudentMessage> messages = messageRepository.findRecentMessages();
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getPendingReplies(Long recipientId) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new RuntimeException("Recipient not found with id: " + recipientId));
        List<StudentMessage> messages = messageRepository.findPendingReplies(recipient);
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    public StudentMessageDto markAsRead(Long messageId) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        message.markAsRead();
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    public StudentMessageDto replyToMessage(Long messageId, String reply, Long replierId) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        User replier = userRepository.findById(replierId)
                .orElseThrow(() -> new RuntimeException("Replier not found"));
        
        message.reply(reply, replier);
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    public StudentMessageDto resolveMessage(Long messageId) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        message.resolve();
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    public StudentMessageDto archiveMessage(Long messageId) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        message.archive();
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Long countUnreadMessages(Long recipientId) {
        try {
            // If recipientId is null, count all unread messages
            if (recipientId == null) {
                return messageRepository.countByIsReadFalse();
            }

            // Check if user exists first
            if (!userRepository.existsById(recipientId)) {
                System.out.println("User with ID " + recipientId + " not found in database");
                return 0L; // Return zero instead of throwing exception
            }
            
            User recipient = userRepository.findById(recipientId).get();
            return messageRepository.countUnreadMessagesByRecipient(recipient);
        } catch (Throwable e) {
            System.err.println("Error counting unread messages for user " + recipientId + ": " + e.getMessage());
            e.printStackTrace();
            return 0L;
        }
    }
    
    @Override
    public StudentMessageDto updateMessagePriority(Long messageId, String priority) {
        StudentMessage message = messageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found"));
        message.setPriority(priority);
        message.setUpdatedAt(LocalDateTime.now());
        StudentMessage savedMessage = messageRepository.save(message);
        return convertToDto(savedMessage);
    }
    
    @Override
    public void deleteMessage(Long messageId) {
        if (!messageRepository.existsById(messageId)) {
            throw new RuntimeException("Message not found");
        }
        messageRepository.deleteById(messageId);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentMessageDto> getAllMessages() {
        List<StudentMessage> messages = messageRepository.findAll();
        return messages.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    private StudentMessageDto convertToDto(StudentMessage message) {
        if (message == null) {
            return null;
        }
        
        StudentMessageDto dto = new StudentMessageDto();
        dto.setId(message.getId());
        
        // Add null checks for sender and recipient
        if (message.getSender() != null) {
            dto.setSenderId(message.getSender().getId());
            dto.setSenderName(message.getSender().getFullName());
        } else {
            dto.setSenderId(null); // Or a placeholder ID
            dto.setSenderName("Unknown Sender");
        }
        
        if (message.getRecipient() != null) {
            dto.setRecipientId(message.getRecipient().getId());
            dto.setRecipientName(message.getRecipient().getFullName());
        } else {
            dto.setRecipientId(null); // Or a placeholder ID
            dto.setRecipientName("Unknown Recipient");
        }
        
        dto.setSubject(message.getSubject());
        dto.setContent(message.getContent());
        dto.setMessageType(message.getMessageType());
        dto.setPriority(message.getPriority());
        dto.setStatus(message.getStatus());
        dto.setIsRead(message.getIsRead());
        dto.setReadAt(message.getReadAt());
        dto.setReply(message.getReply());
        dto.setRepliedAt(message.getRepliedAt());
        if (message.getRepliedBy() != null) {
            dto.setRepliedById(message.getRepliedBy().getId());
            dto.setRepliedByName(message.getRepliedBy().getFullName());
        }
        dto.setCreatedAt(message.getCreatedAt());
        dto.setUpdatedAt(message.getUpdatedAt());
        return dto;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/StudentQuestionServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.StudentQuestionDto;
import com.classroomapp.classroombackend.model.StudentQuestion;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.StudentQuestionRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.StudentQuestionService;

@Service
@Transactional
public class StudentQuestionServiceImpl implements StudentQuestionService {
    
    @Autowired
    private StudentQuestionRepository questionRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public StudentQuestionDto createQuestion(StudentQuestionDto questionDto) {
        User student = userRepository.findById(questionDto.getStudentId())
                .orElseThrow(() -> new RuntimeException("Student not found"));
        User teacher = userRepository.findById(questionDto.getTeacherId())
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        
        StudentQuestion question = new StudentQuestion();
        question.setStudent(student);
        question.setTeacher(teacher);
        question.setSubject(questionDto.getSubject());
        question.setContent(questionDto.getContent());
        question.setPriority(questionDto.getPriority() != null ? questionDto.getPriority() : "MEDIUM");
        question.setStatus("PENDING");
        
        StudentQuestion savedQuestion = questionRepository.save(question);
        return convertToDto(savedQuestion);
    }
    
    @Override
    public StudentQuestionDto answerQuestion(Long questionId, String answer, Long teacherId) {
        StudentQuestion question = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("Question not found"));
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        
        question.markAsAnswered(answer, teacher);
        StudentQuestion savedQuestion = questionRepository.save(question);
        return convertToDto(savedQuestion);
    }
    
    @Override
    @Transactional(readOnly = true)
    public StudentQuestionDto getQuestionById(Long questionId) {
        StudentQuestion question = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("Question not found"));
        return convertToDto(question);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getQuestionsByStudent(Long studentId) {
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        List<StudentQuestion> questions = questionRepository.findByStudentOrderByCreatedAtDesc(student);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getQuestionsByTeacher(Long teacherId) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        List<StudentQuestion> questions = questionRepository.findByTeacherOrderByCreatedAtDesc(teacher);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getPendingQuestionsByTeacher(Long teacherId) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        List<StudentQuestion> questions = questionRepository.findByTeacherAndStatusOrderByCreatedAtDesc(teacher, "PENDING");
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getQuestionsByStatus(String status) {
        List<StudentQuestion> questions = questionRepository.findByStatusOrderByCreatedAtDesc(status);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getQuestionsByPriority(String priority) {
        List<StudentQuestion> questions = questionRepository.findByPriorityOrderByCreatedAtDesc(priority);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getConversation(Long studentId, Long teacherId) {
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        List<StudentQuestion> questions = questionRepository.findByStudentAndTeacherOrderByCreatedAtDesc(student, teacher);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> searchQuestions(String keyword) {
        List<StudentQuestion> questions = questionRepository.searchQuestions(keyword);
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<StudentQuestionDto> getRecentQuestions() {
        List<StudentQuestion> questions = questionRepository.findRecentQuestions();
        return questions.stream().map(this::convertToDto).collect(Collectors.toList());
    }
    
    @Override
    public StudentQuestionDto closeQuestion(Long questionId) {
        StudentQuestion question = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("Question not found"));
        question.setStatus("CLOSED");
        question.setUpdatedAt(LocalDateTime.now());
        StudentQuestion savedQuestion = questionRepository.save(question);
        return convertToDto(savedQuestion);
    }
    
    @Override
    public StudentQuestionDto updateQuestionPriority(Long questionId, String priority) {
        StudentQuestion question = questionRepository.findById(questionId)
                .orElseThrow(() -> new RuntimeException("Question not found"));
        question.setPriority(priority);
        question.setUpdatedAt(LocalDateTime.now());
        StudentQuestion savedQuestion = questionRepository.save(question);
        return convertToDto(savedQuestion);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Long countPendingQuestionsByTeacher(Long teacherId) {
        User teacher = userRepository.findById(teacherId)
                .orElseThrow(() -> new RuntimeException("Teacher not found"));
        return questionRepository.countPendingQuestionsByTeacher(teacher);
    }
    
    @Override
    public void deleteQuestion(Long questionId) {
        if (!questionRepository.existsById(questionId)) {
            throw new RuntimeException("Question not found");
        }
        questionRepository.deleteById(questionId);
    }
    
    private StudentQuestionDto convertToDto(StudentQuestion question) {
        StudentQuestionDto dto = new StudentQuestionDto();
        dto.setId(question.getId());
        dto.setStudentId(question.getStudent().getId());
        dto.setStudentName(question.getStudent().getFullName());
        dto.setTeacherId(question.getTeacher().getId());
        dto.setTeacherName(question.getTeacher().getFullName());
        dto.setSubject(question.getSubject());
        dto.setContent(question.getContent());
        dto.setPriority(question.getPriority());
        dto.setStatus(question.getStatus());
        dto.setAnswer(question.getAnswer());
        dto.setAnsweredAt(question.getAnsweredAt());
        if (question.getAnsweredBy() != null) {
            dto.setAnsweredById(question.getAnsweredBy().getId());
            dto.setAnsweredByName(question.getAnsweredBy().getFullName());
        }
        dto.setCreatedAt(question.getCreatedAt());
        dto.setUpdatedAt(question.getUpdatedAt());
        return dto;
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/SubmissionServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.OptionalDouble;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.SubmissionDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;
import com.classroomapp.classroombackend.model.assignmentmanagement.Submission;
import com.classroomapp.classroombackend.model.assignmentmanagement.SubmissionAttachment;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.repository.assignmentmanagement.SubmissionRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.FileStorageService;
import com.classroomapp.classroombackend.service.SubmissionService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class SubmissionServiceImpl implements SubmissionService {

    private final SubmissionRepository submissionRepository;
    private final AssignmentRepository assignmentRepository;
    private final UserRepository userRepository;
    private final ModelMapper modelMapper;
    private final FileStorageService fileStorageService;

    @Override
    public SubmissionDto GetSubmissionById(Long id) {
        Submission submission = FindSubmissionById(id);
        return modelMapper.map(submission, SubmissionDto.class);
    }

    @Override
    @Transactional
    public SubmissionDto submit(CreateSubmissionDto dto, String studentUsername) {
        User student = userRepository.findByEmail(studentUsername)
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", studentUsername));

        Assignment assignment = assignmentRepository.findById(dto.getAssignmentId())
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", dto.getAssignmentId()));

        // 1. Kiểm tra hạn nộp
        if (LocalDateTime.now().isAfter(assignment.getDueDate())) {
            throw new BusinessLogicException("Assignment deadline has passed.");
        }

        // 2. Logic Upsert: Tìm hoặc tạo mới Submission
        Submission submission = submissionRepository
                .findByAssignmentAndStudent(assignment, student)
                .orElse(new Submission(assignment, student));

        // 3. Nếu là nộp lại, xóa file cũ
        if (submission.getId() != null && submission.getAttachments() != null) {
            submission.getAttachments().forEach(att -> fileStorageService.delete(att.getFileName()));
            submission.getAttachments().clear();
        }

        // 4. Cập nhật nội dung và file mới
        submission.setComment(dto.getComment());
        submission.setSubmittedAt(LocalDateTime.now());

        if (dto.getAttachments() != null && !dto.getAttachments().isEmpty()) {
            dto.getAttachments().forEach(fileInfo ->
                submission.addAttachment(new SubmissionAttachment(fileInfo, submission))
            );
        }

        Submission savedSubmission = submissionRepository.save(submission);
        return modelMapper.map(savedSubmission, SubmissionDto.class);
    }

    @Override
    @Transactional
    public SubmissionDto CreateSubmission(CreateSubmissionDto createSubmissionDto, String studentUsername) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(createSubmissionDto.getAssignmentId())
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", createSubmissionDto.getAssignmentId()));
        
        // Get student
        User student = userRepository.findByEmail(studentUsername)
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", studentUsername));
        
        // Validate student role
        if (student.getRoleId() != 1) {
            throw new IllegalArgumentException("Only users with student role can submit assignments");
        }
        
        // Check if student is enrolled in the classroom
        Classroom classroom = assignment.getClassroom();
        if (classroom.getStudents() == null || !classroom.getStudents().contains(student)) {
            throw new IllegalArgumentException("Student is not enrolled in this classroom");
        }
          // Check if submission already exists
        submissionRepository.findByAssignmentAndStudent(assignment, student)
                .ifPresent(existingSubmission -> {
                    throw new IllegalArgumentException("Student has already submitted this assignment");
                });
        
        // Create submission
        Submission submission = new Submission(assignment, student);
        submission.setComment(createSubmissionDto.getComment());
        submission.setSubmittedAt(LocalDateTime.now());

        if (createSubmissionDto.getAttachments() != null && !createSubmissionDto.getAttachments().isEmpty()) {
            createSubmissionDto.getAttachments().forEach(fileInfo ->
                submission.addAttachment(new SubmissionAttachment(fileInfo, submission))
            );
        }
        
        // Save and return
        Submission savedSubmission = submissionRepository.save(submission);
        return modelMapper.map(savedSubmission, SubmissionDto.class);
    }

    @Override
    @Transactional
    public SubmissionDto UpdateSubmission(Long id, CreateSubmissionDto updateSubmissionDto) {
        Submission submission = FindSubmissionById(id);
        
        // Only allow updating if not graded
        if (submission.getScore() != null) {
            throw new IllegalArgumentException("Cannot update a graded submission");
        }
        
        // Delete old attachments from storage
        if (submission.getAttachments() != null && !submission.getAttachments().isEmpty()) {
            submission.getAttachments().forEach(attachment -> fileStorageService.delete(attachment.getFileName()));
        }

        // Clear the old collection of attachments managed by JPA
        submission.getAttachments().clear();
        
        // Update fields
        submission.setComment(updateSubmissionDto.getComment());
        submission.setSubmittedAt(LocalDateTime.now());

        // Add new attachments
        if (updateSubmissionDto.getAttachments() != null && !updateSubmissionDto.getAttachments().isEmpty()) {
            updateSubmissionDto.getAttachments().forEach(fileInfo ->
                submission.addAttachment(new SubmissionAttachment(fileInfo, submission))
            );
        }
        
        // Save and return
        Submission updatedSubmission = submissionRepository.save(submission);
        return modelMapper.map(updatedSubmission, SubmissionDto.class);
    }

    @Override
    @Transactional
    public void DeleteSubmission(Long id) {
        Submission submission = FindSubmissionById(id);
        
        // Only allow deleting if not graded
        if (submission.getScore() != null) {
            throw new IllegalArgumentException("Cannot delete a graded submission");
        }

        // Also delete files from storage before deleting the submission from DB
        if (submission.getAttachments() != null && !submission.getAttachments().isEmpty()) {
            submission.getAttachments().forEach(attachment -> fileStorageService.delete(attachment.getFileName()));
        }
        
        submissionRepository.delete(submission);
    }

    @Override
    public List<SubmissionDto> GetSubmissionsByAssignment(Long assignmentId) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(assignmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", assignmentId));
        
        // Get submissions
        List<Submission> submissions = submissionRepository.findByAssignmentOrderBySubmittedAtDesc(assignment);
        return submissions.stream()
                .map(submission -> modelMapper.map(submission, SubmissionDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<SubmissionDto> GetSubmissionsByStudent(Long studentId) {
        // Get student
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", studentId));
        
        // Get submissions using the optimized query
        List<Submission> submissions = submissionRepository.findByStudentWithDetails(student);
        return submissions.stream()
                .map(submission -> modelMapper.map(submission, SubmissionDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public SubmissionDto GetStudentSubmissionForAssignment(Long assignmentId, Long studentId) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(assignmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", assignmentId));
        
        // Get student
        User student = userRepository.findById(studentId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", studentId));
        
        // Get submission
        Submission submission = submissionRepository.findByAssignmentAndStudent(assignment, student)
                .orElseThrow(() -> new ResourceNotFoundException("Submission", "assignment and student", 
                        assignmentId + " and " + studentId));
        
        return modelMapper.map(submission, SubmissionDto.class);
    }

    @Override
    @Transactional
    public SubmissionDto GradeSubmission(Long submissionId, GradeSubmissionDto gradeSubmissionDto, String teacherUsername) {
        // Get submission
        Submission submission = FindSubmissionById(submissionId);
        
        // Get teacher
        User teacher = userRepository.findByEmail(teacherUsername)
                .orElseThrow(() -> new ResourceNotFoundException("User", "email", teacherUsername));
        
        // Validate teacher role
        if (teacher.getRoleId() != 2 && teacher.getRoleId() != 3) {
            throw new IllegalArgumentException("Only teachers can grade submissions");
        }
        
        // Validate teacher is the owner of the classroom
        Assignment assignment = submission.getAssignment();
        Classroom classroom = assignment.getClassroom();
        
        if (!classroom.getTeacher().equals(teacher)) {
            throw new IllegalArgumentException("Only the classroom teacher can grade submissions");
        }
        
        // Validate score is within the assignment's points
        if (gradeSubmissionDto.getScore() > assignment.getPoints()) {
            throw new IllegalArgumentException("Score cannot exceed the maximum points for the assignment");
        }
        
        // Update submission
        submission.setScore(gradeSubmissionDto.getScore());
        submission.setFeedback(gradeSubmissionDto.getFeedback());
        submission.setGradedAt(LocalDateTime.now());
        submission.setGradedBy(teacher);
        
        // Save and return
        Submission gradedSubmission = submissionRepository.save(submission);
        return modelMapper.map(gradedSubmission, SubmissionDto.class);
    }

    @Override
    public List<SubmissionDto> GetGradedSubmissionsByAssignment(Long assignmentId) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(assignmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", assignmentId));
        
        // Get graded submissions
        List<Submission> submissions = submissionRepository.findByAssignmentAndScoreIsNotNull(assignment);
        return submissions.stream()
                .map(submission -> modelMapper.map(submission, SubmissionDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public List<SubmissionDto> GetUngradedSubmissionsByAssignment(Long assignmentId) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(assignmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", assignmentId));
        
        // Get ungraded submissions
        List<Submission> submissions = submissionRepository.findByAssignmentAndScoreIsNull(assignment);
        return submissions.stream()
                .map(submission -> modelMapper.map(submission, SubmissionDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public SubmissionStatistics GetSubmissionStatisticsForAssignment(Long assignmentId) {
        // Get assignment
        Assignment assignment = assignmentRepository.findById(assignmentId)
                .orElseThrow(() -> new ResourceNotFoundException("Assignment", "id", assignmentId));
        
        // Create statistics object
        SubmissionStatistics stats = new SubmissionStatistics();
        
        // Set total students count
        int totalStudents = assignment.getClassroom().getStudents().size();
        stats.setTotalStudents(totalStudents);
        
        // Set submission count
        long submissionCount = submissionRepository.countByAssignment(assignment);
        stats.setSubmissionCount(submissionCount);
        
        // Get all graded submissions
        List<Submission> gradedSubmissions = submissionRepository.findByAssignmentAndScoreIsNotNull(assignment);
        stats.setGradedCount(gradedSubmissions.size());
        
        // Calculate average score if there are graded submissions
        if (!gradedSubmissions.isEmpty()) {
            OptionalDouble averageScore = gradedSubmissions.stream()
                    .mapToInt(Submission::getScore)
                    .average();
            
            stats.setAverageScore(averageScore.orElse(0.0));
        } else {
            stats.setAverageScore(0.0);
        }
        
        return stats;
    }
    
    // Helper method to find submission by ID or throw exception
    private Submission FindSubmissionById(Long id) {
        return submissionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Submission", "id", id));
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/TimetableServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.dto.CreateEventDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;
import com.classroomapp.classroombackend.model.TimetableEvent;
import com.classroomapp.classroombackend.repository.TimetableEventRepository;
import com.classroomapp.classroombackend.service.TimetableService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TimetableServiceImpl implements TimetableService {

    private final TimetableEventRepository timetableEventRepository;

    @Override
    @Transactional
    public TimetableEventDto createEvent(CreateEventDto createDto, Long createdBy) {
        TimetableEvent event = new TimetableEvent();
        event.setTitle(createDto.getTitle());
        event.setDescription(createDto.getDescription());
        event.setStartDatetime(createDto.getStartDatetime());
        event.setEndDatetime(createDto.getEndDatetime());
        event.setEventType(TimetableEvent.EventType.valueOf(createDto.getEventType()));
        event.setClassroomId(createDto.getClassroomId());
        event.setLocation(createDto.getLocation());
        event.setIsAllDay(createDto.getIsAllDay());
        event.setReminderMinutes(createDto.getReminderMinutes());
        event.setColor(createDto.getColor());
        event.setRecurringRule(createDto.getRecurringRule());
        event.setParentEventId(createDto.getParentEventId());
        event.setCreatedBy(createdBy);
        event.setCreatedAt(LocalDateTime.now());
        event.setUpdatedAt(LocalDateTime.now());
        event.setIsCancelled(false);
        
        TimetableEvent savedEvent = timetableEventRepository.save(event);
        return convertToDto(savedEvent);
    }

    @Override
    @Transactional(readOnly = true)
    public TimetableEventDto getEventById(Long eventId) {
        TimetableEvent event = timetableEventRepository.findById(eventId)
                .orElseThrow(() -> new RuntimeException("Event not found with id: " + eventId));
        return convertToDto(event);
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsByClassroomAndDateRange(Long classroomId, LocalDateTime startDate, LocalDateTime endDate) {
        List<TimetableEvent> events = timetableEventRepository.findEventsByClassroomAndDateRange(
                classroomId, startDate, endDate);
        return events.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsByDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        List<TimetableEvent> events = timetableEventRepository.findEventsByDateRange(startDate, endDate);
        return events.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getUpcomingEvents(Long classroomId) {
        // Get upcoming events for the next 30 days
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime thirtyDaysLater = now.plusDays(30);
        
        List<TimetableEvent> events;
        if (classroomId != null) {
            events = timetableEventRepository.findEventsByClassroomAndDateRange(
                    classroomId, now, thirtyDaysLater);
        } else {
            events = timetableEventRepository.findUpcomingEvents(now);
        }
        
        return events.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsByType(Long classroomId, String eventType) {
        TimetableEvent.EventType type = TimetableEvent.EventType.valueOf(eventType);
        List<TimetableEvent> events = timetableEventRepository.findByEventType(type);
        
        // Filter by classroom if provided
        List<TimetableEvent> filteredEvents;
        if (classroomId != null) {
            filteredEvents = events.stream()
                    .filter(event -> event.getClassroomId() != null && event.getClassroomId().equals(classroomId))
                    .collect(Collectors.toList());
        } else {
            filteredEvents = events;
        }
        
        return filteredEvents.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getAllDayEvents(Long classroomId) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime oneMonthLater = now.plusMonths(1);
        
        List<TimetableEvent> events = timetableEventRepository.findAllDayEventsByDateRange(now, oneMonthLater);
        
        // Filter by classroom if provided
        List<TimetableEvent> filteredEvents;
        if (classroomId != null) {
            filteredEvents = events.stream()
                    .filter(event -> event.getClassroomId() != null && event.getClassroomId().equals(classroomId))
                    .collect(Collectors.toList());
        } else {
            filteredEvents = events;
        }
        
        return filteredEvents.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getRecurringEvents(Long classroomId) {
        // Get all events with a recurring rule
        List<TimetableEvent> allEvents = timetableEventRepository.findAll();
        List<TimetableEvent> recurringEvents = allEvents.stream()
                .filter(event -> event.getRecurringRule() != null && !event.getRecurringRule().isEmpty())
                .collect(Collectors.toList());
        
        // Filter by classroom if provided
        List<TimetableEvent> filteredEvents;
        if (classroomId != null) {
            filteredEvents = recurringEvents.stream()
                    .filter(event -> event.getClassroomId() != null && event.getClassroomId().equals(classroomId))
                    .collect(Collectors.toList());
        } else {
            filteredEvents = recurringEvents;
        }
        
        return filteredEvents.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public TimetableEventDto updateEvent(Long eventId, CreateEventDto updateDto) {
        TimetableEvent event = timetableEventRepository.findById(eventId)
                .orElseThrow(() -> new RuntimeException("Event not found with id: " + eventId));
        
        // Update fields
        if (updateDto.getTitle() != null) {
            event.setTitle(updateDto.getTitle());
        }
        if (updateDto.getDescription() != null) {
            event.setDescription(updateDto.getDescription());
        }
        if (updateDto.getStartDatetime() != null) {
            event.setStartDatetime(updateDto.getStartDatetime());
        }
        if (updateDto.getEndDatetime() != null) {
            event.setEndDatetime(updateDto.getEndDatetime());
        }
        if (updateDto.getEventType() != null) {
            event.setEventType(TimetableEvent.EventType.valueOf(updateDto.getEventType()));
        }
        if (updateDto.getClassroomId() != null) {
            event.setClassroomId(updateDto.getClassroomId());
        }
        if (updateDto.getLocation() != null) {
            event.setLocation(updateDto.getLocation());
        }
        if (updateDto.getIsAllDay() != null) {
            event.setIsAllDay(updateDto.getIsAllDay());
        }
        if (updateDto.getReminderMinutes() != null) {
            event.setReminderMinutes(updateDto.getReminderMinutes());
        }
        if (updateDto.getColor() != null) {
            event.setColor(updateDto.getColor());
        }
        if (updateDto.getRecurringRule() != null) {
            event.setRecurringRule(updateDto.getRecurringRule());
        }
        
        event.setUpdatedAt(LocalDateTime.now());
        
        TimetableEvent updatedEvent = timetableEventRepository.save(event);
        return convertToDto(updatedEvent);
    }

    @Override
    @Transactional
    public void deleteEvent(Long eventId) {
        timetableEventRepository.deleteById(eventId);
    }

    @Override
    @Transactional
    public TimetableEventDto cancelEvent(Long eventId) {
        TimetableEvent event = timetableEventRepository.findById(eventId)
                .orElseThrow(() -> new RuntimeException("Event not found with id: " + eventId));
        
        event.setIsCancelled(true);
        event.setUpdatedAt(LocalDateTime.now());
        
        TimetableEvent updatedEvent = timetableEventRepository.save(event);
        return convertToDto(updatedEvent);
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> checkConflicts(Long classroomId, LocalDateTime startTime, LocalDateTime endTime, Long excludeEventId) {
        List<TimetableEvent> events = timetableEventRepository.findEventsByClassroomAndDateRange(
                classroomId, startTime, endTime);
        
        // Filter out the excluded event if provided
        List<TimetableEvent> filteredEvents;
        if (excludeEventId != null) {
            filteredEvents = events.stream()
                    .filter(event -> !event.getId().equals(excludeEventId))
                    .collect(Collectors.toList());
        } else {
            filteredEvents = events;
        }
        
        return filteredEvents.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsByClassrooms(List<Long> classroomIds, LocalDateTime startDate, LocalDateTime endDate) {
        // Get events for each classroom and combine
        List<TimetableEvent> allEvents = new ArrayList<>();
        for (Long classroomId : classroomIds) {
            List<TimetableEvent> classroomEvents = timetableEventRepository.findEventsByClassroomAndDateRange(
                    classroomId, startDate, endDate);
            allEvents.addAll(classroomEvents);
        }
        
        return allEvents.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void addAttendee(Long eventId, Long userId) {
        // Implementation for adding attendees would be here
        // This would require additional repository methods and models
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsForUser(Long userId, LocalDateTime startDate, LocalDateTime endDate) {
        System.out.println("📅 TimetableServiceImpl.getEventsForUser: Getting events for user " + userId);
        System.out.println("   Date range: " + startDate + " to " + endDate);

        // For now, return all events in the date range
        // TODO: In a real implementation, we would:
        // 1. Get classrooms where user is enrolled (for students) or teaching (for teachers)
        // 2. Get events only for those classrooms
        // 3. Filter by user permissions

        List<TimetableEvent> events = timetableEventRepository.findEventsByDateRange(startDate, endDate);
        System.out.println("📅 TimetableServiceImpl.getEventsForUser: Found " + events.size() + " events");

        return events.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void removeAttendee(Long eventId, Long userId) {
        // Implementation for removing attendees would be here
    }

    @Override
    @Transactional
    public void updateAttendanceStatus(Long eventId, Long userId, String status) {
        // Implementation for updating attendance status would be here
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventAttendees(Long eventId) {
        // Implementation for getting event attendees would be here
        return List.of();
    }

    @Override
    @Transactional
    public List<TimetableEventDto> createRecurringInstances(Long parentEventId, LocalDateTime endDate) {
        // Implementation for creating recurring instances would be here
        return List.of();
    }

    @Override
    @Transactional(readOnly = true)
    public List<TimetableEventDto> getEventsByCreator(Long createdBy) {
        List<TimetableEvent> events = timetableEventRepository.findByCreatedBy(createdBy);
        return events.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }
    
    // Helper method to convert entity to DTO
    private TimetableEventDto convertToDto(TimetableEvent event) {
        TimetableEventDto dto = new TimetableEventDto();
        dto.setId(event.getId());
        dto.setTitle(event.getTitle());
        dto.setDescription(event.getDescription());
        dto.setStartDatetime(event.getStartDatetime());
        dto.setEndDatetime(event.getEndDatetime());
        dto.setEventType(event.getEventType().name());
        dto.setClassroomId(event.getClassroomId());
        dto.setLectureId(event.getLectureId()); // Set lectureId for attendance navigation
        dto.setCreatedBy(event.getCreatedBy());
        dto.setLocation(event.getLocation());
        dto.setIsAllDay(event.getIsAllDay());
        dto.setReminderMinutes(event.getReminderMinutes());
        dto.setColor(event.getColor());
        dto.setRecurringRule(event.getRecurringRule());
        dto.setParentEventId(event.getParentEventId());
        dto.setIsCancelled(event.getIsCancelled());
        dto.setCreatedAt(event.getCreatedAt());
        dto.setUpdatedAt(event.getUpdatedAt());
        
        // If the classroom is loaded, include its name
        if (event.getClassroom() != null) {
            dto.setClassroomName(event.getClassroom().getName());
        }
        
        return dto;
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/UserServiceExtensionImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.Optional;
import java.util.UUID;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.EmailService;
import com.classroomapp.classroombackend.service.UserServiceExtension;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceExtensionImpl implements UserServiceExtension {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final EmailService emailService;

    @Override
    @Transactional
    public boolean updateUserRole(String email, String role) {
        Optional<User> optionalUser = userRepository.findByEmail(email);
        if (optionalUser.isPresent()) {
            User user = optionalUser.get();
            user.setRoleId(convertRoleToRoleId(role));
            userRepository.save(user);
            log.info("Updated role for user: {} to {}", email, role);
            return true;
        }
        return false;
    }

    @Override
    public boolean userExists(String email) {
        return userRepository.existsByEmail(email);
    }

    @Override
    @Transactional
    public boolean createOrUpdateUser(String email, String fullName, String role) {
        try {
            log.info("Creating or updating user with email: {}, name: {}, role: {}", email, fullName, role);
            Optional<User> optionalUser = userRepository.findByEmail(email);
            
            if (optionalUser.isPresent()) {
                // User exists, update role
                User user = optionalUser.get();
                Integer roleId = convertRoleToRoleId(role);
                log.info("User exists - current role: {}, new role: {}", user.getRoleId(), roleId);
                user.setRoleId(roleId);
                userRepository.save(user);
                log.info("Updated role for existing user: {} to {}", email, role);
                return true;
            } else {
                // Create new user with temporary password
                log.info("User does not exist, creating new user");
                String tempPassword = UUID.randomUUID().toString().substring(0, 8);
                User user = new User();
                user.setEmail(email);
                user.setUsername(email); // Use email as username
                user.setPassword(passwordEncoder.encode(tempPassword));
                user.setFullName(fullName);
                user.setRoleId(convertRoleToRoleId(role));
                user.setStatus("active");
                
                User savedUser = userRepository.save(user);
                log.info("Created new user: {} with ID: {} and role {}", email, savedUser.getId(), role);
                
                // Send email with temporary password
                try {
                    emailService.sendAccountInfoEmail(
                        email, 
                        fullName, 
                        getReadableRole(role),
                        email, // username
                        tempPassword
                    );
                    log.info("Sent account information email to new user: {}", email);
                } catch (Exception e) {
                    log.error("Failed to send account information email to: {}", email, e);
                    // Don't fail user creation if email sending fails
                }
                
                return true;
            }
        } catch (Exception e) {
            log.error("Error creating/updating user: {}", email, e);
            return false;
        }
    }
    
    /**
     * Returns a human-readable role name
     */
    private String getReadableRole(String role) {
        switch (role) {
            case "STUDENT": return "Student";
            case "TEACHER": return "Teacher";
            case "MANAGER": return "Manager";
            case "ADMIN": return "Administrator";
            default: return role;
        }
    }
    
    // Helper method to convert role string to roleId
    private Integer convertRoleToRoleId(String role) {
        switch (role) {
            case "STUDENT":
                return 1;
            case "TEACHER":
                return 2;
            case "MANAGER":
                return 3;
            case "ADMIN":
                return 4;
            default:
                return 1; // Default to STUDENT
        }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/impl/UserServiceImpl.java">
package com.classroomapp.classroombackend.service.impl;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.classroomapp.classroombackend.constants.RoleConstants;
import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.exception.BusinessLogicException;
import com.classroomapp.classroombackend.exception.ResourceNotFoundException;
import com.classroomapp.classroombackend.model.usermanagement.Role;
import com.classroomapp.classroombackend.model.usermanagement.User;
import com.classroomapp.classroombackend.repository.usermanagement.RoleRepository;
import com.classroomapp.classroombackend.repository.usermanagement.UserRepository;
import com.classroomapp.classroombackend.service.UserService;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final JavaMailSender mailSender;

    private UserDto convertToUserDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setName(user.getFullName());
        dto.setEmail(user.getEmail());
        dto.setEnabled("active".equalsIgnoreCase(user.getStatus()));
        dto.setRoles(Collections.singleton(user.getRole()));
        return dto;
    }

    @Override
    public List<UserDto> getAllUsers() {
        return userRepository.findAll().stream()
                .map(this::convertToUserDto)
                .collect(Collectors.toList());
    }

    @Override
    public Page<UserDto> findAllUsers(String keyword, Pageable pageable) {
        Page<User> userPage;
        if (keyword != null && !keyword.isEmpty()) {
            userPage = userRepository.findByFullNameContainingIgnoreCaseOrEmailContainingIgnoreCase(keyword, keyword, pageable);
        } else {
            userPage = userRepository.findAll(pageable);
        }
        return userPage.map(this::convertToUserDto);
    }

    @Transactional
    @Override
    public UserDto updateUserStatus(Long userId, boolean enabled) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        String currentUsername = "";
        if (principal instanceof UserDetails) {
            currentUsername = ((UserDetails)principal).getUsername();
        } else {
            currentUsername = principal.toString();
        }

        if (user.getEmail().equals(currentUsername)) {
            throw new BusinessLogicException("Cannot disable your own account.");
        }

        user.setStatus(enabled ? "active" : "disabled");
        User updatedUser = userRepository.save(user);
        return convertToUserDto(updatedUser);
    }

    @Override
    public List<UserDto> FindAllUsers() {
        // Convert list of User entities to UserDto objects
        return userRepository.findAll().stream()
                .map(this::convertToUserDto)
                .collect(Collectors.toList());
    }

    @Override
    public UserDto FindUserById(Long id) {
        // Find user by ID or throw exception if not found
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        
        return this.convertToUserDto(user);
    }

    @Override
    public UserDto FindUserByUsername(String username) {
        // Find user by username or throw exception if not found
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with username: " + username));
        
        return this.convertToUserDto(user);
    }

    /*
    // TODO: Refactor CreateUser with a new CreateUserRequestDto
    @Override
    public UserDto CreateUser(UserDto userDto) {
        // Check if username or email already exists
        if (userRepository.existsByEmail(userDto.getEmail())) {
            throw new IllegalArgumentException("Email already registered");
        }
        
        // Convert DTO to entity
        User user = UserMapper.toEntity(userDto);
        
        // Encode password before saving
        // Note: In a real application, you would receive the password in a separate DTO
        if (user.getPassword() != null) {
            user.setPassword(passwordEncoder.encode(user.getPassword()));
        }
        
        // Save user and return as DTO
        User savedUser = userRepository.save(user);
        return this.convertToUserDto(savedUser);
    }
    */

    /*
    // TODO: Refactor UpdateUser with a new UpdateUserRequestDto
    @Override
    public UserDto UpdateUser(Long id, UserDto userDto) {
        // Check if user exists
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        
        // Check if email is being changed and is already taken by another user
        if (!existingUser.getEmail().equals(userDto.getEmail()) && 
                userRepository.existsByEmail(userDto.getEmail())) {
            throw new IllegalArgumentException("Email already registered");
        }
        
        // Update fields
        existingUser.setEmail(userDto.getEmail());
        existingUser.setFullName(userDto.getName());
        
        // Note: Password should be updated in a separate endpoint with proper validation
        
        // Save updated user and return as DTO
        User updatedUser = userRepository.save(existingUser);
        return this.convertToUserDto(updatedUser);
    }
    */

    @Override
    public void DeleteUser(Long id) {
        // Check if user exists
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("User not found with id: " + id);
        }
        
        // Delete user
        userRepository.deleteById(id);
    }

    @Override
    public boolean IsUsernameExists(String username) {
        return userRepository.existsByUsername(username);
    }

    @Override
    public boolean IsEmailExists(String email) {
        return userRepository.existsByEmail(email);
    }
    
    @Override
    public List<UserDto> FindUsersByRole(Integer roleId) {
        // Use the repository method to find users by role ID
        List<User> users = userRepository.findByRoleId(roleId);
        return users.stream()
                .map(this::convertToUserDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public UserDto updateUserRoles(Long userId, Set<String> roleNames) {
        if (roleNames == null || roleNames.isEmpty()) {
            throw new BusinessLogicException("Roles cannot be empty.");
        }
        // The current schema only supports one role per user.
        // We throw an error if more than one role is provided to make this limitation clear.
        if (roleNames.size() > 1) {
            throw new BusinessLogicException("System currently supports only one role per user.");
        }

        String newRoleName = roleNames.iterator().next();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        Role newRole = roleRepository.findByName(newRoleName)
                .orElseThrow(() -> new BusinessLogicException("Role not found: " + newRoleName));

        // Business rule: Prevent admin from removing their own admin role
        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if (principal instanceof UserDetails) {
            String currentUsername = ((UserDetails) principal).getUsername();
            if (user.getEmail().equals(currentUsername) &&
                user.getRoleId() == RoleConstants.ADMIN &&
                !newRole.getId().equals(RoleConstants.ADMIN)) {
                throw new BusinessLogicException("Cannot remove ADMIN role from your own account.");
            }
        }

        user.setRoleId(newRole.getId());
        User updatedUser = userRepository.save(user);
        return convertToUserDto(updatedUser);
    }

    @Override
    public void sendPasswordResetEmail(String email, String resetLink) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(email);
        message.setSubject("Password Reset Request");
        message.setText("To reset your password, click the link below:\n" +
            "http://localhost:3000/reset-password?token=" + resetLink);
        mailSender.send(message);
    }
    
    @Override
    public User findUserEntityByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElse(null);
    }
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AcademicPerformanceService.java">
 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AccomplishmentSecurityService.java">
package com.classroomapp.classroombackend.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import com.classroomapp.classroombackend.model.Accomplishment;
import com.classroomapp.classroombackend.repository.AccomplishmentRepository;

@Service("accomplishmentSecurityService")
public class AccomplishmentSecurityService {

    @Autowired
    private AccomplishmentRepository accomplishmentRepository;

    public boolean isOwner(Authentication authentication, Long accomplishmentId) {
        String currentUsername = authentication.getName();
        Accomplishment accomplishment = accomplishmentRepository.findById(accomplishmentId).orElse(null);
        if (accomplishment == null) {
            return false;
        }
        return accomplishment.getStudent().getEmail().equals(currentUsername);
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AccomplishmentService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import org.springframework.security.core.userdetails.UserDetails;

import com.classroomapp.classroombackend.dto.AccomplishmentDto;

public interface AccomplishmentService {

    List<AccomplishmentDto> getAccomplishmentsByOwner(UserDetails userDetails);

    AccomplishmentDto createAccomplishment(AccomplishmentDto accomplishmentDto, UserDetails userDetails);

    AccomplishmentDto updateAccomplishment(Long id, AccomplishmentDto accomplishmentDto);

    void deleteAccomplishment(Long id);
    
    List<AccomplishmentDto> getStudentAccomplishments(Long userId);

}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AdminRequestService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.requestmanagement.RequestDTO;

public interface AdminRequestService {
    List<RequestDTO> getAllRequests();
    RequestDTO approveRequest(Long id);
    RequestDTO rejectRequest(Long id, String reason);
    List<RequestDTO> getPendingRequests();
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AnnouncementService.java">
package com.classroomapp.classroombackend.service;

import com.classroomapp.classroombackend.dto.AnnouncementDto;
import com.classroomapp.classroombackend.dto.CreateAnnouncementDto;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface AnnouncementService {
    
    /**
     * Create a new announcement
     */
    AnnouncementDto createAnnouncement(CreateAnnouncementDto createDto, Long createdBy);
    
    /**
     * Create announcement with attachments
     */
    AnnouncementDto createAnnouncementWithAttachments(CreateAnnouncementDto createDto, 
                                                    List<MultipartFile> attachments, Long createdBy);
    
    /**
     * Get announcement by ID
     */
    AnnouncementDto getAnnouncementById(Long announcementId);
    
    /**
     * Get active announcements for a classroom
     */
    List<AnnouncementDto> getActiveAnnouncementsByClassroom(Long classroomId);
    
    /**
     * Get global announcements
     */
    List<AnnouncementDto> getGlobalAnnouncements();
    
    /**
     * Get pinned announcements
     */
    List<AnnouncementDto> getPinnedAnnouncements(Long classroomId);
    
    /**
     * Get announcements by priority
     */
    List<AnnouncementDto> getAnnouncementsByPriority(Long classroomId, String priority);
    
    /**
     * Update announcement
     */
    AnnouncementDto updateAnnouncement(Long announcementId, CreateAnnouncementDto updateDto);
    
    /**
     * Delete announcement
     */
    void deleteAnnouncement(Long announcementId);
    
    /**
     * Archive announcement
     */
    AnnouncementDto archiveAnnouncement(Long announcementId);
    
    /**
     * Pin/unpin announcement
     */
    AnnouncementDto togglePinAnnouncement(Long announcementId);
    
    /**
     * Mark announcement as read by user
     */
    void markAsRead(Long announcementId, Long userId);
    
    /**
     * Get unread announcements for a user
     */
    List<AnnouncementDto> getUnreadAnnouncements(Long classroomId, Long userId);
    
    /**
     * Count unread announcements for a user
     */
    long countUnreadAnnouncements(Long classroomId, Long userId);
    
    /**
     * Search announcements
     */
    List<AnnouncementDto> searchAnnouncements(Long classroomId, String searchTerm);
    
    /**
     * Get announcements created by a user
     */
    List<AnnouncementDto> getAnnouncementsByCreator(Long createdBy);
    
    /**
     * Process scheduled announcements
     */
    void processScheduledAnnouncements();
    
    /**
     * Archive expired announcements
     */
    void archiveExpiredAnnouncements();
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AssessmentService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.AssessmentDto;
import com.classroomapp.classroombackend.dto.CreateAssessmentDto;

public interface AssessmentService {
    AssessmentDto createAssessment(Long lectureId, CreateAssessmentDto createAssessmentDto, String userEmail);
    List<AssessmentDto> getAssessmentsByLectureId(Long lectureId);
    AssessmentDto getAssessmentById(Long assessmentId);
    void deleteAssessment(Long assessmentId, String userEmail);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AssignmentService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.AssignmentRubricDto;
import com.classroomapp.classroombackend.dto.AssignmentSubmissionDto;
import com.classroomapp.classroombackend.dto.BulkGradingDto;
import com.classroomapp.classroombackend.dto.BulkGradingResultDto;
import com.classroomapp.classroombackend.dto.CreateFeedbackDto;
import com.classroomapp.classroombackend.dto.CreateRubricDto;
import com.classroomapp.classroombackend.dto.FeedbackDto;
import com.classroomapp.classroombackend.dto.GradeDto;
import com.classroomapp.classroombackend.dto.GradingAnalyticsDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.AssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateAssignmentDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.model.assignmentmanagement.Assignment;

public interface AssignmentService {
    
    // Get an assignment entity by ID (for internal use)
    Assignment findEntityById(Long id);
    
    // Get an assignment by ID
    AssignmentDto GetAssignmentById(Long id);
    
    // Create a new assignment
    AssignmentDto CreateAssignment(CreateAssignmentDto createAssignmentDto, String teacherUsername);
    
    // Update an existing assignment
    AssignmentDto UpdateAssignment(Long id, CreateAssignmentDto updateAssignmentDto);
    
    // Delete an assignment
    void DeleteAssignment(Long id);
    
    // Get all assignments for a classroom
    List<AssignmentDto> GetAssignmentsByClassroom(Long classroomId);
    
    // Get all assignments (for admin/overview purposes)
    List<AssignmentDto> GetAllAssignments();
      // Get assignments for a specific student (enrolled classrooms)
    List<AssignmentDto> GetAssignmentsByStudent(Long studentId);
    
    // Get assignments for the current teacher
    List<AssignmentDto> getAssignmentsByCurrentTeacher();

    // Get assignments for the current student
    List<AssignmentDto> getAssignmentsByCurrentStudent();

    // Get assignments for a specific teacher (their classrooms)
    List<AssignmentDto> getAssignmentsByTeacher(Long teacherId);
    
    // Additional methods needed by FrontendApiBridgeController
    List<AssignmentDto> findByTeacherId(Long teacherId);
    List<AssignmentDto> findByStudentId(Long studentId);
    List<AssignmentDto> getAllAssignments();
    
    // Get upcoming assignments for a classroom
    List<AssignmentDto> GetUpcomingAssignmentsByClassroom(Long classroomId);
    
    // Get past assignments for a classroom
    List<AssignmentDto> GetPastAssignmentsByClassroom(Long classroomId);
    
    // Search for assignments by title
    List<AssignmentDto> SearchAssignmentsByTitle(String title);
    
    // Additional methods needed by AssignmentController
    
    // Get assignment submissions for grading
    List<AssignmentSubmissionDto> getAssignmentSubmissions(Long assignmentId);
    
    // Grade a submission
    GradeDto gradeSubmission(Long assignmentId, Long submissionId, GradeSubmissionDto gradeSubmissionDto);
    
    // Get assignment rubric
    AssignmentRubricDto getAssignmentRubric(Long assignmentId);
    
    // Create assignment rubric
    AssignmentRubricDto createAssignmentRubric(Long assignmentId, CreateRubricDto createRubricDto);
    
    // Bulk grade submissions
    BulkGradingResultDto bulkGradeSubmissions(Long assignmentId, BulkGradingDto bulkGradingDto);
    
    // Get grading analytics
    GradingAnalyticsDto getGradingAnalytics(Long assignmentId);
    
    // Provide feedback
    FeedbackDto provideFeedback(Long assignmentId, CreateFeedbackDto createFeedbackDto);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AttendanceService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import org.springframework.security.core.userdetails.UserDetails;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceRecordDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceResultDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSubmitDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateAttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateOrUpdateAttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.MyAttendanceHistoryDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.StudentAttendanceDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.TeachingHistoryDto;
import com.classroomapp.classroombackend.model.attendancemanagement.Attendance;
import com.classroomapp.classroombackend.model.attendancemanagement.AttendanceSession;

public interface AttendanceService {

    /**
     * Creates a new attendance session for a classroom.
     * Only a teacher of the classroom can perform this action.
     *
     * @param createDto DTO containing classroom ID and session duration.
     * @return The created AttendanceSession entity.
     */
    AttendanceSession createSession(CreateAttendanceSessionDto createDto);

    /**
     * Records a student's attendance for a specific session.
     *
     * @param sessionId   The ID of the attendance session.
     * @param studentCode A unique code from the student (e.g., from QR scan), can be extended later.
     * @return The created AttendanceRecord.
     */
    Attendance recordStudentAttendance(Long sessionId, String studentCode);

    /**
     * Closes an open attendance session.
     * Only a teacher of the classroom can perform this action.
     *
     * @param sessionId The ID of the session to close.
     * @return The updated AttendanceSession.
     */
    AttendanceSession closeSession(Long sessionId);

    /**
     * Retrieves the list of all attendance records for a specific session.
     * Only the teacher can view all records.
     *
     * @param sessionId The ID of the session.
     * @return A list of DTOs representing student attendance.
     */
    List<StudentAttendanceDto> getSessionAttendance(Long sessionId);

    /**
     * Calculates and retrieves the overall attendance result for a student in a classroom.
     * Can be accessed by the teacher or the student themselves.
     *
     * @param classroomId The ID of the classroom.
     * @param studentId   The ID of the student.
     * @return A DTO containing the attendance statistics.
     */
    AttendanceResultDto getAttendanceResult(Long classroomId, Long studentId);

    /**
     * Gets the currently active attendance session for a classroom. (New flow)
     * @param classroomId The ID of the classroom.
     * @return The active session DTO, or null if none exists.
     */
    AttendanceSessionDto getActiveSession(Long classroomId);

    /**
     * Marks attendance for a student. (New flow)
     * @param dto The DTO containing the session ID.
     * @param userDetails The security principal of the student.
     */
    void markAttendance(StudentAttendanceDto dto, UserDetails userDetails);

    /**
     * Gets the results of a specific attendance session. (New flow)
     * @param sessionId The ID of the session.
     * @return A list of all students in the class and their attendance status.
     */
    List<AttendanceResultDto> getSessionResults(Long sessionId);

    // --- Old/Existing Methods ---

    void createOrUpdateAttendance(CreateOrUpdateAttendanceDto dto);

    List<AttendanceRecordDto> getAttendanceForLecture(Long lectureId, Long classroomId);

    List<MyAttendanceHistoryDto> getMyAttendanceHistory(Long studentId, Long classroomId);
    
    /**
     * Lấy lịch sử giảng dạy của giáo viên
     * @param teacherId ID của giáo viên
     * @return Danh sách các buổi học đã được ghi nhận giảng dạy
     */
    List<TeachingHistoryDto> getTeachingHistory(Long teacherId);
    
    /**
     * Find attendance records by user ID
     * @param userId The ID of the user
     * @return List of attendance records
     */
    List<AttendanceDto> findByUserId(Long userId);

    void submitAttendance(AttendanceSubmitDto submitDto);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AttendanceSessionService.java">
package com.classroomapp.classroombackend.service;

import java.security.Principal;
import java.util.List;

import org.springframework.http.ResponseEntity;

import com.classroomapp.classroombackend.dto.attendancemanagement.AttendanceSessionDto;
import com.classroomapp.classroombackend.dto.attendancemanagement.CreateAttendanceSessionDto;

public interface AttendanceSessionService {
    ResponseEntity<AttendanceSessionDto> createSession(CreateAttendanceSessionDto createDto, Principal principal);
    ResponseEntity<List<AttendanceSessionDto>> getSessionsForClassroom(Long classroomId, Principal principal);
    ResponseEntity<AttendanceSessionDto> getSessionDetails(Long sessionId, Principal principal);
    ResponseEntity<?> closeSession(Long sessionId, Principal principal);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/AuthService.java">
package com.classroomapp.classroombackend.service;

import com.classroomapp.classroombackend.dto.GoogleAuthRequestDto;
import com.classroomapp.classroombackend.dto.LoginRequestDto;
import com.classroomapp.classroombackend.dto.LoginResponseDto;
import com.classroomapp.classroombackend.dto.PasswordConfirmationDto;
import com.classroomapp.classroombackend.dto.PasswordResetRequestDto;
import com.classroomapp.classroombackend.dto.RegisterDto;
import com.classroomapp.classroombackend.dto.UserDto;

/**
 * Service for authentication-related operations
 */
public interface AuthService {

    /**
     * Register a new user
     * 
     * @param registerDto registration data
     * @return created user data
     */
    UserDto registerUser(RegisterDto registerDto);

    LoginResponseDto authenticateUser(LoginRequestDto loginRequest);

    LoginResponseDto authenticateWithGoogle(GoogleAuthRequestDto googleAuthRequest);

    void requestPasswordReset(PasswordResetRequestDto passwordResetRequest);

    void resetPassword(PasswordConfirmationDto passwordConfirmation);

    String generateToken(String username, Integer roleId, String email);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/BlogService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.BlogDto;
import com.classroomapp.classroombackend.dto.CreateBlogDto;

public interface BlogService {
    
    BlogDto createBlog(CreateBlogDto createBlogDto, Long authorId);
    
    BlogDto getBlogById(Long id);

    BlogDto getBlogBySlug(String slug);
    
    List<BlogDto> getAllBlogs();
    
    List<BlogDto> getPublishedBlogs();
    
    List<BlogDto> getBlogsByAuthor(Long authorId);
    
    BlogDto updateBlog(Long id, CreateBlogDto updateBlogDto, Long editorId);
    
    void deleteBlog(Long id);
    
    BlogDto publishBlog(Long id, Long publisherId);
    
    BlogDto unpublishBlog(Long id, Long unpublisherId);
    
    List<BlogDto> searchBlogs(String keyword);
    
    List<BlogDto> getBlogsByTag(String tag);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/ClassroomSecurityService.java">
package com.classroomapp.classroombackend.service;

import com.classroomapp.classroombackend.model.usermanagement.User;

public interface ClassroomSecurityService {

    boolean isMember(Long classroomId);

    boolean isTeacher(Long classroomId);

    boolean isMember(Long classroomId, Object principal);

    boolean isTeacherOfClassroom(Object principal, Long classroomId);

    boolean isTeacherOfClassroom(User user, Long classroomId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/ClassroomService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import org.springframework.security.core.userdetails.UserDetails;

import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.ClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;
import com.classroomapp.classroombackend.dto.classroommanagement.CreateClassroomDto;
import com.classroomapp.classroombackend.dto.classroommanagement.UpdateClassroomDto;
import com.classroomapp.classroombackend.model.usermanagement.User;

public interface ClassroomService {
    
    // Retrieve all classrooms
    List<ClassroomDto> getAllClassrooms();
    
    // Retrieve a classroom by its ID (lowercase method for video conference)
    ClassroomDto getClassroomById(Long id);
    
    // Retrieve a classroom by its ID
    ClassroomDto GetClassroomById(Long id);
    
    // Create a new classroom with the logged-in user as teacher
    ClassroomDetailsDto createClassroom(CreateClassroomDto dto);
    
    // Update an existing classroom
    ClassroomDto UpdateClassroom(Long id, UpdateClassroomDto updateClassroomDto, UserDetails userDetails);
    
    // Delete a classroom
    void DeleteClassroom(Long id);
    
    // Get all classrooms taught by a specific teacher
    List<ClassroomDto> GetClassroomsByTeacher(Long teacherId);
    
    // Get all classrooms where a student is enrolled
    List<ClassroomDto> GetClassroomsByStudent(Long studentId);
    
    // Enroll a student in a classroom
    void EnrollStudent(Long classroomId, Long studentId);
    
    // Remove a student from a classroom
    void UnenrollStudent(Long classroomId, Long studentId);
    
    // Search for classrooms by name
    List<ClassroomDto> SearchClassroomsByName(String name);
    
    // Get classrooms by subject
    List<ClassroomDto> GetClassroomsBySubject(String subject);
    
    // Get comprehensive course details including all related information
    CourseDetailsDto GetCourseDetails(Long classroomId);

    List<User> getStudentsInClassroom(Long classroomId);

    List<ClassroomDto> GetClassroomsByCurrentTeacher();

    List<ClassroomDto> getClassroomsByCurrentStudent();

    ClassroomDetailsDto findClassroomDetailsById(Long classroomId);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/CourseFeedbackService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.CourseFeedbackDto;

public interface CourseFeedbackService {
    
    // Create new feedback
    CourseFeedbackDto createFeedback(CourseFeedbackDto feedbackDto);
    
    // Get feedback by ID
    CourseFeedbackDto getFeedbackById(Long feedbackId);
    
    // Get all feedback by student
    List<CourseFeedbackDto> getFeedbackByStudent(Long studentId);
    
    // Get all feedback for a classroom
    List<CourseFeedbackDto> getFeedbackByClassroom(Long classroomId);
    
    // Get all feedback for a teacher
    List<CourseFeedbackDto> getFeedbackByTeacher(Long teacherId);
    
    // Get feedback by status
    List<CourseFeedbackDto> getFeedbackByStatus(String status);
    
    // Get feedback by category
    List<CourseFeedbackDto> getFeedbackByCategory(String category);
    
    // Get feedback by rating range
    List<CourseFeedbackDto> getFeedbackByRatingRange(Integer minRating, Integer maxRating);
    
    // Search feedback
    List<CourseFeedbackDto> searchFeedback(String keyword);
    
    // Get recent feedback
    List<CourseFeedbackDto> getRecentFeedback(Integer days);
    
    // Get anonymous feedback
    List<CourseFeedbackDto> getAnonymousFeedback();
    
    // Review feedback (by teacher or admin)
    CourseFeedbackDto reviewFeedback(Long feedbackId, String response, Long reviewerId);
    
    // Acknowledge feedback
    CourseFeedbackDto acknowledgeFeedback(Long feedbackId);
    
    // Check if student already gave feedback for classroom
    boolean hasStudentGivenFeedback(Long studentId, Long classroomId);
    
    // Get average rating for classroom
    Double getAverageRatingByClassroom(Long classroomId);
    
    // Get average teaching quality for teacher
    Double getAverageTeachingQualityByTeacher(Long teacherId);
    
    // Count feedback by status for teacher
    Long countFeedbackByTeacherAndStatus(Long teacherId, String status);
    
    // Delete feedback
    void deleteFeedback(Long feedbackId);
    
    // Get all feedback (admin only)
    List<CourseFeedbackDto> getAllFeedback();
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/CourseMaterialService.java">
package com.classroomapp.classroombackend.service;

import com.classroomapp.classroombackend.dto.CourseMaterialDto;
import com.classroomapp.classroombackend.dto.UploadMaterialDto;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface CourseMaterialService {
    
    /**
     * Upload a new course material
     */
    CourseMaterialDto uploadMaterial(UploadMaterialDto uploadDto, MultipartFile file, Long uploadedBy);
    
    /**
     * Get all materials for a classroom
     */
    List<CourseMaterialDto> getMaterialsByClassroom(Long classroomId);
    
    /**
     * Get public materials for a classroom
     */
    List<CourseMaterialDto> getPublicMaterialsByClassroom(Long classroomId);
    
    /**
     * Get material by ID
     */
    CourseMaterialDto getMaterialById(Long materialId);
    
    /**
     * Update material details (title, description, visibility)
     */
    CourseMaterialDto updateMaterial(Long materialId, UploadMaterialDto updateDto);
    
    /**
     * Delete a material
     */
    void deleteMaterial(Long materialId);
    
    /**
     * Download material (increments download count)
     */
    byte[] downloadMaterial(Long materialId);
    
    /**
     * Search materials by title or description
     */
    List<CourseMaterialDto> searchMaterials(Long classroomId, String searchTerm);
    
    /**
     * Get materials by file type
     */
    List<CourseMaterialDto> getMaterialsByFileType(Long classroomId, String fileType);
    
    /**
     * Get materials uploaded by a user
     */
    List<CourseMaterialDto> getMaterialsByUploader(Long uploadedBy);
    
    /**
     * Get total download statistics for a classroom
     */
    Long getTotalDownloadsByClassroom(Long classroomId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/CourseService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.classroommanagement.CourseDetailsDto;

public interface CourseService {
    List<CourseDetailsDto> getAllCourses();
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/EducationalRoleService.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/EmailService.java">
package com.classroomapp.classroombackend.service;

/**
 * Service interface for email operations
 */
public interface EmailService {
    /**
     * Send an email notification
     * @param to Recipient email address
     * @param subject Email subject
     * @param body Email body (can be HTML)
     */
    void sendEmail(String to, String subject, String body);
    
    /**
     * Send a notification for a request status change
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param requestedRole The role that was requested
     * @param status The new status (APPROVED/REJECTED)
     * @param reason The reason for rejection (if applicable)
     */
    void sendRequestStatusNotification(String to, String fullName, String requestedRole, String status, String reason);
    
    /**
     * Send account information with credentials
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param role User's role
     * @param username Username for login
     * @param password Temporary password
     */
    void sendAccountInfoEmail(String to, String fullName, String role, String username, String password);
    
    /**
     * Send a form completion confirmation
     * @param to Recipient email address
     * @param fullName Recipient's full name
     * @param requestedRole The role that was requested
     */
    void sendFormCompletionConfirmation(String to, String fullName, String requestedRole);

    /**
     * Send an approval email with a temporary password.
     * @param to Recipient email address
     * @param fullName The user's full name
     * @param roleName The user's assigned role
     * @param temporaryPassword The generated temporary password for the user
     */
    void sendApprovalEmail(String to, String fullName, String roleName, String temporaryPassword);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/ExamService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamDto;

public interface ExamService {
    ExamDto createExam(CreateExamDto createExamDto);
    List<ExamDto> getExamsByClassroomId(Long classroomId);
    ExamDto getExamById(Long examId);
    ExamDto updateExam(Long examId, CreateExamDto createExamDto);
    void deleteExam(Long examId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/ExamSubmissionService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.exammangement.CreateExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.ExamSubmissionDto;
import com.classroomapp.classroombackend.dto.exammangement.GradeExamDto;

public interface ExamSubmissionService {

    /**
     * Creates a new submission record when a student starts an exam.
     * @param examId The ID of the exam being started.
     * @return The created exam submission.
     */
    ExamSubmissionDto startExam(Long examId);

    /**
     * Submits the answers for an ongoing exam submission.
     * @param submissionId The ID of the submission record created by startExam.
     * @param submissionDto The DTO containing the submission content.
     * @return The updated exam submission.
     */
    ExamSubmissionDto submitExam(Long submissionId, CreateExamSubmissionDto submissionDto);

    /**
     * Retrieves all submissions for a specific exam. (For teachers/admins)
     * @param examId The ID of the exam.
     * @return A list of all submissions.
     */
    List<ExamSubmissionDto> getSubmissionsForExam(Long examId);

    /**
     * Retrieves a student's submission for a specific exam.
     * @param examId The ID of the exam.
     * @return The student's submission.
     */
    ExamSubmissionDto getStudentSubmissionForExam(Long examId);

    /**
     * Grades an exam submission. (For teachers/admins)
     * @param submissionId The ID of the submission to grade.
     * @param gradeDto The DTO containing the grade and feedback.
     * @return The graded submission.
     */
    ExamSubmissionDto gradeSubmission(Long submissionId, GradeExamDto gradeDto);

} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/FileStorageService.java">
package com.classroomapp.classroombackend.service;

import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.FileUploadResponse;

public interface FileStorageService {
    /**
     * Saves a file to the storage.
     * @param file the file to save
     * @return metadata about the saved file
     */
    default FileUploadResponse save(MultipartFile file) {
        return save(file, "uploads");
    }

    /**
     * Saves a file to a specific folder in the storage
     * @param file the file to save
     * @param folder the folder to save into
     * @return metadata about the saved file
     */
    FileUploadResponse save(MultipartFile file, String folder);

    /**
     * Deletes a file from the storage.
     * @param fileName the name of the file to delete
     */
    void delete(String fileName);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/LectureMaterialService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import org.springframework.core.io.Resource;
import org.springframework.http.ResponseEntity;
import org.springframework.web.multipart.MultipartFile;

import com.classroomapp.classroombackend.dto.LectureMaterialDto;


public interface LectureMaterialService {
    List<LectureMaterialDto> getMaterialsByLectureId(Long lectureId);
    LectureMaterialDto storeFile(MultipartFile file, Long lectureId, String userEmail);
    void deleteFile(Long materialId, String userEmail);
    ResponseEntity<Resource> getFile(Long materialId);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/LectureService.java">
package com.classroomapp.classroombackend.service;

import java.security.Principal;
import java.util.List;

import com.classroomapp.classroombackend.dto.CreateLectureDto;
import com.classroomapp.classroombackend.dto.FileUploadResponse;
import com.classroomapp.classroombackend.dto.LectureDetailsDto;
import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.LectureMaterialDto;
import com.classroomapp.classroombackend.dto.UpdateLectureDto;

public interface LectureService {
    List<LectureDto> getLecturesByClassroomId(Long classroomId);
    LectureDto createLecture(Long classroomId, CreateLectureDto createLectureDto, String userEmail);
    LectureDetailsDto getLectureById(Long lectureId, Principal principal);
    LectureDto updateLecture(Long lectureId, UpdateLectureDto updateLectureDto, String userEmail);
    void deleteLecture(Long lectureId, String userEmail);
    List<LectureMaterialDto> addMaterials(Long lectureId, List<FileUploadResponse> files, String teacherUsername);
    LectureDto addMaterialToLecture(Long lectureId, LectureMaterialDto lectureMaterialDto);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/MCPTestService.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/RequestService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.RequestDTO;
import com.classroomapp.classroombackend.dto.RequestResponseDTO;
import com.classroomapp.classroombackend.dto.requestmanagement.CreateRequestDto;

public interface RequestService {
    void createRegistrationRequest(CreateRequestDto dto);
    RequestResponseDTO createRequest(RequestDTO requestDTO);
    RequestResponseDTO approveRequest(Long requestId);
    RequestResponseDTO rejectRequest(Long requestId, String reason);
    List<RequestResponseDTO> getPendingRequests();
    List<RequestResponseDTO> getRequestsByEmail(String email);
    boolean hasActiveRequest(String email, String role);
    RequestResponseDTO getRequestDetails(Long requestId);
    List<RequestResponseDTO> getAllRequests();
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/ScheduleService.java">
package com.classroomapp.classroombackend.service;

import java.time.LocalDate;
import java.util.List;

import com.classroomapp.classroombackend.dto.LectureDto;
import com.classroomapp.classroombackend.dto.ScheduleDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;

public interface ScheduleService {
    /**
     * Chuyển đổi lịch học thành sự kiện lịch trình cho người dùng
     */
    List<TimetableEventDto> getTimetableForUser(Long userId, LocalDate startDate, LocalDate endDate);
    
    /**
     * Lấy tất cả lịch học
     */
    List<ScheduleDto> getAllSchedules();
    
    /**
     * Lấy lịch học theo ID
     */
    ScheduleDto getScheduleById(Long id);
    
    /**
     * Lấy lịch học theo ID của giáo viên
     */
    List<ScheduleDto> getSchedulesByTeacherId(Long teacherId);
    
    /**
     * Lấy lịch học theo ID của học sinh
     */
    List<ScheduleDto> getSchedulesByStudentId(Long studentId);
    
    /**
     * Lấy lịch học theo ID của lớp học
     */
    List<ScheduleDto> getSchedulesByClassroomId(Long classroomId);
    
    /**
     * Tạo lịch học mới
     */
    ScheduleDto createSchedule(ScheduleDto scheduleDto);
    
    /**
     * Cập nhật lịch học
     */
    ScheduleDto updateSchedule(Long id, ScheduleDto scheduleDto);
    
    /**
     * Xóa lịch học
     */
    void deleteSchedule(Long id);
    
    /**
     * Tạo lịch học mẫu cho một lớp học
     */
    void createSampleSchedules(Long classroomId);

    /**
     * Lấy lịch học theo giáo viên và ngày trong tuần
     */
    List<ScheduleDto> getSchedulesByTeacherAndDay(Long teacherId, Integer dayOfWeek);

    /**
     * Tạo một entry lịch học mới
     */
    ScheduleDto createScheduleEntry(ScheduleDto scheduleDto);

    /**
     * Get lectures associated with a specific schedule
     */
    List<LectureDto> getLecturesByScheduleId(Long scheduleId);
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/SignalingWebSocketHandler.java">
package com.classroomapp.classroombackend.service;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * WebSocket Handler for Video Conference Signaling
 */
@Component
public class SignalingWebSocketHandler extends TextWebSocketHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(SignalingWebSocketHandler.class);
    
    // Map to store rooms and their sessions
    private final Map<String, Map<WebSocketSession, String>> rooms = new ConcurrentHashMap<>();
    
    // ObjectMapper for JSON parsing
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public void afterConnectionEstablished(@NonNull WebSocketSession session) throws Exception {
        logger.info("New WebSocket connection established: {}", session.getId());
    }
    
    @Override
    public void afterConnectionClosed(@NonNull WebSocketSession session, @NonNull CloseStatus status) throws Exception {
        logger.info("WebSocket connection closed: {} with status: {}", session.getId(), status);
        removeSessionFromAllRooms(session);
    }
    
    @Override
    protected void handleTextMessage(@NonNull WebSocketSession session, @NonNull TextMessage message) throws Exception {
        try {
            JsonNode jsonMessage = objectMapper.readTree(message.getPayload());
            String type = jsonMessage.get("type").asText();
            String roomId = jsonMessage.has("roomId") ? jsonMessage.get("roomId").asText() : null;
            
            logger.info("Received message: {} in room: {}", type, roomId);
            
            switch (type) {
                case "join":
                    handleJoinRoom(session, jsonMessage);
                    break;
                case "offer":
                case "answer":
                case "ice-candidate":
                    forwardMessageToRoom(session, jsonMessage, roomId);
                    break;
                case "leave":
                    handleLeaveRoom(session, roomId);
                    break;
                default:
                    logger.warn("Unknown message type: {}", type);
            }
        } catch (Exception e) {
            logger.error("Error processing message: {}", e.getMessage(), e);
        }
    }
    
    @Override
    public void handleTransportError(@NonNull WebSocketSession session, @NonNull Throwable exception) throws Exception {
        logger.error("Transport error for session {}: {}", session.getId(), exception.getMessage(), exception);
        removeSessionFromAllRooms(session);
    }
    
    /**
     * Handle user joining a room
     */
    private void handleJoinRoom(WebSocketSession session, JsonNode message) throws IOException {
        String roomId = message.get("roomId").asText();
        JsonNode user = message.get("user");
        String userId = user.get("id").asText();
        
        // Create room if it doesn't exist
        rooms.putIfAbsent(roomId, new ConcurrentHashMap<>());
        
        // Add session to room
        rooms.get(roomId).put(session, userId);
        
        logger.info("User {} joined room {}. Room size: {}", userId, roomId, rooms.get(roomId).size());
        
        // Notify other clients in the room
        String joinMessage = objectMapper.writeValueAsString(Map.of(
            "type", "user-joined",
            "roomId", roomId,
            "user", objectMapper.readTree(user.toString())
        ));
        
        // Send notification to all other clients in the room
        for (Map.Entry<WebSocketSession, String> entry : rooms.get(roomId).entrySet()) {
            WebSocketSession otherSession = entry.getKey();
            if (!otherSession.equals(session) && otherSession.isOpen()) {
                try {
                    otherSession.sendMessage(new TextMessage(joinMessage));
                } catch (IOException e) {
                    logger.error("Error sending join message to session {}: {}", otherSession.getId(), e.getMessage());
                }
            }
        }
    }
    
    /**
     * Forward message to other clients in the room
     */
    private void forwardMessageToRoom(WebSocketSession sender, JsonNode message, String roomId) {
        Map<WebSocketSession, String> roomSessions = rooms.get(roomId);
        
        if (roomSessions == null || roomSessions.isEmpty()) {
            logger.warn("Room not found or empty: {}", roomId);
            return;
        }
        
        String senderId = message.has("userId") ? message.get("userId").asText() : "";
        String messageText = message.toString();
        
        // Forward message to all other clients in the room
        for (Map.Entry<WebSocketSession, String> entry : roomSessions.entrySet()) {
            WebSocketSession session = entry.getKey();
            String sessionUserId = entry.getValue();
            
            // Don't send back to sender
            if (!session.equals(sender) && !sessionUserId.equals(senderId) && session.isOpen()) {
                try {
                    session.sendMessage(new TextMessage(messageText));
                } catch (IOException e) {
                    logger.error("Error forwarding message to session {}: {}", session.getId(), e.getMessage());
                }
            }
        }
    }
    
    /**
     * Handle user leaving a room
     */
    private void handleLeaveRoom(WebSocketSession session, String roomId) throws IOException {
        Map<WebSocketSession, String> roomSessions = rooms.get(roomId);
        
        if (roomSessions == null || roomSessions.isEmpty()) {
            return;
        }
        
        // Get user ID before removing from room
        String userId = roomSessions.get(session);
        
        // Remove session from room
        roomSessions.remove(session);
        
        logger.info("User {} left room {}", userId, roomId);
        
        // If room is empty, remove it
        if (roomSessions.isEmpty()) {
            rooms.remove(roomId);
            logger.info("Room {} removed because it's empty", roomId);
            return;
        }
        
        // Notify remaining clients in the room
        String leaveMessage = objectMapper.writeValueAsString(Map.of(
            "type", "user-left",
            "roomId", roomId,
            "userId", userId
        ));
        
        // Send notification to all remaining clients in the room
        for (WebSocketSession remainingSession : roomSessions.keySet()) {
            if (remainingSession.isOpen()) {
                try {
                    remainingSession.sendMessage(new TextMessage(leaveMessage));
                } catch (IOException e) {
                    logger.error("Error sending leave message to session {}: {}", remainingSession.getId(), e.getMessage());
                }
            }
        }
    }
    
    /**
     * Remove session from all rooms when connection is closed
     */
    private void removeSessionFromAllRooms(WebSocketSession session) {
        for (Map.Entry<String, Map<WebSocketSession, String>> roomEntry : rooms.entrySet()) {
            String roomId = roomEntry.getKey();
            Map<WebSocketSession, String> roomSessions = roomEntry.getValue();
            
            if (roomSessions.containsKey(session)) {
                String userId = roomSessions.get(session);
                roomSessions.remove(session);
                
                logger.info("User {} disconnected from room {}", userId, roomId);
                
                // If room is empty, remove it
                if (roomSessions.isEmpty()) {
                    rooms.remove(roomId);
                    logger.info("Room {} removed because it's empty", roomId);
                } else {
                    // Notify remaining clients in the room
                    try {
                        String leaveMessage = objectMapper.writeValueAsString(Map.of(
                            "type", "user-left",
                            "roomId", roomId,
                            "userId", userId
                        ));
                        
                        for (WebSocketSession remainingSession : roomSessions.keySet()) {
                            if (remainingSession.isOpen()) {
                                try {
                                    remainingSession.sendMessage(new TextMessage(leaveMessage));
                                } catch (IOException e) {
                                    logger.error("Error sending leave message to session {}: {}", remainingSession.getId(), e.getMessage());
                                }
                            }
                        }
                    } catch (Exception e) {
                        logger.error("Error creating leave message: {}", e.getMessage());
                    }
                }
                
                // Only process the first room found with this session
                break;
            }
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/StudentMessageService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.StudentMessageDto;

public interface StudentMessageService {
    
    // Send a new message
    StudentMessageDto sendMessage(StudentMessageDto messageDto);
    
    // Get message by ID
    StudentMessageDto getMessageById(Long messageId);
    
    // Get messages sent by a user
    List<StudentMessageDto> getSentMessages(Long senderId);
    
    // Get messages received by a user
    List<StudentMessageDto> getReceivedMessages(Long recipientId);
    
    // Get conversation between two users
    List<StudentMessageDto> getConversation(Long user1Id, Long user2Id);
    
    // Get unread messages for a recipient
    List<StudentMessageDto> getUnreadMessages(Long recipientId);
    
    // Get messages by status
    List<StudentMessageDto> getMessagesByStatus(String status);
    
    // Get messages by type
    List<StudentMessageDto> getMessagesByType(String messageType);
    
    // Get messages by priority
    List<StudentMessageDto> getMessagesByPriority(String priority);
    
    // Get urgent messages for a recipient
    List<StudentMessageDto> getUrgentMessages(Long recipientId);
    
    // Search messages
    List<StudentMessageDto> searchMessages(String keyword);
    
    // Get recent messages
    List<StudentMessageDto> getRecentMessages();
    
    // Get pending replies for a recipient
    List<StudentMessageDto> getPendingReplies(Long recipientId);
    
    // Mark message as read
    StudentMessageDto markAsRead(Long messageId);
    
    // Reply to a message
    StudentMessageDto replyToMessage(Long messageId, String reply, Long replierId);
    
    // Resolve a message
    StudentMessageDto resolveMessage(Long messageId);
    
    // Archive a message
    StudentMessageDto archiveMessage(Long messageId);
    
    // Count unread messages for a recipient
    Long countUnreadMessages(Long recipientId);
    
    // Update message priority
    StudentMessageDto updateMessagePriority(Long messageId, String priority);
    
    // Delete a message
    void deleteMessage(Long messageId);
    
    // Get all messages (admin only)
    List<StudentMessageDto> getAllMessages();
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/StudentProgressService.java">
package com.classroomapp.classroombackend.service;

import com.classroomapp.classroombackend.dto.StudentProgressDto;
import com.classroomapp.classroombackend.dto.ProgressAnalyticsDto;
import com.classroomapp.classroombackend.model.StudentProgress;

import java.math.BigDecimal;
import java.util.List;

public interface StudentProgressService {
    
    /**
     * Create or update student progress
     */
    StudentProgressDto createOrUpdateProgress(StudentProgressDto progressDto);
    
    /**
     * Get student progress for a classroom
     */
    List<StudentProgressDto> getStudentProgressByClassroom(Long studentId, Long classroomId);
    
    /**
     * Get progress for a specific assignment
     */
    StudentProgressDto getProgressByAssignment(Long studentId, Long assignmentId);
    
    /**
     * Get overall progress for a student in a classroom
     */
    StudentProgressDto getOverallProgress(Long studentId, Long classroomId);
    
    /**
     * Get all students' progress for a classroom (teacher view)
     */
    List<StudentProgressDto> getAllStudentsProgress(Long classroomId);
    
    /**
     * Get progress analytics for a classroom
     */
    ProgressAnalyticsDto getProgressAnalytics(Long classroomId);
    
    /**
     * Get students with low progress
     */
    List<StudentProgressDto> getStudentsWithLowProgress(Long classroomId, BigDecimal threshold);
    
    /**
     * Update time spent on a specific activity
     */
    StudentProgressDto updateTimeSpent(Long studentId, Long classroomId, 
                                     StudentProgress.ProgressType progressType, Integer minutesSpent);
    
    /**
     * Calculate and update overall progress for a student
     */
    StudentProgressDto calculateOverallProgress(Long studentId, Long classroomId);
    
    /**
     * Get total time spent by student in classroom
     */
    Integer getTotalTimeSpent(Long studentId, Long classroomId);
    
    /**
     * Bulk update progress for multiple students
     */
    List<StudentProgressDto> bulkUpdateProgress(List<StudentProgressDto> progressList);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/StudentQuestionService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.StudentQuestionDto;

public interface StudentQuestionService {
    
    // Create a new question
    StudentQuestionDto createQuestion(StudentQuestionDto questionDto);
    
    // Answer a question
    StudentQuestionDto answerQuestion(Long questionId, String answer, Long teacherId);
    
    // Get question by ID
    StudentQuestionDto getQuestionById(Long questionId);
    
    // Get all questions by student
    List<StudentQuestionDto> getQuestionsByStudent(Long studentId);
    
    // Get all questions for a teacher
    List<StudentQuestionDto> getQuestionsByTeacher(Long teacherId);
    
    // Get pending questions for a teacher
    List<StudentQuestionDto> getPendingQuestionsByTeacher(Long teacherId);
    
    // Get questions by status
    List<StudentQuestionDto> getQuestionsByStatus(String status);
    
    // Get questions by priority
    List<StudentQuestionDto> getQuestionsByPriority(String priority);
    
    // Get conversation between student and teacher
    List<StudentQuestionDto> getConversation(Long studentId, Long teacherId);
    
    // Search questions
    List<StudentQuestionDto> searchQuestions(String keyword);
    
    // Get recent questions
    List<StudentQuestionDto> getRecentQuestions();
    
    // Close a question
    StudentQuestionDto closeQuestion(Long questionId);
    
    // Update question priority
    StudentQuestionDto updateQuestionPriority(Long questionId, String priority);
    
    // Count pending questions for a teacher
    Long countPendingQuestionsByTeacher(Long teacherId);
    
    // Delete a question
    void deleteQuestion(Long questionId);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/SubmissionService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;

import com.classroomapp.classroombackend.dto.assignmentmanagement.CreateSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.GradeSubmissionDto;
import com.classroomapp.classroombackend.dto.assignmentmanagement.SubmissionDto;

public interface SubmissionService {
    
    // Get a submission by ID
    SubmissionDto GetSubmissionById(Long id);
    
    /**
     * Creates or updates a submission for the current user.
     * This method implements an "upsert" logic.
     * @param createSubmissionDto DTO containing submission data.
     * @param studentUsername The username of the student submitting.
     * @return The created or updated submission as a DTO.
     */
    SubmissionDto submit(CreateSubmissionDto createSubmissionDto, String studentUsername);

    /**
     * @deprecated Use submit() instead.
     */
    @Deprecated
    SubmissionDto CreateSubmission(CreateSubmissionDto createSubmissionDto, String studentUsername);
    
    /**
     * @deprecated Use submit() instead.
     */
    @Deprecated
    SubmissionDto UpdateSubmission(Long id, CreateSubmissionDto updateSubmissionDto);
    
    // Delete a submission
    void DeleteSubmission(Long id);
    
    // Get all submissions for an assignment
    List<SubmissionDto> GetSubmissionsByAssignment(Long assignmentId);
    
    // Get all submissions by a student
    List<SubmissionDto> GetSubmissionsByStudent(Long studentId);
    
    // Get a student's submission for an assignment
    SubmissionDto GetStudentSubmissionForAssignment(Long assignmentId, Long studentId);
    
    // Grade a submission
    SubmissionDto GradeSubmission(Long submissionId, GradeSubmissionDto gradeSubmissionDto, String teacherUsername);
    
    // Get all graded submissions for an assignment
    List<SubmissionDto> GetGradedSubmissionsByAssignment(Long assignmentId);
    
    // Get all ungraded submissions for an assignment
    List<SubmissionDto> GetUngradedSubmissionsByAssignment(Long assignmentId);
    
    // Get submission statistics for an assignment
    SubmissionStatistics GetSubmissionStatisticsForAssignment(Long assignmentId);
    
    // Inner class for submission statistics
    class SubmissionStatistics {
        private long totalStudents;
        private long submissionCount;
        private long gradedCount;
        private double averageScore;
        
        // Getters and setters
        public long getTotalStudents() { return totalStudents; }
        public void setTotalStudents(long totalStudents) { this.totalStudents = totalStudents; }
        
        public long getSubmissionCount() { return submissionCount; }
        public void setSubmissionCount(long submissionCount) { this.submissionCount = submissionCount; }
        
        public long getGradedCount() { return gradedCount; }
        public void setGradedCount(long gradedCount) { this.gradedCount = gradedCount; }
        
        public double getAverageScore() { return averageScore; }
        public void setAverageScore(double averageScore) { this.averageScore = averageScore; }
    }
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/TimetableService.java">
package com.classroomapp.classroombackend.service;

import java.time.LocalDateTime;
import java.util.List;

import com.classroomapp.classroombackend.dto.CreateEventDto;
import com.classroomapp.classroombackend.dto.TimetableEventDto;

public interface TimetableService {
    
    /**
     * Create a new timetable event
     */
    TimetableEventDto createEvent(CreateEventDto createDto, Long createdBy);
    
    /**
     * Get event by ID
     */
    TimetableEventDto getEventById(Long eventId);
    
    /**
     * Get events within date range (for all classrooms)
     */
    List<TimetableEventDto> getEventsByDateRange(LocalDateTime startDate, LocalDateTime endDate);
    
    /**
     * Get events for a classroom within date range
     */
    List<TimetableEventDto> getEventsByClassroomAndDateRange(Long classroomId, 
                                                           LocalDateTime startDate, 
                                                           LocalDateTime endDate);
    
    /**
     * Get upcoming events for a classroom
     */
    List<TimetableEventDto> getUpcomingEvents(Long classroomId);
    
    /**
     * Get events by type
     */
    List<TimetableEventDto> getEventsByType(Long classroomId, String eventType);
    
    /**
     * Get all-day events
     */
    List<TimetableEventDto> getAllDayEvents(Long classroomId);
    
    /**
     * Get recurring events
     */
    List<TimetableEventDto> getRecurringEvents(Long classroomId);
    
    /**
     * Update event
     */
    TimetableEventDto updateEvent(Long eventId, CreateEventDto updateDto);
    
    /**
     * Delete event
     */
    void deleteEvent(Long eventId);
    
    /**
     * Cancel event
     */
    TimetableEventDto cancelEvent(Long eventId);
    
    /**
     * Check for conflicting events
     */
    List<TimetableEventDto> checkConflicts(Long classroomId, LocalDateTime startTime, 
                                         LocalDateTime endTime, Long excludeEventId);
    
    /**
     * Get events for multiple classrooms (teacher view)
     */
    List<TimetableEventDto> getEventsByClassrooms(List<Long> classroomIds, 
                                                LocalDateTime startDate, 
                                                LocalDateTime endDate);
    
    /**
     * Add attendee to event
     */
    void addAttendee(Long eventId, Long userId);
    
    /**
     * Remove attendee from event
     */
    void removeAttendee(Long eventId, Long userId);
    
    /**
     * Update attendance status
     */
    void updateAttendanceStatus(Long eventId, Long userId, String status);
    
    /**
     * Get event attendees
     */
    List<TimetableEventDto> getEventAttendees(Long eventId);
    
    /**
     * Create recurring event instances
     */
    List<TimetableEventDto> createRecurringInstances(Long parentEventId, 
                                                    LocalDateTime endDate);
    
    /**
     * Get events created by a user
     */
    List<TimetableEventDto> getEventsByCreator(Long createdBy);

    /**
     * Get timetable events for a specific user (student or teacher)
     * This method will get events from classrooms the user is enrolled in or teaching
     */
    List<TimetableEventDto> getEventsForUser(Long userId, LocalDateTime startDate, LocalDateTime endDate);
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/UserService.java">
package com.classroomapp.classroombackend.service;

import java.util.List;
import java.util.Set;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import com.classroomapp.classroombackend.dto.UserDto;
import com.classroomapp.classroombackend.model.usermanagement.User;

public interface UserService {
    
    /**
     * Find all users
     * @return list of all users
     */
    List<UserDto> FindAllUsers();
    
    /**
     * Find user by ID
     * @param id user ID
     * @return user DTO if found
     */
    UserDto FindUserById(Long id);
    
    /**
     * Find user by username
     * @param username username to search
     * @return user DTO if found
     */
    UserDto FindUserByUsername(String username);
    
    /*
    /**
     * Create a new user
     * @param userDto user information
     * @return created user DTO
     */
    // UserDto CreateUser(UserDto userDto);
    
    /*
    /**
     * Update existing user
     * @param id user ID
     * @param userDto updated user information
     * @return updated user DTO
     */
    // UserDto UpdateUser(Long id, UserDto userDto);
    
    /**
     * Delete user
     * @param id user ID
     */
    void DeleteUser(Long id);
    
    /**
     * Check if username exists
     * @param username username to check
     * @return true if username exists
     */
    boolean IsUsernameExists(String username);
    
    /**
     * Check if email exists
     * @param email email to check
     * @return true if email exists
     */
    boolean IsEmailExists(String email);
    
    /**
     * Find users by role ID
     * @param roleId role ID to filter by
     * @return list of users with specified role
     */
    List<UserDto> FindUsersByRole(Integer roleId);

    void sendPasswordResetEmail(String email, String resetLink);

    Page<UserDto> findAllUsers(String keyword, Pageable pageable);

    UserDto updateUserStatus(Long userId, boolean enabled);

    UserDto updateUserRoles(Long userId, Set<String> roleNames);

    /**
     * Find user entity by email
     * @param email email to search
     * @return User entity if found, null otherwise
     */
    User findUserEntityByEmail(String email);

    List<UserDto> getAllUsers();
}
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/UserServiceExtension.java">
package com.classroomapp.classroombackend.service;

public interface UserServiceExtension {
    /**
     * Update user role
     * @param email User's email
     * @param role New role to set
     * @return true if successful, false otherwise
     */
    boolean updateUserRole(String email, String role);
    
    /**
     * Check if a user exists
     * @param email User's email
     * @return true if exists, false otherwise
     */
    boolean userExists(String email);
    
    /**
     * Create a new user with the given role if they don't exist
     * @param email User's email
     * @param fullName User's full name
     * @param role Role to assign
     * @return true if created or updated, false otherwise
     */
    boolean createOrUpdateUser(String email, String fullName, String role);
} 
</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/VideoConferenceService.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/VietnameseSpeechRecognitionService.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/service/VietnameseTextValidationService.java">
package com.classroomapp.classroombackend.service;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;

/**
 * Service for validating and fixing Vietnamese text encoding issues
 * 
 * This service helps detect corrupted Vietnamese characters and provides
 * methods to validate and fix encoding problems.
 */
@Slf4j
@Service
public class VietnameseTextValidationService {

    // Pattern to detect Vietnamese characters
    private static final Pattern VIETNAMESE_PATTERN = Pattern.compile(
        "[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđ" +
        "ÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸĐ]"
    );

    // Pattern to detect corrupted characters (question marks)
    private static final Pattern CORRUPTION_PATTERN = Pattern.compile("\\?+");

    // Common Vietnamese words for validation
    private static final String[] COMMON_VIETNAMESE_WORDS = {
        "học", "sinh", "giáo", "viên", "lớp", "bài", "tập", "kiểm", "tra",
        "thông", "báo", "hệ", "thống", "quản", "lý", "nội", "dung",
        "thời", "gian", "địa", "điểm", "kết", "quả", "phân", "tích",
        "cải", "thiện", "hoàn", "thiện", "thực", "hiện", "chất", "lượng"
    };

    /**
     * Validates if text contains proper Vietnamese characters
     * 
     * @param text Text to validate
     * @return ValidationResult containing validation status and details
     */
    public ValidationResult validateVietnameseText(String text) {
        if (text == null || text.trim().isEmpty()) {
            return new ValidationResult(true, "Text is empty", null);
        }

        log.debug("🔍 Validating Vietnamese text: {}", text.substring(0, Math.min(text.length(), 50)));

        ValidationResult result = new ValidationResult();
        result.setOriginalText(text);

        // Check for corruption patterns
        if (CORRUPTION_PATTERN.matcher(text).find()) {
            result.setValid(false);
            result.setIssue("Text contains corrupted characters (?)");
            result.setCorruptionDetected(true);
            
            // Count corrupted characters
            long corruptedCount = text.chars().filter(ch -> ch == '?').count();
            result.setCorruptedCharacterCount((int) corruptedCount);
            
            log.warn("❌ Corrupted Vietnamese text detected: {} corrupted characters", corruptedCount);
        }

        // Check encoding integrity
        byte[] utf8Bytes = text.getBytes(StandardCharsets.UTF_8);
        String reconstructed = new String(utf8Bytes, StandardCharsets.UTF_8);
        
        if (!text.equals(reconstructed)) {
            result.setValid(false);
            result.setIssue("Text encoding is corrupted");
            result.setEncodingIssue(true);
            log.warn("❌ Encoding issue detected in Vietnamese text");
        }

        // Check for Vietnamese character presence
        boolean hasVietnameseChars = VIETNAMESE_PATTERN.matcher(text).find();
        result.setContainsVietnameseCharacters(hasVietnameseChars);

        if (result.isValid()) {
            result.setIssue("Text is valid");
            log.debug("✅ Vietnamese text validation passed");
        }

        return result;
    }

    /**
     * Attempts to fix corrupted Vietnamese text
     * 
     * @param corruptedText Text with potential corruption
     * @return Fixed text or original if no fix possible
     */
    public String fixCorruptedVietnameseText(String corruptedText) {
        if (corruptedText == null || !CORRUPTION_PATTERN.matcher(corruptedText).find()) {
            return corruptedText;
        }

        log.info("🔧 Attempting to fix corrupted Vietnamese text");

        String fixedText = corruptedText;

        // Apply common Vietnamese text fixes
        fixedText = fixedText
            .replace("?ng", "ứng")
            .replace("?c", "ức")
            .replace("?i", "ới")
            .replace("?n", "ần")
            .replace("?t", "ất")
            .replace("?m", "ầm")
            .replace("?p", "ập")
            .replace("?nh", "ành")
            .replace("?ch", "ách")
            .replace("?y", "ấy")
            .replace("?u", "ầu")
            .replace("h?", "hệ")
            .replace("th?", "thể")
            .replace("qu?", "quả")
            .replace("tr?", "trước")
            .replace("gi?", "giữa")
            .replace("l?", "lớp")
            .replace("h?c", "học")
            .replace("vi?n", "viên")
            .replace("thi?u", "thiếu")
            // Common phrases
            .replace("L?m r?t t?t", "Làm rất tốt")
            .replace("C?n c?i thi?n", "Cần cải thiện")
            .replace("B?i l?m t?t", "Bài làm tốt")
            .replace("K?t qu? t?t", "Kết quả tốt")
            .replace("Thi?u chi ti?t", "Thiếu chi tiết")
            .replace("C?n b? sung", "Cần bổ sung")
            .replace("R?t t?t", "Rất tốt")
            .replace("T?t l?m", "Tốt lắm")
            .replace("Xu?t s?c", "Xuất sắc")
            .replace("H?y ti?p t?c", "Hãy tiếp tục")
            .replace("C? g?ng h?n", "Cố gắng hơn")
            .replace("L?m t?t h?n", "Làm tốt hơn");

        if (!fixedText.equals(corruptedText)) {
            log.info("✅ Vietnamese text fix applied successfully");
            log.debug("Original: {}", corruptedText);
            log.debug("Fixed: {}", fixedText);
        } else {
            log.warn("⚠️ Could not fix Vietnamese text corruption");
        }

        return fixedText;
    }

    /**
     * Validates and fixes Vietnamese text in one operation
     * 
     * @param text Text to validate and fix
     * @return ProcessingResult with validation and fix results
     */
    public ProcessingResult processVietnameseText(String text) {
        ValidationResult validation = validateVietnameseText(text);
        String processedText = text;

        if (!validation.isValid() && validation.isCorruptionDetected()) {
            processedText = fixCorruptedVietnameseText(text);
            
            // Re-validate after fix
            ValidationResult postFixValidation = validateVietnameseText(processedText);
            
            return new ProcessingResult(
                validation,
                processedText,
                postFixValidation,
                !processedText.equals(text)
            );
        }

        return new ProcessingResult(validation, processedText, validation, false);
    }

    /**
     * Checks if text is likely Vietnamese based on character patterns
     * 
     * @param text Text to check
     * @return true if text appears to be Vietnamese
     */
    public boolean isVietnameseText(String text) {
        if (text == null || text.trim().isEmpty()) {
            return false;
        }

        // Check for Vietnamese characters
        if (VIETNAMESE_PATTERN.matcher(text).find()) {
            return true;
        }

        // Check for common Vietnamese words
        String lowerText = text.toLowerCase();
        for (String word : COMMON_VIETNAMESE_WORDS) {
            if (lowerText.contains(word)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Result class for Vietnamese text validation
     */
    public static class ValidationResult {
        private boolean valid = true;
        private String issue;
        private String originalText;
        private boolean corruptionDetected = false;
        private boolean encodingIssue = false;
        private boolean containsVietnameseCharacters = false;
        private int corruptedCharacterCount = 0;

        public ValidationResult() {}

        public ValidationResult(boolean valid, String issue, String originalText) {
            this.valid = valid;
            this.issue = issue;
            this.originalText = originalText;
        }

        // Getters and setters
        public boolean isValid() { return valid; }
        public void setValid(boolean valid) { this.valid = valid; }
        
        public String getIssue() { return issue; }
        public void setIssue(String issue) { this.issue = issue; }
        
        public String getOriginalText() { return originalText; }
        public void setOriginalText(String originalText) { this.originalText = originalText; }
        
        public boolean isCorruptionDetected() { return corruptionDetected; }
        public void setCorruptionDetected(boolean corruptionDetected) { this.corruptionDetected = corruptionDetected; }
        
        public boolean isEncodingIssue() { return encodingIssue; }
        public void setEncodingIssue(boolean encodingIssue) { this.encodingIssue = encodingIssue; }
        
        public boolean isContainsVietnameseCharacters() { return containsVietnameseCharacters; }
        public void setContainsVietnameseCharacters(boolean containsVietnameseCharacters) { 
            this.containsVietnameseCharacters = containsVietnameseCharacters; 
        }
        
        public int getCorruptedCharacterCount() { return corruptedCharacterCount; }
        public void setCorruptedCharacterCount(int corruptedCharacterCount) { 
            this.corruptedCharacterCount = corruptedCharacterCount; 
        }
    }

    /**
     * Result class for Vietnamese text processing
     */
    public static class ProcessingResult {
        private final ValidationResult originalValidation;
        private final String processedText;
        private final ValidationResult finalValidation;
        private final boolean wasFixed;

        public ProcessingResult(ValidationResult originalValidation, String processedText, 
                              ValidationResult finalValidation, boolean wasFixed) {
            this.originalValidation = originalValidation;
            this.processedText = processedText;
            this.finalValidation = finalValidation;
            this.wasFixed = wasFixed;
        }

        public ValidationResult getOriginalValidation() { return originalValidation; }
        public String getProcessedText() { return processedText; }
        public ValidationResult getFinalValidation() { return finalValidation; }
        public boolean wasFixed() { return wasFixed; }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/test/CriticalFixesTestRunner.java">
package com.classroomapp.classroombackend.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import com.classroomapp.classroombackend.repository.assignmentmanagement.AssignmentRepository;
import com.classroomapp.classroombackend.service.impl.AccomplishmentServiceImpl;
import com.classroomapp.classroombackend.service.impl.AttendanceServiceImpl;

/**
 * Test runner to verify critical fixes are working
 */
@Component
@Profile("test")
public class CriticalFixesTestRunner implements ApplicationRunner {

    private static final Logger log = LoggerFactory.getLogger(CriticalFixesTestRunner.class);

    @Autowired
    private AttendanceServiceImpl attendanceService;

    @Autowired
    private AccomplishmentServiceImpl accomplishmentService;

    @Autowired
    private AssignmentRepository assignmentRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        log.info("🧪 [CriticalFixesTestRunner] Starting critical fixes verification...");

        try {
            // Test 1: Check if assignments can be queried (tests dueDate column mapping)
            log.info("Test 1: Checking Assignment entity column mapping...");
            long assignmentCount = assignmentRepository.count();
            log.info("✅ Assignment count: {}", assignmentCount);

            // Test 2: Check AccomplishmentService can be instantiated
            log.info("Test 2: Checking AccomplishmentService instantiation...");
            if (accomplishmentService != null) {
                log.info("✅ AccomplishmentService instantiated successfully");
            }

            // Test 3: Check AttendanceService can be instantiated
            log.info("Test 3: Checking AttendanceService instantiation...");
            if (attendanceService != null) {
                log.info("✅ AttendanceService instantiated successfully");
            }

            log.info("🎉 [CriticalFixesTestRunner] All critical fixes verified successfully!");

        } catch (Exception e) {
            log.error("❌ [CriticalFixesTestRunner] Critical fix verification failed: {}", e.getMessage(), e);
            throw e;
        }
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/util/EntityScanVerifier.java">
package com.classroomapp.classroombackend.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import jakarta.persistence.EntityManager;
import jakarta.persistence.metamodel.EntityType;
import lombok.extern.slf4j.Slf4j;

/**
 * Utility to verify all JPA entities are properly scanned by Hibernate
 * This will run on application startup and log all detected entities
 */
@Component
@Slf4j
public class EntityScanVerifier implements CommandLineRunner {

    @Autowired
    private EntityManager entityManager;

    @Override
    public void run(String... args) throws Exception {
        log.info("🔍 Verifying Entity Scanning for Hibernate + SQL Server...");
        
        var metamodel = entityManager.getMetamodel();
        var entities = metamodel.getEntities();
        
        log.info("✅ Found {} entities:", entities.size());
        
        for (EntityType<?> entity : entities) {
            String entityName = entity.getName();
            String javaType = entity.getJavaType().getSimpleName();
            String packageName = entity.getJavaType().getPackageName();
            
            log.info("📋 Entity: {} (Class: {}) in package: {}", 
                entityName, javaType, packageName);
        }
        
        log.info("✅ Entity scanning verification completed!");
        log.info("🗄️ Hibernate will now create/update tables in SQL Server");
    }
}

</file>
<file path="src/main/java/com/classroomapp/classroombackend/util/PasswordHasher.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/websocket/VideoConferenceSignalingServer.java">

</file>
<file path="src/main/java/com/classroomapp/classroombackend/ClassroomBackendApplication.java">
package com.classroomapp.classroombackend;

import java.nio.charset.StandardCharsets;
import java.util.List;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import com.classroomapp.classroombackend.config.seed.ClassroomEnrollmentSeeder;
import com.classroomapp.classroombackend.config.seed.ClassroomSeeder;
import com.classroomapp.classroombackend.config.seed.LectureSeeder;
import com.classroomapp.classroombackend.config.seed.RoleSeeder;
import com.classroomapp.classroombackend.config.seed.UserSeeder;
import com.classroomapp.classroombackend.model.classroommanagement.Classroom;

@SpringBootApplication
@EnableCaching
@Configuration
@ComponentScan(basePackages = "com.classroomapp.classroombackend")
public class ClassroomBackendApplication implements WebMvcConfigurer {
    
    public static void main(String[] args) {
        System.setProperty("file.encoding", "UTF-8");
        SpringApplication.run(ClassroomBackendApplication.class, args);
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new StringHttpMessageConverter(StandardCharsets.UTF_8));
    }

    @Bean
    public CommandLineRunner commandLineRunner(RoleSeeder roleSeeder, UserSeeder userSeeder, ClassroomSeeder classroomSeeder, ClassroomEnrollmentSeeder enrollmentSeeder, LectureSeeder lectureSeeder) {
        return args -> {
            System.out.println("--- Seeding Database ---");
            roleSeeder.seed();
            userSeeder.seed();
            List<Classroom> seededClassrooms = classroomSeeder.seed();

            // Enroll students. This seeder will find users and classrooms on its own.
            enrollmentSeeder.seed();

            // Now create lectures for those classrooms
            lectureSeeder.seed(seededClassrooms);
            System.out.println("--- Seeding Complete ---");
        };
    }
}
</file>
<file path="src/main/resources/static/sample_materials/sample.pdf">
%PDF-1.4
1 0 obj
<</Type /Catalog /Pages 2 0 R>>
endobj
2 0 obj
<</Type /Pages /Kids [3 0 R] /Count 1>>
endobj
3 0 obj
<</Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 6 0 R>>
endobj
4 0 obj
<</Font <</F1 5 0 R>>>>
endobj
5 0 obj
<</Type /Font /Subtype /Type1 /BaseFont /Helvetica>>
endobj
6 0 obj
<</Length 44>>
stream
BT /F1 24 Tf 100 700 Td (Sample PDF Document) Tj ET
endstream
endobj
xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000056 00000 n
0000000111 00000 n
0000000212 00000 n
0000000250 00000 n
0000000317 00000 n
trailer
<</Size 7 /Root 1 0 R>>
startxref
406
%%EOF 
</file>
<file path="src/main/resources/static/architecture.txt">
Classroom Management Application Architecture
==

┌───────────────────┐     ┌────────────────────┐     ┌───────────────────┐
│                   │     │                    │     │                   │
│  API Controllers  │────▶│     Services      │────▶│    Repositories   │
│                   │     │                   │     │                   │
└───────────────────┘     └────────────────────┘     └───────────────────┘
         │                          │                          │
         │                          │                          │
         ▼                          ▼                          ▼
┌───────────────────┐     ┌────────────────────┐     ┌───────────────────┐
│                   │     │                    │     │                   │
│      DTOs         │     │ Service Impl       │     │     Entities      │
│                   │     │                    │     │                   │
└───────────────────┘     └────────────────────┘     └───────────────────┘
                                    │                          │
                                    │                          │
                                    ▼                          ▼
                           ┌────────────────────┐     ┌───────────────────┐
                           │                    │     │                   │
                           │     Mappers        │────▶│     Database      │
                           │                    │     │                   │
                           └────────────────────┘     └───────────────────┘
                        
┌───────────────────────────────────────────────────────────────────────┐
│                          Cross-Cutting Concerns                       │
├───────────────────┬───────────────────┬───────────────────┬───────────┤
│  Security Config  │  Exception        │  Data Loader      │  Util     │
│                   │  Handling         │                   │           │
└───────────────────┴───────────────────┴───────────────────┴───────────┘

Component Descriptions:
----------------------
* API Controllers: Handle HTTP requests/responses and route to services
* DTOs: Data Transfer Objects for API payload
* Services: Define business operations (interfaces)
* Service Impl: Implement business logic
* Repositories: Data access layer using Spring Data JPA
* Entities: JPA entity classes mapped to database tables
* Mappers: Convert between DTOs and Entities
* Cross-Cutting Concerns: Components affecting multiple layers

Data Flow:
---------
1. Client request → Controllers
2. Controllers convert request to DTOs
3. DTOs passed to Services
4. Services implement business logic
5. Repositories interface with database
6. Response flows back through Services → Controllers → Client 
</file>
<file path="src/main/resources/templates/email/request-approved.html">
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .header {
            background-color: #52c41a;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
        }
        .success {
            color: #52c41a;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Yêu cầu đã được chấp thuận</h1>
    </div>
    <div class="content">
        <p>Kính gửi <span th:text="${name}"></span>,</p>
        
        <p>Chúng tôi vui mừng thông báo rằng yêu cầu đăng ký vai trò <strong th:text="${role}"></strong> của bạn đã được chấp thuận.</p>
        
        <p class="success">Tài khoản của bạn đã được cập nhật với vai trò mới.</p>
        
        <p>Bạn có thể đăng nhập vào hệ thống ngay bây giờ để sử dụng các tính năng mới.</p>
        
        <p>Nếu bạn có bất kỳ câu hỏi nào, vui lòng liên hệ với chúng tôi.</p>
        
        <p>Trân trọng,<br>
        Đội ngũ MVS Classroom</p>
    </div>
</body>
</html> 
</file>
<file path="src/main/resources/templates/email/request-received.html">
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .header {
            background-color: #52c41a;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Xác nhận đã nhận yêu cầu</h1>
    </div>
    <div class="content">
        <p>Kính gửi <span th:text="${name}"></span>,</p>

        <p>Chúng tôi đã nhận được yêu cầu đăng ký vai trò <strong th:text="${role}"></strong> của bạn.</p>

        <p>Yêu cầu của bạn đang được xem xét. Chúng tôi sẽ thông báo cho bạn ngay khi có kết quả.</p>

        <p>Nếu bạn có bất kỳ câu hỏi nào, vui lòng liên hệ với chúng tôi.</p>

        <p>Trân trọng,<br>
        Đội ngũ MVS Classroom</p>
    </div>
</body>
</html>

</file>
<file path="src/main/resources/templates/email/request-rejected.html">
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .header {
            background-color: #ff4d4f;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
        }
        .reason {
            background-color: #fff1f0;
            border: 1px solid #ffccc7;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Thông báo về yêu cầu của bạn</h1>
    </div>
    <div class="content">
        <p>Kính gửi <span th:text="${name}"></span>,</p>
        
        <p>Chúng tôi rất tiếc phải thông báo rằng yêu cầu đăng ký vai trò <strong th:text="${role}"></strong> của bạn đã bị từ chối.</p>
        
        <div class="reason">
            <p><strong>Lý do:</strong></p>
            <p th:text="${reason}"></p>
        </div>
        
        <p>Nếu bạn có bất kỳ thắc mắc nào hoặc muốn biết thêm thông tin, vui lòng liên hệ với chúng tôi.</p>
        
        <p>Trân trọng,<br>
        Đội ngũ MVS Classroom</p>
    </div>
</body>
</html> 
</file>
<file path="src/main/resources/application.properties">
# Character encoding
server.servlet.encoding.charset=UTF-8
server.servlet.encoding.enabled=true
server.servlet.encoding.force=true

# Server Configuration
server.port=8088
server.servlet.context-path=/
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

# Spring Boot Configuration
spring.main.allow-bean-definition-overriding=true
spring.profiles.active=local

# Enable email service
email.service.enabled=true

# Local File Storage Configuration
file.upload.dir=uploads

# SQL Server Database Configuration
spring.datasource.url=jdbc:sqlserver://localhost:1433;databaseName=SchoolManagementDB;encrypt=false;trustServerCertificate=true;sendStringParametersAsUnicode=true;characterEncoding=UTF-8;loginTimeout=30
spring.datasource.username=sa
spring.datasource.password=12345678
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Alternative H2 Database Configuration (for development/testing when SQL Server is not available)
# Uncomment these lines and comment out SQL Server config above if needed
# spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
# spring.datasource.username=sa
# spring.datasource.password=
# spring.datasource.driver-class-name=org.h2.Driver
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
# spring.h2.console.enabled=true

# HikariCP Configuration
# spring.datasource.hikari.connection-timeout=60000
# spring.datasource.hikari.maximum-pool-size=5
# spring.datasource.hikari.minimum-idle=2
# spring.datasource.hikari.auto-commit=false
# spring.datasource.hikari.connection-test-query=SELECT 1

# JPA & Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.SQLServerDialect
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.jpa.properties.hibernate.connection.useUnicode=true
spring.jpa.properties.hibernate.connection.CharSet=UTF-8
spring.jpa.properties.hibernate.connection.characterEncoding=UTF-8

# Database connection validation
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.test-while-idle=true
spring.datasource.hikari.validation-timeout=5000

# JSON Serialization Configuration
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.default-property-inclusion=non_null

# Transaction Management
spring.transaction.default-timeout=30
spring.transaction.rollback-on-commit-failure=true

# Flyway Configuration (Disabled)
spring.flyway.enabled=false

# Application name
spring.application.name=classroom-backend

# Security & JWT Configuration
jwt.secret=MVS490ClassroomApplicationSecretKey2025WithStrongerEntropy@#$%98765
jwt.expiration.ms=86400000

# Email Service Configuration
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=nguyenxuanphilong@gmail.com
spring.mail.password=udnr fpri qgji oqbf
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.timeout=10000
spring.mail.from.email=nguyenxuanphilong@gmail.com
spring.mail.properties.mail.debug=true

# Thymeleaf Configuration
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.cache=false

# Firebase Storage Configuration (enabled for testing)
firebase.enabled=false
firebase.storage.bucket-name=mve-1-ad9e3.appspot.com
firebase.bucket-name=mve-1-ad9e3.appspot.com

# File Upload Configuration
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=10MB

# Disable Flyway to let Hibernate ddl-auto handle the schema
spring.flyway.enabled=false

# Liquibase (another migration tool, disabled for safety)
spring.liquibase.enabled=false

# Encoding Configuration
server.servlet.encoding.charset=UTF-8
server.servlet.encoding.enabled=true
server.servlet.encoding.force=true
spring.mandatory-file-encoding=UTF-8
spring.mvc.pathmatch.matching-strategy=ant_path_matcher
spring.mustache.charset=UTF-8

# Jackson Configuration
spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=Asia/Ho_Chi_Minh
spring.jackson.default-property-inclusion=non_null

# Logging Configuration
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.org.springframework.web=INFO
logging.level.org.springframework.boot.web.embedded.tomcat=INFO
logging.level.com.classroomapp=DEBUG
logging.level.com.classroomapp.classroombackend.filter.JwtAuthenticationFilter=DEBUG
logging.level.com.classroomapp.classroombackend.security=DEBUG
logging.level.org.springframework.security=DEBUG

# Jitsi Configuration
jitsi.domain=meet.jit.si
jitsi.app-id=classroom_app

</file>
<file path="src/main/resources/sep490-e5896-firebase-adminsdk-fbsvc-402079bade.json">
{
  "type": "service_account",
  "project_id": "sep490-e5896",
  "private_key_id": "402079bade5d095c726b98e12ddc569e79430b6b",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC/KgDQJOghg8/n\nF7rPwbjLg4CJY2UcNJKtV4FVJDAlILqjrQ4Vi9juCpydCjrDtaUNAbaxxBfa1msy\nDPyIYMjZ+lsaOjiRFqfAjlm9eZW6PszSz1AUDx0O2qht63pmCWeqPVLLMeyfGdc4\niAtqkobGOWaV4z8wdAG+vKihWHwgeGjHKEi/tmND+UyyHa/lHKyLkqVHLbNMLsbD\nPK59xPfHDV5CCRCoXzAM2vaGSQxdovARP405St8rYfR5Q+G6EvxuDMsIHeqRAwj1\ncY7qZi7XV2bS5JeQLFNglYwOKmqI6wI83XDosv2XpZgs91PPUeeHMzbqfGLb8AP5\nF83lrsA1AgMBAAECggEAKylzcgunOuv9TOcDd8W8cP0B0GN4EKCBLrDHg58OXM+x\nPGQGPlCrXAHa3y1QW+B/QfrNUoFdRnyryur6ONurdeYMXFVhcMbt/PDXK8wQRbNI\nwV9sK/9GlxRBO8JTikbc2GgMsdLVo42s1beH5lnrosWSl0yuN4U14KhNpdJqAlVw\nxNi7kAZ+diiyZ63JJOKOFyZjr5aF/L4o1DUkRcFLutUtoFgw1phZ//owQ4mOSm0h\n029nx7SO+VMckhmwz0rxHNrA+cqdN8ki4vw0UHXVFba8bfQrVWUBFPviu4ruPuwN\nGXSmKODcXiYn6ks+kRiFdpPX0GIt7eO6GwpSSF2lwQKBgQD8YEBeAwVDWYeyEzMx\ntre1a/K1doyc4+8FSJBamdQlVy0gi3pv7gDJaEjp7K0qEZYxCb7b0okMDo8O9y7n\nLaFEwkAkuqAq76AFLyqj4I17tRkg2s76J7h3Y8iBdjQ9Rdj/UNOJSJWWyuXrlFv7\nFZMyWXFtM2pkrV+JIf3WriyPdQKBgQDB6Lu3OGgo9P1xYxvw2bNb04ZEAh9VF00+\nntPRA4ja18RhGdXAXIKb+YIoqoybNItHHS0efxsnGrHCWqmb5LqLrNKMNnZxeQb2\n4i988IHhc2T3vvBrCnHEMNvWlc4NSw7cwuTOYRNkrik4HNYRIm3HfDxHBwdvJhJK\nPQzfTMoVwQKBgQC8CAptANse/sl3B48Q7w2YgcDnKlhBXCFtUk8a8Zl56KWapdCn\nLDAx3xzUDJ5HxaqdBqHIreelsAMuJ0QuwXRyAjhAJTvIQZh7xFSEnH1NOfRq4htr\njcSGTzXIHwV00WGHd/TjR80L+EetaW/Odpig3rr/nVsbf4C6bzTsigBxMQKBgQC4\n8ChAidrF3UrvXrAiWO94T9iJemC5vhyc8cxhV3aqCgmw9nvoGBM1gZWDBY5O5KFF\ndO04Xc/eztXk4KVNGqxUVMMGmVcDyIM86eKSzauCA5Wzt/cCkBaLIHI7SesYwJJv\nOK4Sq4Fcj8KeUtpTwztie/ndYDXV60Ccb3ecbVd7wQKBgQDCnNJVKtwS8KYwYnqP\nKGDlZ0xW8GK594DnLFiMgyNOR2VGJGhzmcaUSFZ6CpHW4+xZGSNevhiqFjrm4ywD\nKqS3226dJsuSbNaRqJcrtxUkXuaXPxzhSjSIOi9JVcy35NV09zlnqaHwP9h0gLoF\neyQzHzMPpYzfXE3+LgdDCIVoXg==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@sep490-e5896.iam.gserviceaccount.com",
  "client_id": "105247625630886924006",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40sep490-e5896.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}

</file>
<file path=".gitignore">
# Compiled class files
*.class

# Log files
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# Virtual machine crash logs
hs_err_pid*

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# IDE
.idea/
*.iws
*.iml
*.ipr
.vscode/
.settings/
.project
.classpath

# OS
.DS_Store
Thumbs.db

# Application specific
*.properties.backup
application-dev.properties
application-prod.properties
application-local.properties
"src/main/resources/mve-1-firebase-adminsdk.json" 

</file>
<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
         
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.classroomapp</groupId>
    <artifactId>classroom-backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>classroom-backend</name>
    <description>Backend for Classroom Management Application</description>

    <properties>
        <java.version>21</java.version>
    </properties>

    <repositories>
        <!-- Multiple repositories for redundancy -->
        <repository>
            <id>central</id>
            <name>Maven Central</name>
            <url>https://repo1.maven.org/maven2</url>
        </repository>
        <repository>
            <id>google-maven</id>
            <name>Google Maven Repository</name>
            <url>https://maven-central.storage.googleapis.com/maven2/</url>
        </repository>
        <repository>
            <id>spring-releases</id>
            <name>Spring Releases</name>
            <url>https://repo.spring.io/release</url>
        </repository>
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
            <scope>provided</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-hibernate6</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Servlet API (for Filter) -->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Dev & Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Email -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Thymeleaf for email templates -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Firebase -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.2.0</version>
        </dependency>

        <!-- Flyway Migration -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-sqlserver</artifactId>
        </dependency>

        <!-- Google Cloud Storage -->
        <dependency>
            <groupId>com.google.cloud</groupId>
            <artifactId>google-cloud-storage</artifactId>
            <version>2.32.1</version>
        </dependency>

        <!-- File upload -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.14.0</version>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
        </dependency>

        <!-- Spring Test for MockMultipartFile -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.9.1</version>
        </dependency>

        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.1.1</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <!-- Remove Lombok exclusion -->
                    </excludes>
                    <mainClass>com.classroomapp.classroombackend.ClassroomBackendApplication</mainClass>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>1.5.5.Final</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <compilerArg>-Amapstruct.defaultComponentModel=spring</compilerArg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

</file>